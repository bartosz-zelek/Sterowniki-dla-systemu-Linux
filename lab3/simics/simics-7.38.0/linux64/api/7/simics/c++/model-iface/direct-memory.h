// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_DIRECT_MEMORY_H
#define SIMICS_CPP_MODEL_IFACE_DIRECT_MEMORY_H

#include "simics/model-iface/direct-memory.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class DirectMemoryInterface {
  public:
    using ctype = direct_memory_interface_t;

    // Function override and implemented by user
    virtual direct_memory_handle_t get_handle(conf_object_t *requester, uint64 subsystem, uint64 offs, unsigned size) = 0;
    virtual direct_memory_t request(direct_memory_handle_t handle, access_t permission, access_t inhibit) = 0;
    virtual void revoke(access_t access, access_t permission, access_t inhibit) = 0;
    virtual void * get_user_data(direct_memory_handle_t handle) = 0;
    virtual void set_user_data(direct_memory_handle_t handle, void *user_data) = 0;
    virtual void release(direct_memory_handle_t handle) = 0;
    virtual void ack(direct_memory_ack_id_t id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static direct_memory_handle_t get_handle(conf_object_t *obj, conf_object_t *requester, uint64 subsystem, uint64 offs, unsigned size) {
            return detail::get_interface<DirectMemoryInterface>(obj)->get_handle(requester, subsystem, offs, size);
        }
        static direct_memory_t request(conf_object_t *obj, direct_memory_handle_t handle, access_t permission, access_t inhibit) {
            return detail::get_interface<DirectMemoryInterface>(obj)->request(handle, permission, inhibit);
        }
        static void revoke(conf_object_t *obj, access_t access, access_t permission, access_t inhibit) {
            detail::get_interface<DirectMemoryInterface>(obj)->revoke(access, permission, inhibit);
        }
        static void * get_user_data(conf_object_t *obj, direct_memory_handle_t handle) {
            return detail::get_interface<DirectMemoryInterface>(obj)->get_user_data(handle);
        }
        static void set_user_data(conf_object_t *obj, direct_memory_handle_t handle, void *user_data) {
            detail::get_interface<DirectMemoryInterface>(obj)->set_user_data(handle, user_data);
        }
        static void release(conf_object_t *obj, direct_memory_handle_t handle) {
            detail::get_interface<DirectMemoryInterface>(obj)->release(handle);
        }
        static void ack(conf_object_t *obj, direct_memory_ack_id_t id) {
            detail::get_interface<DirectMemoryInterface>(obj)->ack(id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DirectMemoryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        direct_memory_handle_t get_handle(conf_object_t *requester, uint64 subsystem, uint64 offs, unsigned size) const {
            return iface_->get_handle(obj_, requester, subsystem, offs, size);
        }
        direct_memory_t request(direct_memory_handle_t handle, access_t permission, access_t inhibit) const {
            return iface_->request(obj_, handle, permission, inhibit);
        }
        void revoke(access_t access, access_t permission, access_t inhibit) const {
            iface_->revoke(obj_, access, permission, inhibit);
        }
        void * get_user_data(direct_memory_handle_t handle) const {
            return iface_->get_user_data(obj_, handle);
        }
        void set_user_data(direct_memory_handle_t handle, void *user_data) const {
            iface_->set_user_data(obj_, handle, user_data);
        }
        void release(direct_memory_handle_t handle) const {
            iface_->release(obj_, handle);
        }
        void ack(direct_memory_ack_id_t id) const {
            iface_->ack(obj_, id);
        }

        const DirectMemoryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DirectMemoryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DIRECT_MEMORY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DirectMemoryInterface::ctype funcs {
                FromC::get_handle,
                FromC::request,
                FromC::revoke,
                FromC::get_user_data,
                FromC::set_user_data,
                FromC::release,
                FromC::ack,
            };
            return &funcs;
        }
    };
};

class DirectMemoryLookupInterface {
  public:
    using ctype = direct_memory_lookup_interface_t;

    // Function override and implemented by user
    virtual direct_memory_lookup_t lookup(conf_object_t *requester, physical_address_t addr, unsigned size, access_t access) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static direct_memory_lookup_t lookup(conf_object_t *obj, conf_object_t *requester, physical_address_t addr, unsigned size, access_t access) {
            return detail::get_interface<DirectMemoryLookupInterface>(obj)->lookup(requester, addr, size, access);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DirectMemoryLookupInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        direct_memory_lookup_t lookup(conf_object_t *requester, physical_address_t addr, unsigned size, access_t access) const {
            return iface_->lookup(obj_, requester, addr, size, access);
        }

        const DirectMemoryLookupInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DirectMemoryLookupInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DIRECT_MEMORY_LOOKUP_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DirectMemoryLookupInterface::ctype funcs {
                FromC::lookup,
            };
            return &funcs;
        }
    };
};

class DirectMemoryLookupV2Interface {
  public:
    using ctype = direct_memory_lookup_v2_interface_t;

    // Function override and implemented by user
    virtual direct_memory_lookup_t lookup(transaction_t *transaction, physical_address_t addr, access_t access) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static direct_memory_lookup_t lookup(conf_object_t *obj, transaction_t *transaction, physical_address_t addr, access_t access) {
            return detail::get_interface<DirectMemoryLookupV2Interface>(obj)->lookup(transaction, addr, access);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DirectMemoryLookupV2Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        direct_memory_lookup_t lookup(transaction_t *transaction, physical_address_t addr, access_t access) const {
            return iface_->lookup(obj_, transaction, addr, access);
        }

        const DirectMemoryLookupV2Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DirectMemoryLookupV2Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DIRECT_MEMORY_LOOKUP_V2_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DirectMemoryLookupV2Interface::ctype funcs {
                FromC::lookup,
            };
            return &funcs;
        }
    };
};

class DirectMemoryUpdateInterface {
  public:
    using ctype = direct_memory_update_interface_t;

    // Function override and implemented by user
    virtual void release(conf_object_t *target, direct_memory_handle_t handle, direct_memory_ack_id_t id) = 0;
    virtual void update_permission(conf_object_t *target, direct_memory_handle_t handle, access_t lost_access, access_t lost_permission, access_t lost_inhibit, direct_memory_ack_id_t id) = 0;
    virtual void conflicting_access(conf_object_t *target, direct_memory_handle_t handle, access_t conflicting_permission, direct_memory_ack_id_t id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void release(conf_object_t *obj, conf_object_t *target, direct_memory_handle_t handle, direct_memory_ack_id_t id) {
            detail::get_interface<DirectMemoryUpdateInterface>(obj)->release(target, handle, id);
        }
        static void update_permission(conf_object_t *obj, conf_object_t *target, direct_memory_handle_t handle, access_t lost_access, access_t lost_permission, access_t lost_inhibit, direct_memory_ack_id_t id) {
            detail::get_interface<DirectMemoryUpdateInterface>(obj)->update_permission(target, handle, lost_access, lost_permission, lost_inhibit, id);
        }
        static void conflicting_access(conf_object_t *obj, conf_object_t *target, direct_memory_handle_t handle, access_t conflicting_permission, direct_memory_ack_id_t id) {
            detail::get_interface<DirectMemoryUpdateInterface>(obj)->conflicting_access(target, handle, conflicting_permission, id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DirectMemoryUpdateInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void release(conf_object_t *target, direct_memory_handle_t handle, direct_memory_ack_id_t id) const {
            iface_->release(obj_, target, handle, id);
        }
        void update_permission(conf_object_t *target, direct_memory_handle_t handle, access_t lost_access, access_t lost_permission, access_t lost_inhibit, direct_memory_ack_id_t id) const {
            iface_->update_permission(obj_, target, handle, lost_access, lost_permission, lost_inhibit, id);
        }
        void conflicting_access(conf_object_t *target, direct_memory_handle_t handle, access_t conflicting_permission, direct_memory_ack_id_t id) const {
            iface_->conflicting_access(obj_, target, handle, conflicting_permission, id);
        }

        const DirectMemoryUpdateInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DirectMemoryUpdateInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DIRECT_MEMORY_UPDATE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DirectMemoryUpdateInterface::ctype funcs {
                FromC::release,
                FromC::update_permission,
                FromC::conflicting_access,
            };
            return &funcs;
        }
    };
};

class DirectMemoryFlushInterface {
  public:
    using ctype = direct_memory_flush_interface_t;

    // Function override and implemented by user
    virtual void revoke(uint64 base, uint64 size, access_t access, access_t perm, access_t inhibit) = 0;
    virtual bool set_access_bits(conf_object_t *requester, uint64 base, uint64 size, access_t access) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void revoke(conf_object_t *obj, uint64 base, uint64 size, access_t access, access_t perm, access_t inhibit) {
            detail::get_interface<DirectMemoryFlushInterface>(obj)->revoke(base, size, access, perm, inhibit);
        }
        static bool set_access_bits(conf_object_t *obj, conf_object_t *requester, uint64 base, uint64 size, access_t access) {
            return detail::get_interface<DirectMemoryFlushInterface>(obj)->set_access_bits(requester, base, size, access);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DirectMemoryFlushInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void revoke(uint64 base, uint64 size, access_t access, access_t perm, access_t inhibit) const {
            iface_->revoke(obj_, base, size, access, perm, inhibit);
        }
        bool set_access_bits(conf_object_t *requester, uint64 base, uint64 size, access_t access) const {
            return iface_->set_access_bits(obj_, requester, base, size, access);
        }

        const DirectMemoryFlushInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DirectMemoryFlushInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DIRECT_MEMORY_FLUSH_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DirectMemoryFlushInterface::ctype funcs {
                FromC::revoke,
                FromC::set_access_bits,
            };
            return &funcs;
        }
    };
};

class DirectMemoryTagsInterface {
  public:
    using ctype = direct_memory_tags_interface_t;

    // Function override and implemented by user
    virtual direct_memory_tags_t get_tags_data(direct_memory_handle_t handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static direct_memory_tags_t get_tags_data(conf_object_t *obj, direct_memory_handle_t handle) {
            return detail::get_interface<DirectMemoryTagsInterface>(obj)->get_tags_data(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DirectMemoryTagsInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        direct_memory_tags_t get_tags_data(direct_memory_handle_t handle) const {
            return iface_->get_tags_data(obj_, handle);
        }

        const DirectMemoryTagsInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DirectMemoryTagsInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DIRECT_MEMORY_TAGS_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DirectMemoryTagsInterface::ctype funcs {
                FromC::get_tags_data,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
