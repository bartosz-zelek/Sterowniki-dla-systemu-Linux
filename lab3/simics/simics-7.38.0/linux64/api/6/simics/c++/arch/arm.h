// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_ARCH_ARM_H
#define SIMICS_CPP_ARCH_ARM_H

#include "simics/arch/arm.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class ArmInterface {
  public:
    using ctype = arm_interface_t;

    // Function override and implemented by user
    virtual uint64 read_register_mode(int reg_num, int mode) = 0;
    virtual void write_register_mode(int reg_num, int mode, uint64 value) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 read_register_mode(conf_object_t *processor_obj, int reg_num, int mode) {
            return detail::get_interface<ArmInterface>(processor_obj)->read_register_mode(reg_num, mode);
        }
        static void write_register_mode(conf_object_t *processor_obj, int reg_num, int mode, uint64 value) {
            detail::get_interface<ArmInterface>(processor_obj)->write_register_mode(reg_num, mode, value);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 read_register_mode(int reg_num, int mode) const {
            return iface_->read_register_mode(obj_, reg_num, mode);
        }
        void write_register_mode(int reg_num, int mode, uint64 value) const {
            iface_->write_register_mode(obj_, reg_num, mode, value);
        }

        const ArmInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmInterface::ctype funcs {
                FromC::read_register_mode,
                FromC::write_register_mode,
            };
            return &funcs;
        }
    };
};

class ArmCoprocessorInterface {
  public:
    using ctype = arm_coprocessor_interface_t;

    // Function override and implemented by user
    virtual void process_data(uint32 CRd, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) = 0;
    virtual void load_coprocessor(uint32 CRd, uint32 N, uint32 Options, uint32 value, int type) = 0;
    virtual uint32 read_register(uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) = 0;
    virtual void write_register(uint32 value, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) = 0;
    virtual uint64 read_register_64_bit(uint32 opcode_1, uint32 CRm, int type) = 0;
    virtual void write_register_64_bit(uint64 value, uint32 opcode_1, uint32 CRm, int type) = 0;
    virtual uint32 store_coprocessor(uint32 CRd, uint32 N, uint32 Options, int type) = 0;
    virtual void reset(int hard_reset) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void process_data(conf_object_t *obj, uint32 CRd, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) {
            detail::get_interface<ArmCoprocessorInterface>(obj)->process_data(CRd, opcode_1, CRn, CRm, opcode_2, type);
        }
        static void load_coprocessor(conf_object_t *obj, uint32 CRd, uint32 N, uint32 Options, uint32 value, int type) {
            detail::get_interface<ArmCoprocessorInterface>(obj)->load_coprocessor(CRd, N, Options, value, type);
        }
        static uint32 read_register(conf_object_t *obj, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) {
            return detail::get_interface<ArmCoprocessorInterface>(obj)->read_register(opcode_1, CRn, CRm, opcode_2, type);
        }
        static void write_register(conf_object_t *obj, uint32 value, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) {
            detail::get_interface<ArmCoprocessorInterface>(obj)->write_register(value, opcode_1, CRn, CRm, opcode_2, type);
        }
        static uint64 read_register_64_bit(conf_object_t *obj, uint32 opcode_1, uint32 CRm, int type) {
            return detail::get_interface<ArmCoprocessorInterface>(obj)->read_register_64_bit(opcode_1, CRm, type);
        }
        static void write_register_64_bit(conf_object_t *obj, uint64 value, uint32 opcode_1, uint32 CRm, int type) {
            detail::get_interface<ArmCoprocessorInterface>(obj)->write_register_64_bit(value, opcode_1, CRm, type);
        }
        static uint32 store_coprocessor(conf_object_t *obj, uint32 CRd, uint32 N, uint32 Options, int type) {
            return detail::get_interface<ArmCoprocessorInterface>(obj)->store_coprocessor(CRd, N, Options, type);
        }
        static void reset(conf_object_t *obj, int hard_reset) {
            detail::get_interface<ArmCoprocessorInterface>(obj)->reset(hard_reset);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmCoprocessorInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void process_data(uint32 CRd, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) const {
            iface_->process_data(obj_, CRd, opcode_1, CRn, CRm, opcode_2, type);
        }
        void load_coprocessor(uint32 CRd, uint32 N, uint32 Options, uint32 value, int type) const {
            iface_->load_coprocessor(obj_, CRd, N, Options, value, type);
        }
        uint32 read_register(uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) const {
            return iface_->read_register(obj_, opcode_1, CRn, CRm, opcode_2, type);
        }
        void write_register(uint32 value, uint32 opcode_1, uint32 CRn, uint32 CRm, uint32 opcode_2, int type) const {
            iface_->write_register(obj_, value, opcode_1, CRn, CRm, opcode_2, type);
        }
        uint64 read_register_64_bit(uint32 opcode_1, uint32 CRm, int type) const {
            return iface_->read_register_64_bit(obj_, opcode_1, CRm, type);
        }
        void write_register_64_bit(uint64 value, uint32 opcode_1, uint32 CRm, int type) const {
            iface_->write_register_64_bit(obj_, value, opcode_1, CRm, type);
        }
        uint32 store_coprocessor(uint32 CRd, uint32 N, uint32 Options, int type) const {
            return iface_->store_coprocessor(obj_, CRd, N, Options, type);
        }
        void reset(int hard_reset) const {
            iface_->reset(obj_, hard_reset);
        }

        const ArmCoprocessorInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmCoprocessorInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_COPROCESSOR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmCoprocessorInterface::ctype funcs {
                FromC::process_data,
                FromC::load_coprocessor,
                FromC::read_register,
                FromC::write_register,
                FromC::read_register_64_bit,
                FromC::write_register_64_bit,
                FromC::store_coprocessor,
                FromC::reset,
            };
            return &funcs;
        }
    };
};

class ArmAvicInterface {
  public:
    using ctype = arm_avic_interface_t;

    // Function override and implemented by user
    virtual arm_avic_t get_interrupt_address() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static arm_avic_t get_interrupt_address(conf_object_t *obj) {
            return detail::get_interface<ArmAvicInterface>(obj)->get_interrupt_address();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmAvicInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        arm_avic_t get_interrupt_address() const {
            return iface_->get_interrupt_address(obj_);
        }

        const ArmAvicInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmAvicInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_AVIC_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmAvicInterface::ctype funcs {
                FromC::get_interrupt_address,
            };
            return &funcs;
        }
    };
};

class ArmTrustzoneInterface {
  public:
    using ctype = arm_trustzone_interface_t;

    // Function override and implemented by user
    virtual arm_trustzone_mode_t get_security_mode() = 0;
    virtual arm_trustzone_mode_t mem_op_security_mode(generic_transaction_t *memop) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static arm_trustzone_mode_t get_security_mode(conf_object_t *obj) {
            return detail::get_interface<ArmTrustzoneInterface>(obj)->get_security_mode();
        }
        static arm_trustzone_mode_t mem_op_security_mode(conf_object_t *obj, generic_transaction_t *memop) {
            return detail::get_interface<ArmTrustzoneInterface>(obj)->mem_op_security_mode(memop);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmTrustzoneInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        arm_trustzone_mode_t get_security_mode() const {
            return iface_->get_security_mode(obj_);
        }
        arm_trustzone_mode_t mem_op_security_mode(generic_transaction_t *memop) const {
            return iface_->mem_op_security_mode(obj_, memop);
        }

        const ArmTrustzoneInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmTrustzoneInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_TRUSTZONE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmTrustzoneInterface::ctype funcs {
                FromC::get_security_mode,
                FromC::mem_op_security_mode,
            };
            return &funcs;
        }
    };
};

class ArmExternalDebugInterface {
  public:
    using ctype = arm_external_debug_interface_t;

    // Function override and implemented by user
    virtual void handle_semihosting() = 0;
    virtual uint64 read_reg(int offset) = 0;
    virtual void write_reg(int offset, uint64 v) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void handle_semihosting(conf_object_t *obj) {
            detail::get_interface<ArmExternalDebugInterface>(obj)->handle_semihosting();
        }
        static uint64 read_reg(conf_object_t *obj, int offset) {
            return detail::get_interface<ArmExternalDebugInterface>(obj)->read_reg(offset);
        }
        static void write_reg(conf_object_t *obj, int offset, uint64 v) {
            detail::get_interface<ArmExternalDebugInterface>(obj)->write_reg(offset, v);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmExternalDebugInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void handle_semihosting() const {
            iface_->handle_semihosting(obj_);
        }
        uint64 read_reg(int offset) const {
            return iface_->read_reg(obj_, offset);
        }
        void write_reg(int offset, uint64 v) const {
            iface_->write_reg(obj_, offset, v);
        }

        const ArmExternalDebugInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmExternalDebugInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_EXTERNAL_DEBUG_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmExternalDebugInterface::ctype funcs {
                FromC::handle_semihosting,
                FromC::read_reg,
                FromC::write_reg,
            };
            return &funcs;
        }
    };
};

class ArmGicInterface {
  public:
    using ctype = arm_gic_interface_t;

    // Function override and implemented by user
    virtual uint64 read_register(gic_reg_info_t reg_info, bool inquiry) = 0;
    virtual void write_register(gic_reg_info_t reg_info, uint64 value) = 0;
    virtual void cpu_state_changed(arm_cpu_state_t cpu_state) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 read_register(conf_object_t *obj, gic_reg_info_t reg_info, bool inquiry) {
            return detail::get_interface<ArmGicInterface>(obj)->read_register(reg_info, inquiry);
        }
        static void write_register(conf_object_t *obj, gic_reg_info_t reg_info, uint64 value) {
            detail::get_interface<ArmGicInterface>(obj)->write_register(reg_info, value);
        }
        static void cpu_state_changed(conf_object_t *obj, arm_cpu_state_t cpu_state) {
            detail::get_interface<ArmGicInterface>(obj)->cpu_state_changed(cpu_state);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmGicInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 read_register(gic_reg_info_t reg_info, bool inquiry) const {
            return iface_->read_register(obj_, reg_info, inquiry);
        }
        void write_register(gic_reg_info_t reg_info, uint64 value) const {
            iface_->write_register(obj_, reg_info, value);
        }
        void cpu_state_changed(arm_cpu_state_t cpu_state) const {
            iface_->cpu_state_changed(obj_, cpu_state);
        }

        const ArmGicInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmGicInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_GIC_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmGicInterface::ctype funcs {
                FromC::read_register,
                FromC::write_register,
                FromC::cpu_state_changed,
            };
            return &funcs;
        }
    };
};

class ArmGicCpuStateInterface {
  public:
    using ctype = arm_gic_cpu_state_interface_t;

    // Function override and implemented by user
    virtual arm_cpu_state_t get_cpu_state() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static arm_cpu_state_t get_cpu_state(conf_object_t *obj) {
            return detail::get_interface<ArmGicCpuStateInterface>(obj)->get_cpu_state();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmGicCpuStateInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        arm_cpu_state_t get_cpu_state() const {
            return iface_->get_cpu_state(obj_);
        }

        const ArmGicCpuStateInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmGicCpuStateInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_GIC_CPU_STATE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmGicCpuStateInterface::ctype funcs {
                FromC::get_cpu_state,
            };
            return &funcs;
        }
    };
};

class ArmCpuGroupExclusiveInterface {
  public:
    using ctype = arm_cpu_group_exclusive_interface_t;

    // Function override and implemented by user
    virtual void mark_exclusive(physical_address_t address, physical_address_t size) = 0;
    virtual bool clear_and_probe_exclusive(physical_address_t clear_address, physical_address_t clear_size, physical_address_t probe_address, physical_address_t probe_size) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void mark_exclusive(conf_object_t *obj, physical_address_t address, physical_address_t size) {
            detail::get_interface<ArmCpuGroupExclusiveInterface>(obj)->mark_exclusive(address, size);
        }
        static bool clear_and_probe_exclusive(conf_object_t *obj, physical_address_t clear_address, physical_address_t clear_size, physical_address_t probe_address, physical_address_t probe_size) {
            return detail::get_interface<ArmCpuGroupExclusiveInterface>(obj)->clear_and_probe_exclusive(clear_address, clear_size, probe_address, probe_size);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmCpuGroupExclusiveInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void mark_exclusive(physical_address_t address, physical_address_t size) const {
            iface_->mark_exclusive(obj_, address, size);
        }
        bool clear_and_probe_exclusive(physical_address_t clear_address, physical_address_t clear_size, physical_address_t probe_address, physical_address_t probe_size) const {
            return iface_->clear_and_probe_exclusive(obj_, clear_address, clear_size, probe_address, probe_size);
        }

        const ArmCpuGroupExclusiveInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmCpuGroupExclusiveInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_CPU_GROUP_EXCLUSIVE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmCpuGroupExclusiveInterface::ctype funcs {
                FromC::mark_exclusive,
                FromC::clear_and_probe_exclusive,
            };
            return &funcs;
        }
    };
};

class ArmCpuGroupEventInterface {
  public:
    using ctype = arm_cpu_group_event_interface_t;

    // Function override and implemented by user
    virtual void signal_event() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void signal_event(conf_object_t *obj) {
            detail::get_interface<ArmCpuGroupEventInterface>(obj)->signal_event();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmCpuGroupEventInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void signal_event() const {
            iface_->signal_event(obj_);
        }

        const ArmCpuGroupEventInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmCpuGroupEventInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_CPU_GROUP_EVENT_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmCpuGroupEventInterface::ctype funcs {
                FromC::signal_event,
            };
            return &funcs;
        }
    };
};

class ArmCpuGroupTlbInterface {
  public:
    using ctype = arm_cpu_group_tlb_interface_t;

    // Function override and implemented by user
    virtual void invalidate_tlb(arm_translation_regime_t translation_regime, bool by_virtual_address, logical_address_t virtual_address) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void invalidate_tlb(conf_object_t *obj, arm_translation_regime_t translation_regime, bool by_virtual_address, logical_address_t virtual_address) {
            detail::get_interface<ArmCpuGroupTlbInterface>(obj)->invalidate_tlb(translation_regime, by_virtual_address, virtual_address);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ArmCpuGroupTlbInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void invalidate_tlb(arm_translation_regime_t translation_regime, bool by_virtual_address, logical_address_t virtual_address) const {
            iface_->invalidate_tlb(obj_, translation_regime, by_virtual_address, virtual_address);
        }

        const ArmCpuGroupTlbInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ArmCpuGroupTlbInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ARM_CPU_GROUP_TLB_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ArmCpuGroupTlbInterface::ctype funcs {
                FromC::invalidate_tlb,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
