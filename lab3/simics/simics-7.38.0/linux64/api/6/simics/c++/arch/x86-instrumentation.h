// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_ARCH_X86_INSTRUMENTATION_H
#define SIMICS_CPP_ARCH_X86_INSTRUMENTATION_H

#include "simics/arch/x86-instrumentation.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class X86InstructionQueryInterface {
  public:
    using ctype = x86_instruction_query_interface_t;

    // Function override and implemented by user
    virtual linear_address_t linear_address(instruction_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static linear_address_t linear_address(conf_object_t *cpu, instruction_handle_t *handle) {
            return detail::get_interface<X86InstructionQueryInterface>(cpu)->linear_address(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86InstructionQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        linear_address_t linear_address(instruction_handle_t *handle) const {
            return iface_->linear_address(obj_, handle);
        }

        const X86InstructionQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86InstructionQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_INSTRUCTION_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86InstructionQueryInterface::ctype funcs {
                FromC::linear_address,
            };
            return &funcs;
        }
    };
};

class X86MemoryQueryInterface {
  public:
    using ctype = x86_memory_query_interface_t;

    // Function override and implemented by user
    virtual linear_address_t linear_address(memory_handle_t *handle) = 0;
    virtual x86_seg_t segment(memory_handle_t *handle) = 0;
    virtual x86_access_type_t access_type(memory_handle_t *handle) = 0;
    virtual x86_memory_type_t memory_type(memory_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static linear_address_t linear_address(conf_object_t *cpu, memory_handle_t *handle) {
            return detail::get_interface<X86MemoryQueryInterface>(cpu)->linear_address(handle);
        }
        static x86_seg_t segment(conf_object_t *cpu, memory_handle_t *handle) {
            return detail::get_interface<X86MemoryQueryInterface>(cpu)->segment(handle);
        }
        static x86_access_type_t access_type(conf_object_t *obj, memory_handle_t *handle) {
            return detail::get_interface<X86MemoryQueryInterface>(obj)->access_type(handle);
        }
        static x86_memory_type_t memory_type(conf_object_t *obj, memory_handle_t *handle) {
            return detail::get_interface<X86MemoryQueryInterface>(obj)->memory_type(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86MemoryQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        linear_address_t linear_address(memory_handle_t *handle) const {
            return iface_->linear_address(obj_, handle);
        }
        x86_seg_t segment(memory_handle_t *handle) const {
            return iface_->segment(obj_, handle);
        }
        x86_access_type_t access_type(memory_handle_t *handle) const {
            return iface_->access_type(obj_, handle);
        }
        x86_memory_type_t memory_type(memory_handle_t *handle) const {
            return iface_->memory_type(obj_, handle);
        }

        const X86MemoryQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86MemoryQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_MEMORY_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86MemoryQueryInterface::ctype funcs {
                FromC::linear_address,
                FromC::segment,
                FromC::access_type,
                FromC::memory_type,
            };
            return &funcs;
        }
    };
};

class X86ExceptionQueryInterface {
  public:
    using ctype = x86_exception_query_interface_t;

    // Function override and implemented by user
    virtual uint8 vector(exception_handle_t *handle) = 0;
    virtual x86_exception_source_t source(exception_handle_t *handle) = 0;
    virtual uint32 error_code(exception_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint8 vector(conf_object_t *cpu, exception_handle_t *handle) {
            return detail::get_interface<X86ExceptionQueryInterface>(cpu)->vector(handle);
        }
        static x86_exception_source_t source(conf_object_t *cpu, exception_handle_t *handle) {
            return detail::get_interface<X86ExceptionQueryInterface>(cpu)->source(handle);
        }
        static uint32 error_code(conf_object_t *cpu, exception_handle_t *handle) {
            return detail::get_interface<X86ExceptionQueryInterface>(cpu)->error_code(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86ExceptionQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint8 vector(exception_handle_t *handle) const {
            return iface_->vector(obj_, handle);
        }
        x86_exception_source_t source(exception_handle_t *handle) const {
            return iface_->source(obj_, handle);
        }
        uint32 error_code(exception_handle_t *handle) const {
            return iface_->error_code(obj_, handle);
        }

        const X86ExceptionQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86ExceptionQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_EXCEPTION_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86ExceptionQueryInterface::ctype funcs {
                FromC::vector,
                FromC::source,
                FromC::error_code,
            };
            return &funcs;
        }
    };
};

class X86AddressQueryInterface {
  public:
    using ctype = x86_address_query_interface_t;

    // Function override and implemented by user
    virtual x86_seg_t segment(address_handle_t *handle) = 0;
    virtual page_crossing_info_t get_page_crossing_info(address_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static x86_seg_t segment(conf_object_t *cpu, address_handle_t *handle) {
            return detail::get_interface<X86AddressQueryInterface>(cpu)->segment(handle);
        }
        static page_crossing_info_t get_page_crossing_info(conf_object_t *cpu, address_handle_t *handle) {
            return detail::get_interface<X86AddressQueryInterface>(cpu)->get_page_crossing_info(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86AddressQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        x86_seg_t segment(address_handle_t *handle) const {
            return iface_->segment(obj_, handle);
        }
        page_crossing_info_t get_page_crossing_info(address_handle_t *handle) const {
            return iface_->get_page_crossing_info(obj_, handle);
        }

        const X86AddressQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86AddressQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_ADDRESS_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86AddressQueryInterface::ctype funcs {
                FromC::segment,
                FromC::get_page_crossing_info,
            };
            return &funcs;
        }
    };
};

class X86InstrumentationSubscribeInterface {
  public:
    using ctype = x86_instrumentation_subscribe_interface_t;

    // Function override and implemented by user
    virtual cpu_cb_handle_t * register_mode_switch_cb(conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_illegal_instruction_cb(conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_cb_handle_t * register_mode_switch_cb(conf_object_t *cpu, conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<X86InstrumentationSubscribeInterface>(cpu)->register_mode_switch_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_illegal_instruction_cb(conf_object_t *cpu, conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) {
            return detail::get_interface<X86InstrumentationSubscribeInterface>(cpu)->register_illegal_instruction_cb(connection, cb, disass_cb, data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86InstrumentationSubscribeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_cb_handle_t * register_mode_switch_cb(conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_mode_switch_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_illegal_instruction_cb(conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) const {
            return iface_->register_illegal_instruction_cb(obj_, connection, cb, disass_cb, data);
        }

        const X86InstrumentationSubscribeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86InstrumentationSubscribeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_INSTRUMENTATION_SUBSCRIBE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86InstrumentationSubscribeInterface::ctype funcs {
                FromC::register_mode_switch_cb,
                FromC::register_illegal_instruction_cb,
            };
            return &funcs;
        }
    };
};

class X86InstrumentationSubscribeV2Interface {
  public:
    using ctype = x86_instrumentation_subscribe_v2_interface_t;

    // Function override and implemented by user
    virtual cpu_cb_handle_t * register_mode_enter_cb(conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_mode_leave_cb(conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_illegal_instruction_cb(conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_cb_handle_t * register_mode_enter_cb(conf_object_t *cpu, conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<X86InstrumentationSubscribeV2Interface>(cpu)->register_mode_enter_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_mode_leave_cb(conf_object_t *cpu, conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<X86InstrumentationSubscribeV2Interface>(cpu)->register_mode_leave_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_illegal_instruction_cb(conf_object_t *cpu, conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) {
            return detail::get_interface<X86InstrumentationSubscribeV2Interface>(cpu)->register_illegal_instruction_cb(connection, cb, disass_cb, data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86InstrumentationSubscribeV2Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_cb_handle_t * register_mode_enter_cb(conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_mode_enter_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_mode_leave_cb(conf_object_t *connection, x86_mode_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_mode_leave_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_illegal_instruction_cb(conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) const {
            return iface_->register_illegal_instruction_cb(obj_, connection, cb, disass_cb, data);
        }

        const X86InstrumentationSubscribeV2Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86InstrumentationSubscribeV2Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_INSTRUMENTATION_SUBSCRIBE_V2_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86InstrumentationSubscribeV2Interface::ctype funcs {
                FromC::register_mode_enter_cb,
                FromC::register_mode_leave_cb,
                FromC::register_illegal_instruction_cb,
            };
            return &funcs;
        }
    };
};

class VmxInstrumentationSubscribeInterface {
  public:
    using ctype = vmx_instrumentation_subscribe_interface_t;

    // Function override and implemented by user
    virtual cpu_cb_handle_t * register_vmx_mode_leave_cb(conf_object_t *connection, vmx_mode_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_vmx_mode_enter_cb(conf_object_t *connection, vmx_mode_switch_cb_t cb, lang_void *user_data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_cb_handle_t * register_vmx_mode_leave_cb(conf_object_t *cpu, conf_object_t *connection, vmx_mode_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<VmxInstrumentationSubscribeInterface>(cpu)->register_vmx_mode_leave_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_vmx_mode_enter_cb(conf_object_t *cpu, conf_object_t *connection, vmx_mode_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<VmxInstrumentationSubscribeInterface>(cpu)->register_vmx_mode_enter_cb(connection, cb, user_data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const VmxInstrumentationSubscribeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_cb_handle_t * register_vmx_mode_leave_cb(conf_object_t *connection, vmx_mode_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_vmx_mode_leave_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_vmx_mode_enter_cb(conf_object_t *connection, vmx_mode_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_vmx_mode_enter_cb(obj_, connection, cb, user_data);
        }

        const VmxInstrumentationSubscribeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const VmxInstrumentationSubscribeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return VMX_INSTRUMENTATION_SUBSCRIBE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr VmxInstrumentationSubscribeInterface::ctype funcs {
                FromC::register_vmx_mode_leave_cb,
                FromC::register_vmx_mode_enter_cb,
            };
            return &funcs;
        }
    };
};

class SmmInstrumentationSubscribeInterface {
  public:
    using ctype = smm_instrumentation_subscribe_interface_t;

    // Function override and implemented by user
    virtual cpu_cb_handle_t * register_smm_enter_before_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_smm_enter_after_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_smm_leave_before_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) = 0;
    virtual cpu_cb_handle_t * register_smm_leave_after_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_cb_handle_t * register_smm_enter_before_cb(conf_object_t *cpu, conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<SmmInstrumentationSubscribeInterface>(cpu)->register_smm_enter_before_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_smm_enter_after_cb(conf_object_t *cpu, conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<SmmInstrumentationSubscribeInterface>(cpu)->register_smm_enter_after_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_smm_leave_before_cb(conf_object_t *cpu, conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<SmmInstrumentationSubscribeInterface>(cpu)->register_smm_leave_before_cb(connection, cb, user_data);
        }
        static cpu_cb_handle_t * register_smm_leave_after_cb(conf_object_t *cpu, conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) {
            return detail::get_interface<SmmInstrumentationSubscribeInterface>(cpu)->register_smm_leave_after_cb(connection, cb, user_data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const SmmInstrumentationSubscribeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_cb_handle_t * register_smm_enter_before_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_smm_enter_before_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_smm_enter_after_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_smm_enter_after_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_smm_leave_before_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_smm_leave_before_cb(obj_, connection, cb, user_data);
        }
        cpu_cb_handle_t * register_smm_leave_after_cb(conf_object_t *connection, smm_switch_cb_t cb, lang_void *user_data) const {
            return iface_->register_smm_leave_after_cb(obj_, connection, cb, user_data);
        }

        const SmmInstrumentationSubscribeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const SmmInstrumentationSubscribeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return SMM_INSTRUMENTATION_SUBSCRIBE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr SmmInstrumentationSubscribeInterface::ctype funcs {
                FromC::register_smm_enter_before_cb,
                FromC::register_smm_enter_after_cb,
                FromC::register_smm_leave_before_cb,
                FromC::register_smm_leave_after_cb,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
