// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_SIMULATOR_IFACE_BREAKPOINT_MANAGER_H
#define SIMICS_CPP_SIMULATOR_IFACE_BREAKPOINT_MANAGER_H

#include "simics/simulator-iface/breakpoint-manager.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class BreakpointRegistrationInterface {
  public:
    using ctype = breakpoint_registration_interface_t;

    // Function override and implemented by user
    virtual uint64 register_breakpoint(void (*delete_breakpoint)(cbdata_call_t data, uint64 id), cbdata_register_t delete_data, attr_value_t (*get_properties)(cbdata_call_t data, uint64 id), cbdata_register_t get_properties_data, void (*set_enabled)(cbdata_call_t data, uint64 id, bool enabled), cbdata_register_t set_enabled_data, void (*set_temporary)(cbdata_call_t data, uint64 id, bool temporary), cbdata_register_t set_temporary_data, void (*set_ignore_count)(cbdata_call_t data, uint64 id, uint64 ignore_count), cbdata_register_t set_ignore_count_data) = 0;
    virtual void deleted(uint64 id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 register_breakpoint(conf_object_t *mgr, void (*delete_breakpoint)(cbdata_call_t data, uint64 id), cbdata_register_t delete_data, attr_value_t (*get_properties)(cbdata_call_t data, uint64 id), cbdata_register_t get_properties_data, void (*set_enabled)(cbdata_call_t data, uint64 id, bool enabled), cbdata_register_t set_enabled_data, void (*set_temporary)(cbdata_call_t data, uint64 id, bool temporary), cbdata_register_t set_temporary_data, void (*set_ignore_count)(cbdata_call_t data, uint64 id, uint64 ignore_count), cbdata_register_t set_ignore_count_data) {
            return detail::get_interface<BreakpointRegistrationInterface>(mgr)->register_breakpoint(delete_breakpoint, delete_data, get_properties, get_properties_data, set_enabled, set_enabled_data, set_temporary, set_temporary_data, set_ignore_count, set_ignore_count_data);
        }
        static void deleted(conf_object_t *mgr, uint64 id) {
            detail::get_interface<BreakpointRegistrationInterface>(mgr)->deleted(id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const BreakpointRegistrationInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 register_breakpoint(void (*delete_breakpoint)(cbdata_call_t data, uint64 id), cbdata_register_t delete_data, attr_value_t (*get_properties)(cbdata_call_t data, uint64 id), cbdata_register_t get_properties_data, void (*set_enabled)(cbdata_call_t data, uint64 id, bool enabled), cbdata_register_t set_enabled_data, void (*set_temporary)(cbdata_call_t data, uint64 id, bool temporary), cbdata_register_t set_temporary_data, void (*set_ignore_count)(cbdata_call_t data, uint64 id, uint64 ignore_count), cbdata_register_t set_ignore_count_data) const {
            return iface_->register_breakpoint(obj_, delete_breakpoint, delete_data, get_properties, get_properties_data, set_enabled, set_enabled_data, set_temporary, set_temporary_data, set_ignore_count, set_ignore_count_data);
        }
        void deleted(uint64 id) const {
            iface_->deleted(obj_, id);
        }

        const BreakpointRegistrationInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const BreakpointRegistrationInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return BREAKPOINT_REGISTRATION_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr BreakpointRegistrationInterface::ctype funcs {
                FromC::register_breakpoint,
                FromC::deleted,
            };
            return &funcs;
        }
    };
};

class BreakpointTypeInterface {
  public:
    using ctype = breakpoint_type_interface_t;

    // Function override and implemented by user
    virtual bool register_type(const char *name, conf_object_t *provider, attr_value_t args, const char *cls, const char *iface, attr_value_t docs, bool object_required, bool temporary_default, bool recursive) = 0;
    virtual bool trigger(conf_object_t *provider, uint64 bp_id, conf_object_t *trigger, const char *msg) = 0;
    virtual uint64 get_break_id(uint64 bm_id) = 0;
    virtual uint64 get_manager_id(conf_object_t *provider, uint64 bp_id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static bool register_type(conf_object_t *mgr, const char *name, conf_object_t *provider, attr_value_t args, const char *cls, const char *iface, attr_value_t docs, bool object_required, bool temporary_default, bool recursive) {
            return detail::get_interface<BreakpointTypeInterface>(mgr)->register_type(name, provider, args, cls, iface, docs, object_required, temporary_default, recursive);
        }
        static bool trigger(conf_object_t *mgr, conf_object_t *provider, uint64 bp_id, conf_object_t *trigger, const char *msg) {
            return detail::get_interface<BreakpointTypeInterface>(mgr)->trigger(provider, bp_id, trigger, msg);
        }
        static uint64 get_break_id(conf_object_t *mgr, uint64 bm_id) {
            return detail::get_interface<BreakpointTypeInterface>(mgr)->get_break_id(bm_id);
        }
        static uint64 get_manager_id(conf_object_t *mgr, conf_object_t *provider, uint64 bp_id) {
            return detail::get_interface<BreakpointTypeInterface>(mgr)->get_manager_id(provider, bp_id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const BreakpointTypeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        bool register_type(const char *name, conf_object_t *provider, attr_value_t args, const char *cls, const char *iface, attr_value_t docs, bool object_required, bool temporary_default, bool recursive) const {
            return iface_->register_type(obj_, name, provider, args, cls, iface, docs, object_required, temporary_default, recursive);
        }
        bool trigger(conf_object_t *provider, uint64 bp_id, conf_object_t *trigger, const char *msg) const {
            return iface_->trigger(obj_, provider, bp_id, trigger, msg);
        }
        uint64 get_break_id(uint64 bm_id) const {
            return iface_->get_break_id(obj_, bm_id);
        }
        uint64 get_manager_id(conf_object_t *provider, uint64 bp_id) const {
            return iface_->get_manager_id(obj_, provider, bp_id);
        }

        const BreakpointTypeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const BreakpointTypeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return BREAKPOINT_TYPE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr BreakpointTypeInterface::ctype funcs {
                FromC::register_type,
                FromC::trigger,
                FromC::get_break_id,
                FromC::get_manager_id,
            };
            return &funcs;
        }
    };
};

class BreakpointTypeProviderInterface {
  public:
    using ctype = breakpoint_type_provider_interface_t;

    // Function override and implemented by user
    virtual uint64 register_bp(uint64 bp_id) = 0;
    virtual uint64 add_bp(int flags, attr_value_t data) = 0;
    virtual void remove_bp(uint64 bp_id) = 0;
    virtual char * trace_msg(uint64 bp_id) = 0;
    virtual char * break_msg(uint64 bp_id) = 0;
    virtual char * wait_msg(uint64 bp_id) = 0;
    virtual attr_value_t break_data(uint64 bp_id) = 0;
    virtual attr_value_t values(const char *arg, attr_value_t prev_args) = 0;
    virtual void trace(const char *msg) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 register_bp(conf_object_t *obj, uint64 bp_id) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->register_bp(bp_id);
        }
        static uint64 add_bp(conf_object_t *obj, int flags, attr_value_t data) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->add_bp(flags, data);
        }
        static void remove_bp(conf_object_t *obj, uint64 bp_id) {
            detail::get_interface<BreakpointTypeProviderInterface>(obj)->remove_bp(bp_id);
        }
        static char * trace_msg(conf_object_t *obj, uint64 bp_id) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->trace_msg(bp_id);
        }
        static char * break_msg(conf_object_t *obj, uint64 bp_id) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->break_msg(bp_id);
        }
        static char * wait_msg(conf_object_t *obj, uint64 bp_id) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->wait_msg(bp_id);
        }
        static attr_value_t break_data(conf_object_t *obj, uint64 bp_id) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->break_data(bp_id);
        }
        static attr_value_t values(conf_object_t *obj, const char *arg, attr_value_t prev_args) {
            return detail::get_interface<BreakpointTypeProviderInterface>(obj)->values(arg, prev_args);
        }
        static void trace(conf_object_t *obj, const char *msg) {
            detail::get_interface<BreakpointTypeProviderInterface>(obj)->trace(msg);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const BreakpointTypeProviderInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 register_bp(uint64 bp_id) const {
            return iface_->register_bp(obj_, bp_id);
        }
        uint64 add_bp(int flags, attr_value_t data) const {
            return iface_->add_bp(obj_, flags, data);
        }
        void remove_bp(uint64 bp_id) const {
            iface_->remove_bp(obj_, bp_id);
        }
        char * trace_msg(uint64 bp_id) const {
            return iface_->trace_msg(obj_, bp_id);
        }
        char * break_msg(uint64 bp_id) const {
            return iface_->break_msg(obj_, bp_id);
        }
        char * wait_msg(uint64 bp_id) const {
            return iface_->wait_msg(obj_, bp_id);
        }
        attr_value_t break_data(uint64 bp_id) const {
            return iface_->break_data(obj_, bp_id);
        }
        attr_value_t values(const char *arg, attr_value_t prev_args) const {
            return iface_->values(obj_, arg, prev_args);
        }
        void trace(const char *msg) const {
            iface_->trace(obj_, msg);
        }

        const BreakpointTypeProviderInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const BreakpointTypeProviderInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return BREAKPOINT_TYPE_PROVIDER_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr BreakpointTypeProviderInterface::ctype funcs {
                FromC::register_bp,
                FromC::add_bp,
                FromC::remove_bp,
                FromC::trace_msg,
                FromC::break_msg,
                FromC::wait_msg,
                FromC::break_data,
                FromC::values,
                FromC::trace,
            };
            return &funcs;
        }
    };
};

class BreakpointManagerInterface {
  public:
    using ctype = breakpoint_manager_interface_t;

    // Function override and implemented by user
    virtual attr_value_t list_breakpoints() = 0;
    virtual void delete_breakpoint(uint64 id) = 0;
    virtual attr_value_t get_properties(uint64 id) = 0;
    virtual bool set_enabled(uint64 id, bool enabled) = 0;
    virtual bool set_temporary(uint64 id, bool temporary) = 0;
    virtual bool set_ignore_count(uint64 id, uint64 ignore_count) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static attr_value_t list_breakpoints(conf_object_t *mgr) {
            return detail::get_interface<BreakpointManagerInterface>(mgr)->list_breakpoints();
        }
        static void delete_breakpoint(conf_object_t *mgr, uint64 id) {
            detail::get_interface<BreakpointManagerInterface>(mgr)->delete_breakpoint(id);
        }
        static attr_value_t get_properties(conf_object_t *mgr, uint64 id) {
            return detail::get_interface<BreakpointManagerInterface>(mgr)->get_properties(id);
        }
        static bool set_enabled(conf_object_t *mgr, uint64 id, bool enabled) {
            return detail::get_interface<BreakpointManagerInterface>(mgr)->set_enabled(id, enabled);
        }
        static bool set_temporary(conf_object_t *mgr, uint64 id, bool temporary) {
            return detail::get_interface<BreakpointManagerInterface>(mgr)->set_temporary(id, temporary);
        }
        static bool set_ignore_count(conf_object_t *mgr, uint64 id, uint64 ignore_count) {
            return detail::get_interface<BreakpointManagerInterface>(mgr)->set_ignore_count(id, ignore_count);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const BreakpointManagerInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        attr_value_t list_breakpoints() const {
            return iface_->list_breakpoints(obj_);
        }
        void delete_breakpoint(uint64 id) const {
            iface_->delete_breakpoint(obj_, id);
        }
        attr_value_t get_properties(uint64 id) const {
            return iface_->get_properties(obj_, id);
        }
        bool set_enabled(uint64 id, bool enabled) const {
            return iface_->set_enabled(obj_, id, enabled);
        }
        bool set_temporary(uint64 id, bool temporary) const {
            return iface_->set_temporary(obj_, id, temporary);
        }
        bool set_ignore_count(uint64 id, uint64 ignore_count) const {
            return iface_->set_ignore_count(obj_, id, ignore_count);
        }

        const BreakpointManagerInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const BreakpointManagerInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return BREAKPOINT_MANAGER_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr BreakpointManagerInterface::ctype funcs {
                FromC::list_breakpoints,
                FromC::delete_breakpoint,
                FromC::get_properties,
                FromC::set_enabled,
                FromC::set_temporary,
                FromC::set_ignore_count,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
