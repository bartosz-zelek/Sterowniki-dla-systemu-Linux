// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_COMPONENTS_H
#define SIMICS_CPP_MODEL_IFACE_COMPONENTS_H

#include "simics/model-iface/components.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class ComponentInterface {
  public:
    using ctype = component_interface_t;

    // Function override and implemented by user
    virtual bool pre_instantiate() = 0;
    virtual void post_instantiate() = 0;
    virtual bool create_cell() = 0;
    virtual attr_value_t get_slots() = 0;
    virtual attr_value_t get_slot_objects() = 0;
    virtual attr_value_t get_slot_value(const char *slot) = 0;
    virtual void set_slot_value(const char *slot, attr_value_t value) = 0;
    virtual bool has_slot(const char *slot) = 0;
    virtual bool add_slot(const char *slot) = 0;
    virtual bool del_slot(const char *slot) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static bool pre_instantiate(conf_object_t *obj) {
            return detail::get_interface<ComponentInterface>(obj)->pre_instantiate();
        }
        static void post_instantiate(conf_object_t *obj) {
            detail::get_interface<ComponentInterface>(obj)->post_instantiate();
        }
        static bool create_cell(conf_object_t *obj) {
            return detail::get_interface<ComponentInterface>(obj)->create_cell();
        }
        static attr_value_t get_slots(conf_object_t *obj) {
            return detail::get_interface<ComponentInterface>(obj)->get_slots();
        }
        static attr_value_t get_slot_objects(conf_object_t *obj) {
            return detail::get_interface<ComponentInterface>(obj)->get_slot_objects();
        }
        static attr_value_t get_slot_value(conf_object_t *obj, const char *slot) {
            return detail::get_interface<ComponentInterface>(obj)->get_slot_value(slot);
        }
        static void set_slot_value(conf_object_t *obj, const char *slot, attr_value_t value) {
            detail::get_interface<ComponentInterface>(obj)->set_slot_value(slot, value);
        }
        static bool has_slot(conf_object_t *obj, const char *slot) {
            return detail::get_interface<ComponentInterface>(obj)->has_slot(slot);
        }
        static bool add_slot(conf_object_t *obj, const char *slot) {
            return detail::get_interface<ComponentInterface>(obj)->add_slot(slot);
        }
        static bool del_slot(conf_object_t *obj, const char *slot) {
            return detail::get_interface<ComponentInterface>(obj)->del_slot(slot);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ComponentInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        bool pre_instantiate() const {
            return iface_->pre_instantiate(obj_);
        }
        void post_instantiate() const {
            iface_->post_instantiate(obj_);
        }
        bool create_cell() const {
            return iface_->create_cell(obj_);
        }
        attr_value_t get_slots() const {
            return iface_->get_slots(obj_);
        }
        attr_value_t get_slot_objects() const {
            return iface_->get_slot_objects(obj_);
        }
        attr_value_t get_slot_value(const char *slot) const {
            return iface_->get_slot_value(obj_, slot);
        }
        void set_slot_value(const char *slot, attr_value_t value) const {
            iface_->set_slot_value(obj_, slot, value);
        }
        bool has_slot(const char *slot) const {
            return iface_->has_slot(obj_, slot);
        }
        bool add_slot(const char *slot) const {
            return iface_->add_slot(obj_, slot);
        }
        bool del_slot(const char *slot) const {
            return iface_->del_slot(obj_, slot);
        }

        const ComponentInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ComponentInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return COMPONENT_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ComponentInterface::ctype funcs {
                FromC::pre_instantiate,
                FromC::post_instantiate,
                FromC::create_cell,
                FromC::get_slots,
                FromC::get_slot_objects,
                FromC::get_slot_value,
                FromC::set_slot_value,
                FromC::has_slot,
                FromC::add_slot,
                FromC::del_slot,
            };
            return &funcs;
        }
    };
};

class ConnectorInterface {
  public:
    using ctype = connector_interface_t;

    // Function override and implemented by user
    virtual char * type() = 0;
    virtual bool hotpluggable() = 0;
    virtual bool required() = 0;
    virtual bool multi() = 0;
    virtual connector_direction_t direction() = 0;
    virtual bool add_destination(conf_object_t *connector) = 0;
    virtual bool remove_destination(conf_object_t *connector) = 0;
    virtual attr_value_t destination() = 0;
    virtual void update() = 0;
    virtual bool check(attr_value_t attr) = 0;
    virtual void connect(attr_value_t attr) = 0;
    virtual void disconnect() = 0;
    virtual bool deletion_requested() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static char * type(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->type();
        }
        static bool hotpluggable(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->hotpluggable();
        }
        static bool required(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->required();
        }
        static bool multi(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->multi();
        }
        static connector_direction_t direction(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->direction();
        }
        static bool add_destination(conf_object_t *obj, conf_object_t *connector) {
            return detail::get_interface<ConnectorInterface>(obj)->add_destination(connector);
        }
        static bool remove_destination(conf_object_t *obj, conf_object_t *connector) {
            return detail::get_interface<ConnectorInterface>(obj)->remove_destination(connector);
        }
        static attr_value_t destination(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->destination();
        }
        static void update(conf_object_t *obj) {
            detail::get_interface<ConnectorInterface>(obj)->update();
        }
        static bool check(conf_object_t *obj, attr_value_t attr) {
            return detail::get_interface<ConnectorInterface>(obj)->check(attr);
        }
        static void connect(conf_object_t *obj, attr_value_t attr) {
            detail::get_interface<ConnectorInterface>(obj)->connect(attr);
        }
        static void disconnect(conf_object_t *obj) {
            detail::get_interface<ConnectorInterface>(obj)->disconnect();
        }
        static bool deletion_requested(conf_object_t *obj) {
            return detail::get_interface<ConnectorInterface>(obj)->deletion_requested();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ConnectorInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        char * type() const {
            return iface_->type(obj_);
        }
        bool hotpluggable() const {
            return iface_->hotpluggable(obj_);
        }
        bool required() const {
            return iface_->required(obj_);
        }
        bool multi() const {
            return iface_->multi(obj_);
        }
        connector_direction_t direction() const {
            return iface_->direction(obj_);
        }
        bool add_destination(conf_object_t *connector) const {
            return iface_->add_destination(obj_, connector);
        }
        bool remove_destination(conf_object_t *connector) const {
            return iface_->remove_destination(obj_, connector);
        }
        attr_value_t destination() const {
            return iface_->destination(obj_);
        }
        void update() const {
            iface_->update(obj_);
        }
        bool check(attr_value_t attr) const {
            return iface_->check(obj_, attr);
        }
        void connect(attr_value_t attr) const {
            iface_->connect(obj_, attr);
        }
        void disconnect() const {
            iface_->disconnect(obj_);
        }
        bool deletion_requested() const {
            return iface_->deletion_requested(obj_);
        }

        const ConnectorInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ConnectorInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CONNECTOR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ConnectorInterface::ctype funcs {
                FromC::type,
                FromC::hotpluggable,
                FromC::required,
                FromC::multi,
                FromC::direction,
                FromC::add_destination,
                FromC::remove_destination,
                FromC::destination,
                FromC::update,
                FromC::check,
                FromC::connect,
                FromC::disconnect,
                FromC::deletion_requested,
            };
            return &funcs;
        }
    };
};

class ComponentConnectorInterface {
  public:
    using ctype = component_connector_interface_t;

    // Function override and implemented by user
    virtual attr_value_t get_check_data(conf_object_t *connector) = 0;
    virtual attr_value_t get_connect_data(conf_object_t *connector) = 0;
    virtual bool check(conf_object_t *connector, attr_value_t attr) = 0;
    virtual void connect(conf_object_t *connector, attr_value_t attr) = 0;
    virtual void disconnect(conf_object_t *connector) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static attr_value_t get_check_data(conf_object_t *obj, conf_object_t *connector) {
            return detail::get_interface<ComponentConnectorInterface>(obj)->get_check_data(connector);
        }
        static attr_value_t get_connect_data(conf_object_t *obj, conf_object_t *connector) {
            return detail::get_interface<ComponentConnectorInterface>(obj)->get_connect_data(connector);
        }
        static bool check(conf_object_t *obj, conf_object_t *connector, attr_value_t attr) {
            return detail::get_interface<ComponentConnectorInterface>(obj)->check(connector, attr);
        }
        static void connect(conf_object_t *obj, conf_object_t *connector, attr_value_t attr) {
            detail::get_interface<ComponentConnectorInterface>(obj)->connect(connector, attr);
        }
        static void disconnect(conf_object_t *obj, conf_object_t *connector) {
            detail::get_interface<ComponentConnectorInterface>(obj)->disconnect(connector);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ComponentConnectorInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        attr_value_t get_check_data(conf_object_t *connector) const {
            return iface_->get_check_data(obj_, connector);
        }
        attr_value_t get_connect_data(conf_object_t *connector) const {
            return iface_->get_connect_data(obj_, connector);
        }
        bool check(conf_object_t *connector, attr_value_t attr) const {
            return iface_->check(obj_, connector, attr);
        }
        void connect(conf_object_t *connector, attr_value_t attr) const {
            iface_->connect(obj_, connector, attr);
        }
        void disconnect(conf_object_t *connector) const {
            iface_->disconnect(obj_, connector);
        }

        const ComponentConnectorInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ComponentConnectorInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return COMPONENT_CONNECTOR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ComponentConnectorInterface::ctype funcs {
                FromC::get_check_data,
                FromC::get_connect_data,
                FromC::check,
                FromC::connect,
                FromC::disconnect,
            };
            return &funcs;
        }
    };
};

class DiskComponentInterface {
  public:
    using ctype = disk_component_interface_t;

    // Function override and implemented by user
    virtual uint64 size() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 size(conf_object_t *obj) {
            return detail::get_interface<DiskComponentInterface>(obj)->size();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const DiskComponentInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 size() const {
            return iface_->size(obj_);
        }

        const DiskComponentInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const DiskComponentInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return DISK_COMPONENT_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr DiskComponentInterface::ctype funcs {
                FromC::size,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
