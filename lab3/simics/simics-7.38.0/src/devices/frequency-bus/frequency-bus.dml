dml 1.2;

/*
  Â© 2010 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

device frequency_bus;

import "simics/devs/frequency.dml";

parameter desc = "frequency bus";

parameter documentation =
    "The <class>" + $classname + "</class> class implements a "
    + "bus that distributes a frequency to a set of targets. "
    + "Targets subscribe to the bus via the "
    + "<iface>simple_dispatcher</iface> interface, and frequency changes "
    + "are distributed to subscribers via the "
    + "<iface>frequency_listener</iface> iface. "
    + "The distributed frequency can either be generated by the "
    + "bus itself, or be fetched from a different object "
    + "(e.g., from another frequency bus). "
    + "The input frequency can optionally be scaled before it is distributed.";

header %{
    %}

/* configuration for one target */
struct target_t {
    conf_object_t *object;                 /* the target object */
    const frequency_listener_interface_t *iface; /* target interface pointer */
    char *port_name;                       /* port name */
}

typedef target_t vect target_list_t;

method scale() -> (uint64 numerator, uint64 denominator) {
    local int exact;
    exact = unsigned_multiply_rational($frequency.numerator,
                                       $frequency.denominator,
                                       $scale_factor.numerator,
                                       $scale_factor.denominator,
                                       &numerator, &denominator);
    if (exact == 0) {
        static int log_level = 1;
        log info, log_level: "overflow in frequency scaling - precision lost";
        log_level = 2;
    }
}

method broadcast_frequency() {
    local uint64 numerator;
    local uint64 denominator;
    call $scale() -> (numerator, denominator);

    local target_t *one_target;
    foreach one_target in ($targets.targets) {
        one_target->iface->set(one_target->object,
                               numerator, denominator);
    }
}

method report_frequency(conf_object_t *arg) {
    call $broadcast_frequency();
}

method init() {
    VINIT($targets.targets);
    $frequency.numerator = 1;
    $frequency.denominator = 1;
    $scale_factor.numerator = 1;
    $scale_factor.denominator = 1;
}


method post_init() {
    if ($frequency.denominator == 0) {
        $frequency.denominator = 1;
    }

    // Handle subscriptions from fraction_or_freq_bus.set() which were
    // postponed.
    foreach attr in ([$scale_factor, $frequency]) {
        if (attr.source != NULL) {
            SIM_require_object(attr.source);
            attr.iface->subscribe(attr.source, $dev.obj, NULL);
        }
    }
}

template fraction_listen_iface {
    method set(uint64 numerator, uint64 denominator) {
        if (denominator == 0) {
            log error: "%s.set: zero denominator", $name;
            return;
        }
        if ($attr.source == NULL) {
            log error:
                "%s.set called without subscription - the calling dispatcher should be connected to the bus through the %s attribute",
                $name, $attr.name;
            return;
        }
        call $attr.set_fraction(numerator, denominator);
    }
}

implement frequency_listener {
    is fraction_listen_iface;
    parameter attr = $frequency;
}

implement scale_factor_listener {
    is fraction_listen_iface;
    parameter attr = $scale_factor;
}

implement simple_dispatcher {
    method subscribe(conf_object_t *listener,
                             const char *port) {
        if (!SIM_object_is_configured($dev.obj)) {
            log error:
                "%s.subscribe() called before the bus is configured - the bus may supply an invalid frequency (use SIM_require_object() to avoid this problem)",
                SIMPLE_DISPATCHER_INTERFACE;
        }

        local int duplicate;
        call $targets.find(listener, port) -> (duplicate);
        if (duplicate >= 0) {
            log error:
                "simple_dispatcher.subscribe: object '%s' registered twice on the same port",
                SIM_object_name(listener);
            return;
        }

        local const frequency_listener_interface_t *iface;
        iface = SIM_get_port_interface(listener,
                                       FREQUENCY_LISTENER_INTERFACE, port);
        if (iface == NULL) {
            log error:
                "simple_dispatcher.subscribe: object '%s' (port %s) does not implement the %s interface",
                SIM_object_name(listener), port == NULL ? "none" : port,            
                FREQUENCY_LISTENER_INTERFACE;
            return;
        }

        local target_t one_target;
        one_target.object = listener;
        one_target.port_name = port == NULL ? NULL : MM_STRDUP(port);
        one_target.iface = iface;

        VADD($targets.targets, one_target);

        local uint64 num;
        local uint64 den;
        call $scale() -> (num, den);
        iface->set(listener, num, den);
    }

    method unsubscribe(conf_object_t *listener,
                               const char *port) {
        local int duplicate;
        call $targets.find(listener, port) -> (duplicate);
        if (duplicate < 0) {
            log error:
                "simple_dispatcher.unsubscribe: attempt to unregister nonexisting listener %s (port %s)",
                SIM_object_name(listener), port == NULL ? "none" : port;
        } else {
            MM_FREE($targets.targets[duplicate].port_name);
            VREMOVE($targets.targets, duplicate);
        }
    }
}

attribute targets {
    parameter type = "[[o,s|n]*]";
    parameter configuration = "pseudo";
    parameter documentation =
        "Current frequency target objects, on the form [object, port]";

    data target_list_t targets;

    method get() -> (attr_value_t return_list) {
        return_list = SIM_alloc_attr_list(VLEN($targets));

        local int i;
        for (i = 0; i < SIM_attr_list_size(return_list); i += 1) {
            local target_t *one_target = &$targets[i];
            SIM_attr_list_set_item(
                &return_list, i,
                SIM_make_attr_list(2,
                                   SIM_make_attr_object(one_target->object),
                                   SIM_make_attr_string(one_target->port_name)));
        }
    }

    /* Find whether (target, port) listens to this bus. If so, return
       index in target list; if not, return -1. */
    method find(conf_object_t *target, const char *port) -> (int index) {
        local target_t *old_target;
        foreach old_target in ($targets) {
            local bool equal = true;

            if (old_target->object != target) {
                equal = false;
            } else {
                if (port == NULL) {
                    if (old_target->port_name != NULL)
                        equal = false;
                } else {
                    if (old_target->port_name == NULL
                        || strcmp(old_target->port_name, port) != 0)
                        equal = false;
                }
            }
            if (equal) {
                index = old_target - &$targets[0];
                return;
            }
        }
        index = -1;
        return;
    }
}

template fraction_or_freq_bus {
    parameter type = "o|[ii]|[os]";

    data uint64 numerator;
    data uint64 denominator;
    data conf_object_t *source;
    data char *port;
    data const simple_dispatcher_interface_t *iface;

    method set_fraction(uint64 numerator, uint64 denominator) {
        if ($numerator == numerator
            && $denominator == denominator)
            return;

        $numerator = numerator;
        $denominator = denominator;

        log info, 2: "%s changed to %u/%u",
            $description, numerator, denominator;
        call $broadcast_frequency();
    }

    method set(attr_value_t value) {
        local conf_object_t *new_source;
        local const char *new_port;

        if (SIM_attr_is_list(value)
            && SIM_attr_is_integer(SIM_attr_list_item(value, 0))) {
            call $set_fraction(SIM_attr_integer(SIM_attr_list_item(value, 0)),
                               SIM_attr_integer(SIM_attr_list_item(value, 1)));
            call $broadcast_frequency();
            new_source = NULL;
            new_port = NULL;
        } else if (SIM_attr_is_object(value)) {
            new_source = SIM_attr_object(value);
            new_port = NULL;
        } else {
            new_source = SIM_attr_object(SIM_attr_list_item(value, 0));
            new_port   = SIM_attr_string(SIM_attr_list_item(value, 1));
        }

        local bool equal = new_source == $source;
        if (equal && new_source != NULL) {
            if (new_port == NULL)
                equal = $port == NULL;
            else
                equal = $port != NULL && strcmp(new_port, $port) != 0;
        }
        if (!equal) {
            // Source changed, update subscription
            local const simple_dispatcher_interface_t *new_iface;
            if (new_source != NULL) {
                new_iface = SIM_get_port_interface(new_source,
                                                   SIMPLE_DISPATCHER_INTERFACE,
                                                   new_port);
            } else {
                new_iface = NULL;
            }
            if ($source != NULL)
                $iface->unsubscribe($source, $dev.obj, NULL);
            $source = new_source;
            if ($port != NULL)
                MM_FREE($port);
            $port = new_port == NULL ? NULL : MM_STRDUP(new_port);
            $iface = new_iface;
            // If the bus is not yet configured, the dispatcher might
            // not be either. Then delay subscription until post_init.
            if (SIM_object_is_configured($dev.obj) && new_source != NULL)
                $iface->subscribe($source, $dev.obj, NULL);
        }
    }

    method get() -> (attr_value_t value) {
        if ($source == NULL) {
            value = SIM_make_attr_list(2, SIM_make_attr_uint64($numerator),
                                       SIM_make_attr_uint64($denominator));
        } else if ($port == NULL) {
            value = SIM_make_attr_object($source);
        } else {
            value = SIM_make_attr_list(2, SIM_make_attr_object($source),
                                       SIM_make_attr_string($port));
        }
    }
}

attribute frequency {
    is fraction_or_freq_bus;
    parameter documentation = "The frequency broadcasted by this bus. "
        + "A value of [p, q] means a fix frequency of p/q Hz; "
        + "if the value is an object implementing the "
        + SIMPLE_DISPATCHER_INTERFACE + " interface, "
        + "the frequency is fetched from that object; "
        + "if the value is an [object, port] pair, the frequency is "
        + "fetched from the given port.";
    parameter iface_name = FREQUENCY_LISTENER_INTERFACE;
    parameter description = "Nominal output frequency";
}

attribute scale_factor {
    is fraction_or_freq_bus;
    parameter documentation = "The input frequency is multiplied by this "
        + "number before broadcasted. "
        + "A value of [p, q] means a fix factor of p/q; "
        + "if the value is an object implementing the "
        + SIMPLE_DISPATCHER_INTERFACE + " interface, "
        + "the factor is fetched from that object; "
        + "if the value is an [object, port] pair, the factor is "
        + "fetched from the given port.";
    parameter iface_name = SCALE_FACTOR_LISTENER_INTERFACE;
    parameter description = "Frequency scale factor";
}

attribute current_output_freq {
    parameter documentation
        = "The frequency currently output to connected devices";
    parameter configuration = "pseudo";
    parameter type = "[ii]";
    method get() -> (attr_value_t value) {
        local uint64 num;
        local uint64 den;
        call $scale() -> (num, den);
        value = SIM_make_attr_list(2, SIM_make_attr_uint64(num),
                                   SIM_make_attr_uint64(den));
    }
}
