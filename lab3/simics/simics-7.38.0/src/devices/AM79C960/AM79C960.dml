/*
  AM79C960.dml

  Â© 2010 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// The Linux driver for this card is called 'lance'.

dml 1.4;

device AM79C960;
param desc = "model of AM79C960 Ethernet controller";
param documentation = ("AM79C960 is a rather common ISA Ethernet card, "
                           + "used mostly in old x86 PCs");

param limitations = ("<ul>"
                         + "<li>The model has only been tested with Linux 2."
                         + "4. It is likely to not work with other operating "
                         + "systems. </li>"

                         + "<li>All broadcast packets are received, they are "
                         + "not checked against the Logical Address "
                         + "Filter. </li>"

                         + "<li>Received packets larger than the buffer of "
                         + "the current receive descriptor buffer are "
                         + "dropped, they are not stored to multiple chained "
                         + "descriptors as they should be. </li>"

                         + "<li>Chained transmit descriptors are not "
                         + "supported. The model will get stuck on the first "
                         + "of the chained transmit descriptors. </li>"

                         + "<li>Only the CSR registers that are used by "
                         + "Linux have been implemented. Some of the state "
                         + "of the device that would normally be stored in "
                         + "the CSR registers is instead stored in the "
                         + "attributes logical_address_filter, mac_address, "
                         + "rcv_descr_tbl_addr, rcv_descr_tbl_length, xmt_"
                         + "descr_tbl_addr, xmt_descr_tbl_length, curr_txd, "
                         + "curr_rxd. </li>"

                         + "<li>The ISA bus configuration registers are not "
                         + "implemented. </li>"

                         + "<li>Only the parts of the IEEE address PROM "
                         + "that are used by Linux are implemented.</li>"

                         + "<li>The time it takes to transmit a packet is "
                         + "independent of the packet size. It can be set "
                         + "through the transmit_time attribute. The default "
                         + "it is 1 ms. </li>"

                         + "</ul>");

// Standard imports.

import "utility.dml";
import "internal.dml";

import "simics/devs/interrupt.dml";
import "simics/devs/memory-space.dml";

// We use the ethernet-link interface and implement the ethernet-device
// interfaces, so we need to include ethernet.dml.

import "simics/devs/ethernet.dml";

// These libc functions are not automatically declared in DML
extern int sprintf(char *str, const char *format, ...);
extern int sscanf(const char *str, const char *format, ...);

// Enables soft reset
is sreset;

// The irq_dev and irq_level attributes tell us to what device and at what
// level to send interrupts.

//:: pre am79c960_irq_dev_connect {{
connect irq_dev {
    param documentation = "The device that interrupts are sent to.";
    param configuration = "required";

    interface simple_interrupt;
}
// }}

attribute irq_level is int64_attr {
    param documentation = "The level at which interrupts are sent.";
    param configuration = "required";
}

// Keep track of whether the irq is currently raised.

attribute irq_raised is bool_attr {
    param documentation = "Interrupt is currently raised by device";
    param configuration = "optional";
}

// Used to update the irq whenever an interrupt flag or enable bit is changed.

method update_irq() {
    local int intr = csr.csr0.INTR.read();
    local bool irq = (intr == 1 && csr.csr0.IENA.val == 1);

    if (!irq_raised.val && irq) {
        log info, 3: "raising interrupt";
        irq_dev.simple_interrupt.interrupt(irq_level.val);
    }

    if (irq_raised.val && !irq) {
        log info, 3: "lowering interrupt";
        irq_dev.simple_interrupt.interrupt_clear(irq_level.val);
    }

    irq_raised.val = irq;
}

// Implement the ethernet_common interface for new links

//:: pre am79c960_ethernet_common_implement {{
implement ethernet_common {
    method frame(const frags_t *frame, eth_frame_crc_status_t crc_status) {
        receive_packet(frame);
    }
}
// }}


// The ethernet-link the device is connected to. We keep the link object itself
// in obj and the interface used to communicate with it in iface.
//:: pre ethernet_connect {{
connect link {
    param documentation = "The ethernet-link the device is connected to.";
    interface ethernet_common;
}
// }}

// The memory used to access the initialization data and descriptor
// rings.

connect memory is map_target {
    param documentation = "The memory the device uses to access the "
        + "initialization data and descriptor rings.";
    param configuration = "required";

    // Read length bytes from the address addr and return
    // a callee-owned pointer to a buffer containing the bytes
    method read_addr(physical_address_t addr,
                     physical_address_t length) -> (uint8*) {
        local uint8 *buf = new uint8[length];
        try {
            this.read_bytes(addr, length, buf);
        } catch {
            return NULL;
        }
        return buf;
    }

    // Write the contents of the frags frag to the address addr.
    method write_frags_addr(physical_address_t addr,
                            const frags_t *frag) {
        local uint8 *buf = new uint8[frags_len(frag)];
        frags_extract(frag, buf);
        try {
            this.write_bytes(addr, frags_len(frag), buf);
        } catch {
            log info, 1: "Failed to write frags @ 0x08%x", addr;
        }
        delete buf;
    }
}

// Data structure to hold the information from a transmit descriptor, functions
// to convert between the data structure and the byte layout of the descriptor
// in target memory, and a function to log the contents of a descriptor.

//:: pre am79c960_txd_structure_and_buf_mapping {{
typedef struct {
    physical_address_t addr;
    uint1 OWN;
    uint1 STP;
    uint1 ENP;
    uint16 size;
} txd_t;

method txd_from_buf(uint8* buf) -> (txd_t) {
    local txd_t txd;
    txd.addr = buf[0] | buf[1] << 8 | buf[2] << 16;
    txd.OWN = buf[3][7];
    txd.STP = buf[3][1];
    txd.ENP = buf[3][0];
    txd.size = - (buf[4] | buf[5] << 8);
    return txd;
}

method txd_to_buf(txd_t txd, uint8* buf) {
    local int neg_size = - txd.size;
    buf[0] = txd.addr[7:0];
    buf[1] = txd.addr[15:8];
    buf[2] = txd.addr[23:16];
    buf[3] = (txd.OWN << 7) | (txd.STP << 1) | (txd.ENP << 0);
    buf[4] = neg_size[7:0];
    buf[5] = neg_size[15:8];
    buf[6] = 0;
    buf[7] = 0;
}
// }}

method log_txd(int level, txd_t txd) {
    local physical_address_t addr;
    addr = curr_txd.addr();
    log info, level:
        "TXD index: 0x%x", curr_txd.val;
    log info, level:
        "TXD address: 0x%x", addr;
    log info, level:
        "TXD.address: 0x%x", txd.addr;
    log info, level:
        "TXD.status:%s%s%s",
        txd.OWN == 0 ? "" : " <OWN>",
        txd.STP == 0 ? "" : " <STP>",
        txd.ENP == 0 ? "" : " <ENP>";
    log info, level:
        "TXD.byte_count: %d", txd.size;
}

// Data structure to hold the information from a receive descriptor, functions
// to convert between the data structure and the byte layout of the descriptor
// in target memory, and a function to log the contents of a descriptor.

typedef struct {
    physical_address_t addr;
    uint1 OWN;
    uint1 STP;
    uint1 ENP;
    uint16 size;
    uint16 msg_size;
} rxd_t;

method rxd_from_buf(uint8* buf) -> (rxd_t) {
    local rxd_t rxd;
    rxd.addr = buf[0] | buf[1] << 8 | buf[2] << 16;
    rxd.OWN = buf[3][7];
    rxd.STP = buf[3][1];
    rxd.ENP = buf[3][0];
    rxd.size = - (buf[4] | buf[5] << 8);
    rxd.msg_size = buf[6] | buf[7] << 8;
    return rxd;
}

method rxd_to_buf(rxd_t rxd, uint8* buf) {
    local int neg_size = - rxd.size;
    buf[0] = rxd.addr[7:0];
    buf[1] = rxd.addr[15:8];
    buf[2] = rxd.addr[23:16];
    buf[3] = (rxd.OWN << 7) | (rxd.STP << 1) | (rxd.ENP << 0);
    buf[4] = neg_size[7:0];
    buf[5] = neg_size[15:8];
    buf[6] = rxd.msg_size[7:0];
    buf[7] = rxd.msg_size[15:8];
}

method log_rxd(int level, rxd_t rxd) {
    local physical_address_t addr = curr_txd.addr();
    log info, level:
        "RXD index: 0x%x", curr_rxd.val;
    log info, level:
        "RXD address: 0x%x", addr;
    log info, level:
        "RXD.address: 0x%x", rxd.addr;
    log info, level:
        "RXD.status:%s%s%s",
        rxd.OWN == 0 ? "" : " <OWN>",
        rxd.STP == 0 ? "" : " <STP>",
        rxd.ENP == 0 ? "" : " <ENP>";
    log info, level:
        "RXD.byte_count: %d", rxd.size;
}

// Data structure containing an init block and a method to log the contents of
// an init block.

typedef struct {
    uint8 data[24];
} init_block_t;

method log_init_block(int level, init_block_t * init_block) {
    log info, level:
        "    %2x %2x %2x %2x %2x %2x %2x %2x",
        init_block->data[0], init_block->data[1],
        init_block->data[2], init_block->data[3],
        init_block->data[4], init_block->data[5],
        init_block->data[6], init_block->data[7];
    log info, level:
        "    %2x %2x %2x %2x %2x %2x %2x %2x",
        init_block->data[8], init_block->data[9],
        init_block->data[10], init_block->data[11],
        init_block->data[12], init_block->data[13],
        init_block->data[14], init_block->data[15];
    log info, level:
        "    %2x %2x %2x %2x %2x %2x %2x %2x",
        init_block->data[16], init_block->data[17],
        init_block->data[18], init_block->data[19],
        init_block->data[20], init_block->data[21],
        init_block->data[22], init_block->data[23];
}

// Constants

param TXD_SIZE = 8;         // size of transmit descriptor in bytes
param RXD_SIZE = 8;         // size of receive descriptor in bytes

param FRAME_MIN_SIZE = 64;    // Minimum size in bytes of Ethernet frame
param FRAME_CRC_SIZE = 4;     // Size of CRC in Ethernet frame
param FRAME_MAX_SIZE = 1518;  // Maximum size of Ethernet frame

// Layouts of the register banks. The actual register implementations can be
// found near end of this file.

// I/O registers (directly accessible from the target cpu).
bank ioreg {
    param byte_order = "little-endian";
    param register_size = 2;

    register aprom_0 size 1 @ 0x00 "Address PROM (MAC address)";
    register aprom_1 size 1 @ 0x01 "Address PROM (MAC address)";
    register aprom_2 size 1 @ 0x02 "Address PROM (MAC address)";
    register aprom_3 size 1 @ 0x03 "Address PROM (MAC address)";
    register aprom_4 size 1 @ 0x04 "Address PROM (MAC address)";
    register aprom_5 size 1 @ 0x05 "Address PROM (MAC address)";

    register aprom_e size 1 @ 0x0e "Address PROM (unknown)";
    register aprom_f size 1 @ 0x0f "Address PROM (unknown)";

    register rdp            @ 0x10 "Ethernet Controller Register Data Port";
    register rap            @ 0x12 "Address Port (shared between RDP, IDP)";
    register reset          @ 0x14 "Reset (read to trigger)";
    register idp            @ 0x16 "ISA Bus Configuration Register Data Port";
}

// Ethernet Controller Registers (accessed through ioreg.rap, ioreg.rdp).
bank csr {
    param byte_order = "little-endian";
    param register_size = 2;

    register csr0   @ 0  * 2  "Controller Status";
    register csr1   @ 1  * 2  "Init Block Address [15:0]";
    register csr2   @ 2  * 2  "Init Block Address [23:16]";
    register csr3   @ 3  * 2  "Interrupt Mask and Deferral Control";
    register csr4   @ 4  * 2  "Misc";

    register csr8   @ 8  * 2  "Logical Address Filter [15:0]";
    register csr9   @ 9  * 2  "Logical Address Filter [31:16]";
    register csr10  @ 10 * 2  "Logical Address Filter [47:32]";
    register csr11  @ 11 * 2  "Logical Address Filter [63:48]";
    register csr12  @ 12 * 2  "Physical (MAC) Address [15:0]";
    register csr13  @ 13 * 2  "Physical (MAC) Address [31:16]";
    register csr14  @ 14 * 2  "Physical (MAC) Address [47:32]";
    register csr15  @ 15 * 2  "Mode";

    register csr88  @ 88 * 2  "Chip ID lsw";
    register csr89  @ 89 * 2  "Chip ID msw";

    register csr112 @ 112 * 2 "Missed Frame Count";
}

// ISA Bus Configuration Registers (accessed through ioreg.rap, ioreg.idp).
// Unimplemented.
bank isa {
    param byte_order = "little-endian";
    param register_size = 2;

    register msrda  @ 0 * 2 is (unimpl) "Master Mode Read Active";
    register mswra  @ 1 * 2 is (unimpl) "Master Mode Write Active";
    register mc     @ 2 * 2 is (unimpl) "Miscellaneous Configuration";
    register reserved @ 3 * 2 is (reserved);
    register led0   @ 4 * 2 is (unimpl) "LED0 Status (Link Integrity)";
    register led1   @ 5 * 2 is (unimpl) "LED1 Status (Default: RCV)";
    register led2   @ 6 * 2 is (unimpl) "LED2 Status (Default: RCVPOL)";
    register led3   @ 7 * 2 is (unimpl) "LED3 Status (Default: XMT)";
}

// Device state saved in attributes instead of in CSR registers.

// The mac address of the device. When accessed as an attribute we handle it as
// a string in the standard format. Internally we store it in an uint64. Byte 0
// of the MAC address is stored in bits 0-7, byte 1 is stored in bit 8-15, and
// so on.
//
// Corresponds to CSR 12-14.
attribute mac_address {
    param documentation = "The MAC address";
    param configuration = "optional";
    param type = "s";
    session uint64 val;

    method get() -> (attr_value_t) {
        session char mac_str[18];
        sprintf(mac_str, "%02x:%02x:%02x:%02x:%02x:%02x",
                this.val[7:0], this.val[15:8], this.val[23:16],
                this.val[31:24], this.val[39:32], this.val[47:40]);
        return SIM_make_attr_string(mac_str);
    }

    method set(attr_value_t value) throws {
        local int mac_byte[6];
        if (sscanf(SIM_attr_string(value), "%x:%x:%x:%x:%x:%x",
                   &mac_byte[0], &mac_byte[1], &mac_byte[2],
                   &mac_byte[3], &mac_byte[4], &mac_byte[5]) == 6) {

            this.val[7:0]   = mac_byte[0];
            this.val[15:8]  = mac_byte[1];
            this.val[23:16] = mac_byte[2];
            this.val[31:24] = mac_byte[3];
            this.val[39:32] = mac_byte[4];
            this.val[47:40] = mac_byte[5];
        }
        else
            throw;
    }
}

// Corresponds to CSR 8-11.
attribute logical_address_filter is uint64_attr {
    param documentation = "The logical address filter";
    param configuration = "optional";
}

// Corresponds to CSR 24-25.
attribute rcv_descr_tbl_addr is uint64_attr {
    param documentation = "The base address of the receive descriptor ring";
    param configuration = "optional";
}

// Corresponds to CSR 76.
attribute rcv_descr_tbl_length is uint64_attr {
    param documentation = "The length of the receive descriptor ring";
    param configuration = "optional";
}

// Corresponds to CSR 72
attribute curr_rxd is uint64_attr {
    param documentation = "Index of the current receive descriptor";
    param configuration = "optional";
    method addr() -> (physical_address_t) {
        return rcv_descr_tbl_addr.val + (this.val * RXD_SIZE);
    }
    method next() {
        this.val = (this.val + 1) % rcv_descr_tbl_length.val;
    }
}

// Corresponds to CSR 30-31.
attribute xmt_descr_tbl_addr is uint64_attr {
    param documentation = "The base address of the transmit descriptor ring";
    param configuration = "optional";
}

// Corresponds to CSR 78.
attribute xmt_descr_tbl_length is uint64_attr {
    param documentation = "The length of the transmit descriptor ring";
    param configuration = "optional";
}

// Corresponds to CSR 74.
//:: pre am79c960_curr_txd_attribute {{
attribute curr_txd is uint64_attr {
    param documentation = "Index of the current transmit descriptor";
    param configuration = "optional";
    method addr() -> (physical_address_t) {
        return xmt_descr_tbl_addr.val + (this.val * TXD_SIZE);
    }
    method next() {
        this.val = (this.val + 1) % xmt_descr_tbl_length.val;
    }
}
// }}

// The AM79C960 polls regularly for new transmit descriptors. The poll_txd
// event is used to schedule the polls and poll_interval determines the
// interval between polls.

attribute poll_interval is double_attr {
    param documentation = "Interval between transmit descriptor polls";
    param configuration = "optional";
}

event poll_txd is simple_time_event {

    method event() {
        log info, 3: "periodic transmit ring poll triggered";

        // Poll for packets to transmit.
        send_packet();

        // Schedule another poll.
        poll_txd.post(poll_interval.val);
    }
}

// The transmit_done event is posted to raise the TINT interrupt and poll for
// additional packets when a packet has been transmitted. The time it takes to
// transmit a packet.is determined by transmit_time.

attribute transmit_time is double_attr {
    param documentation = "Time it takes to transmit a packet.";
    param configuration = "optional";
}

event transmit_done is simple_time_event {

    method event() {
        log info, 3: "transmit done";
        csr.csr0.TINT.raise();
        send_packet();
    }
}

// Log the contents of a frame.

method log_packet_header(const frags_t *frame, const char *message) {
    local uint8 *buf = new uint8[frags_len(frame)];
    local size_t size = frags_len(frame);
    local strbuf_t sbuf;
    frags_extract(frame, buf);

    sb_init(&sbuf);
    if (size >= 12)
        sb_addfmt(&sbuf,
                  "%s, dst %02x:%02x:%02x:%02x:%02x:%02x, src %02x:%02x:%02x:%02x:%02x:%02x, length %lld bytes",
                  message,
                  buf[0], buf[1], buf[2], buf[3], buf[4], buf[5],
                  buf[6], buf[7], buf[8], buf[9], buf[10], buf[11],
                  cast(size, uint64));
    else
        sb_addfmt(&sbuf, "%s, length %lld bytes", message, cast(size, uint64));

    log info, 2: "%s", sb_str(&sbuf);
    sb_free(&sbuf);
    delete buf;
}

method log_packet(const frags_t *frame) {
    local uint8 *buf = new uint8[frags_len(frame)];
    local size_t size = frags_len(frame);
    local strbuf_t sbuf;
    frags_extract(frame, buf);
    local size_t i;

    sb_init(&sbuf);
    sb_addfmt(&sbuf, "%s", "packet content:");
    for(i = 0; i < size; i++)
        sb_addfmt(&sbuf, "%s%02x", (i % 24 == 0) ? "\n" : " ", buf[i]);
    log info, 3: "%s", sb_str(&sbuf);
    sb_free(&sbuf);
    delete buf;
}

// Called when a packet is received from the link.

method receive_packet(const frags_t *frame) {
    local physical_address_t rxd_addr;
    local uint8 rxd_buf[RXD_SIZE];
    local rxd_t rxd;
    local size_t frame_size = frags_len(frame);
    local uint64 dst_addr;

    log_packet_header(frame, "packet received");
    log_packet(frame);

    if (csr.csr0.RXON.val == 0) {
        log info, 2: "receiver disabled, packet dropped";
        return;
    }

    if (frame_size < FRAME_MIN_SIZE) {
        log info, 2: "runt packet, packet dropped";
        return;
    }

    // Read the receive descriptor.
    rxd_addr = curr_rxd.addr();
    try {
        memory.read_bytes(rxd_addr, RXD_SIZE, rxd_buf);
    } catch {
        log info, 1: "Failed to read receive descriptor";
        return;
    }
    rxd = rxd_from_buf(rxd_buf);
    log_rxd(3, rxd);

    if (rxd.OWN == 0) {
        log info, 2: "receive ring overflow, packet dropped";
        csr.csr112.incr();
        csr.csr0.MISS.raise();
        return;
    }

    if (rxd.size < frame_size) {
        log unimpl, 1:
            "receive buffer smaller than packet, packet dropped";
        return;
    }

    // Check destination address.
    local uint8* buf = new uint8[frags_len(frame)];
    frags_extract(frame, buf);
    dst_addr = UNALIGNED_LOAD_LE64(buf) & 0xffffffffffff;
    if (dst_addr == mac_address.val)
        log info, 2: "MAC address matches, packet accepted";
    else if ((dst_addr & 1) != 0)
        log info, 2: "broadcast address, packet accepted";
    else if (csr.csr15.PROM.val != 0)
        log info, 2: "promiscuous mode enabled, packet accepted";
    else  {
        log info, 2: "MAC address does not match, packet dropped";
        return;
    }

    // Write the frame to the receive buffer.
    memory.write_frags_addr(rxd.addr, frame);

    // Update and write back the receive descriptor.
    rxd.STP = 1;
    rxd.ENP = 1;
    rxd.OWN = 0;
    rxd.msg_size = frame_size;
    rxd_to_buf(rxd, rxd_buf);
    try {
        memory.write_bytes(rxd_addr, RXD_SIZE, rxd_buf);
    } catch {
        log info, 1: "Failed to write back receive descriptor @ 0x%08x", rxd_addr;
    }

    // Step to the next receive descriptor.
    curr_rxd.next();

    // Raise the receive interrupt.
    csr.csr0.RINT.raise();
}

// Called when we should poll for packets we can send, either because the TDMD
// bit is written, a periodic poll is triggered or we have finished
// transmitting a packet.

method send_packet() {
    local physical_address_t txd_addr;
    local uint8 txd_buf[TXD_SIZE];
    local txd_t txd;
    local frags_t frame;
    local size_t frame_size;
    local bool already_posted;

    if (csr.csr0.TXON.val == 0) {
        log info, 3: "transmitter disabled";
        return;
    }

    already_posted = transmit_done.posted();
    if (already_posted) {
        log info, 3: "already transmitting a packet";
        return;
    }

    log info, 3: "checking for packets to send";

    // Clear TDMD.
    csr.csr0.TDMD.val = 0;

    // Read the transmit descriptor.
    txd_addr = curr_txd.addr();
    try {
        memory.read_bytes(txd_addr, TXD_SIZE, txd_buf);
    } catch {
        log info, 1: "Failed to read transmit descriptor";
    }
    txd = txd_from_buf(txd_buf);
    log_txd(3, txd);

    if (txd.OWN == 0) {
        log info, 3: "no packet in transmit ring, no packet sent";
        return;
    }

    if (txd.STP == 0) {
        log spec_viol, 1:
            "STP not set in transmit descriptor, no packet sent";
        return;
    }

    if (txd.ENP == 0) {
        log unimpl, 1: "chained transmit descriptor, no packet sent";
        return;
    }

    // Check if we are connected to a link.
    if (link.obj != NULL) {
        // Read the frame from the transmit buffer.
        local uint8 *buf = memory.read_addr(txd.addr, txd.size);
        frags_init_add(&frame, buf, txd.size);
        frame_size = frags_len(&frame);

        local int pad_size = (FRAME_MIN_SIZE - FRAME_CRC_SIZE) - frame_size;
        if (pad_size < 0)
            pad_size = 0;
        pad_size += FRAME_CRC_SIZE;
        local uint8 *padding = new uint8[pad_size];

        frame = frags_suffix(&frame, padding, pad_size);

        // Transmit the frame.
        log_packet_header(&frame, "Packet sent");
        log_packet(&frame);
        link.ethernet_common.frame(&frame, Eth_Frame_CRC_Match);
    }
    else
        log info, 2: "not connected, no packet sent";

    // Update and write back the transmit descriptor.
    txd.OWN = 0;
    txd_to_buf(txd, txd_buf);
    try {
        memory.write_bytes(txd_addr, TXD_SIZE, txd_buf);
    } catch {
        log info, 1: "Failed to write back transmit descriptor";
    }

    // Step to the next transmit descriptor.
    curr_txd.next();

    // Post a transmit_done event, that will raise the transmit interrupt and
    // poll for additional packets to send once this packet has been sent.
    transmit_done.post(transmit_time.val);
}

// This template is used by registers that save their value in a separate
// attribute. The data parameter specifies the attribute, and the attr_msb and attr_lsb
// parameters specify the part of the attribute that corresponds to this
// register.

//:: pre am79c960_data_accessor_template {{
template attr_accessor {
    param attr;
    param attr_msb;
    param attr_lsb;
    param ignore_write default false;
    param mac_register default false;

    method get() -> (uint64) {
        return read();
    }
    method set(uint64 value) {
        write(value);
    }
    is read;
    method read() -> (uint64) {
        return attr.val[attr_msb:attr_lsb];
    }
    is write;
    method write(uint64 value) {
        if (!ignore_write) {
            attr.val[attr_msb:attr_lsb] = value;
        }
    }
}
// }}

// I/O registers (directly accessible from the target cpu).

bank ioreg {
    // Address 0-15 of the bank map the IEEE address PROM. Bytes 0-5 contain
    // the MAC address. The function of bytes 14 and 15, but they need to
    // contain the value 0x57. The other addresses are unimplemented.

    register aprom_0 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 7;
        param attr_lsb = 0;
        param ignore_write = true;
    }
    register aprom_1 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 15;
        param attr_lsb = 8;
        param ignore_write = true;
    }
    register aprom_2 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 23;
        param attr_lsb = 16;
        param ignore_write = true;
    }
    register aprom_3 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 31;
        param attr_lsb = 24;
        param ignore_write = true;
    }
    register aprom_4 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 39;
        param attr_lsb = 32;
        param ignore_write = true;
    }
    register aprom_5 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 47;
        param attr_lsb = 40;
        param ignore_write = true;
    }
    register aprom_e is (constant) { param init_val = 0x57; }
    register aprom_f is (constant) { param init_val = 0x57; }

    // Accesses to the RDP register are forwarded to the Ethernet Controller
    // Registers bank, at the address specified by the RAP register.
    register rdp {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            local uint64 value;
            if (enabled_bytes != 0xFFFF) {
                log error:
                    "partial read from %s%s",
                    qname, defined desc ? " (" + desc + ")" : "";
                value = 0;
            } else {
                // forward access to target bank
                try {
                    value = csr.read(ioreg.rap.val * 2, enabled_bytes, aux);
                } catch {
                    log error: "Failed to forward register read to csr";
                }
            }
            return value;
        }

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            if (enabled_bytes != 0xFFFF) {
                log error:
                    "partial write to %s%s",
                    qname, defined desc ? " (" + desc + ")" : "";
            } else {
                // forward access to target bank
                try {
                    csr.write(ioreg.rap.val * 2, value, enabled_bytes, aux);
                } catch {
                    log error: "Failed to forward register write to csr";
                }
            }
        }
    }

    // Specifies the address used when the RDP or IDP registers are accessed.
    register rap;

    register reset {
        // Triggering reset leads to a soft-reset of the whole device. The
        // default behaviour for soft-reset in registers and fields is to inline
        // hard-reset, which by default sets values to 0. Registers or fields
        // that behave differently should override soft-reset.
        is read;
        method read() -> (uint64) {
            log info, 2: "reset triggered";
            dev.soft_reset();
            update_irq();
            return 0;
        }
    }

    // Accesses to the IDP register are forwarded to the ISA Bus Configuration
    // Registers bank, at the address specified by the RAP register.
    register idp {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            local uint64 value;
            if (enabled_bytes != 0xFFFF) {
                log error:
                    "partial read from %s%s",
                    qname, defined desc ? " (" + desc + ")" : "";
                value = 0;
            } else {
                // forward access to target bank
                try {
                    value = isa.read(ioreg.rap.val * 2, enabled_bytes, aux);
                } catch {
                    log error: "Failed to forward register read to csr";
                }
            }
            return value;
        }

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            if (enabled_bytes != 0xFFFF) {
                log error:
                    "partial write to %s%s",
                    qname, defined desc ? " (" + desc + ")" : "";
            } else {
                // forward access to target bank
                try {
                    isa.write(ioreg.rap.val * 2, value, enabled_bytes, aux);
                } catch {
                    log error: "Failed to forward register read to csr";
                }
            }
        }
    }
}

// Template used by irq flag fields. Provides methods for raising and lowering
// the interrupt, and implements the lower-on-set semantics.
template irq_flag {
    method raise() default {
        if (this.val == 0) {
            this.val = 1;
            log info, 3: "%s interrupt flag raised", name;
            update_irq();
        }
    }
    method lower() default {
        if (this.val == 1) {
            this.val = 0;
            log info, 3: "%s interrupt flag lowered", name;
            update_irq();
        }
    }

    is read;
    method read() -> (uint64) {
        return this.val;
    }
    is write;
    method write(uint64 value) {
        if (value == 1)
            this.lower();
    }
}

// Ethernet Controller Registers (accessed through ioreg.rap, ioreg.rdp).
bank csr {
    //:: pre csr0_register {{
    register csr0 {
        // will csr0.init() after csr0 written?
        session uint1 do_init;
        // will csr0.start() after csr0 written?
        session uint1 do_start;
        // will csr0.transmit_demand() after csr0 written?
        session uint1 do_transmit_demand;

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            if (do_init == 1) {
                do_init = 0;
                initialize();
            }
            if (do_start == 1) {
                do_start = 0;
                start();
            }
            if (do_transmit_demand == 1) {
                do_transmit_demand = 0;
                transmit_demand();
            }
        }
        // }}
        field INIT  @ [0] "Initialize" {
            is write;
            method write(uint64 value) {
                this.val = this.val | value;
                STOP.val = STOP.val & ~value;
                if (value == 1) {
                    do_init = 1;
                }
            }
        }
        field STRT  @ [1] "Start" {
            is write;
            method write(uint64 value) {
                this.val = this.val | value;
                if (value == 1) {
                    STOP.val = 0;

                    // start happens after init if both are set
                    do_start = 1;
                }
            }
        }
        field STOP  @ [2] "Stop" {
            is soft_reset_val;
            param soft_reset_val = 1;
            is write;
            method write(uint64 value) {
                this.val = this.val | value;
                if (value == 1) {
                    // stop device

                    // reset control register fields, including RXON,
                    // TXON, irq flags
                    csr0.soft_reset();

                    // clean pending events
                    poll_txd.remove();
                    // frame may be sent but TINT irq canceled
                    transmit_done.remove();
                    update_irq();

                    log info, 2: "device stopped";
                }
            }
        }
        //:: pre csr0_tdmd_field {{
        field TDMD  @ [3] "Transmit Demand" {
            is write;
            method write(uint64 value) {
                if (value == 1) {
                    this.val = 1;
                    do_transmit_demand = 1;
                }
                // ignore write 0; cleared by send_packet()
            }
        }
        // }}
        field TXON  @ [4] is ignore_write "Transmit On";
        field RXON  @ [5] is ignore_write "Receive On";
        field IENA  @ [6] "Interrupt Enable" {
            is read;
            method read() -> (uint64) {
                return this.val;
            }
            is write;
            method write(uint64 value) {
                this.val = value;
                update_irq();
            }
        }
        field INTR  @ [7] is (ignore_write) "Interrupt Flag" {
            // auto cleared
            is read;
            method read() -> (uint64) {
                return (BABL.val & ~csr3.BABLM.val) |
                    (MISS.val & ~csr3.MISSM.val) |
                    (MERR.val & ~csr3.MERRM.val) |
                    // MPCO
                    // RCVCCO
                    (RINT.val & ~csr3.RINTM.val) |
                    (TINT.val & ~csr3.TINTM.val) |
                    (IDON.val & ~csr3.IDONM.val);
                    // JAB
                    // TXSTRT
            }
        }
        field IDON  @ [8]  is (irq_flag)       "Initialization Done";
        field TINT  @ [9]  is (irq_flag)       "Transmit Interrupt";
        field RINT  @ [10] is (irq_flag)       "Receive Interrupt";
        field MERR  @ [11] is (irq_flag)       "Memory Error";
        field MISS  @ [12] is (irq_flag)       "Missed Frame";
        field CERR  @ [13] is (write_1_clears) "Collision Error";
        field BABL  @ [14] is (irq_flag)       "Babble";
        field ERR   @ [15]                     "Error" {
            is read;
            method read() -> (uint64) {
                return BABL.val | CERR.val | MISS.val | MERR.val;
            }
            is write;
            method write(uint64 value) {
                // ignored
            }
        }

        method initialize() {
            local physical_address_t addr;
            local init_block_t * init_block;
            local int i;
            local uint16 mode;

            log info, 2: "initializing";

            // read init block from address in CSR2:CSR1
            addr = 0;
            addr[15:0] = csr1.val;
            addr[23:16] = csr2.val;
            init_block = new init_block_t;
            try {
                memory.read_bytes(addr, sizeoftype(init_block_t), cast(init_block, uint8 *));
            } catch {
                log info, 1: "Failed to read init block @ 0x%08x", addr;
                return;
            }
            log_init_block(3, init_block);

            // init registers from block
            mode = (init_block->data[0]) | ((init_block->data[1]) << 8);
            csr15.set(mode);                            // MODE

            mac_address.val[7:0] = init_block->data[2];            // PADR[7:0]
            mac_address.val[15:8] = init_block->data[3];           // PADR[15:8]
            mac_address.val[23:16] = init_block->data[4];          // PADR[23:16]
            mac_address.val[31:24] = init_block->data[5];          // PADR[31:24]
            mac_address.val[39:32] = init_block->data[6];          // PADR[39:32]
            mac_address.val[47:40] = init_block->data[7];          // PADR[47:40]

            csr8.val[7:0] = init_block->data[8];                   // LADRF[7:0]
            csr8.val[15:8] = init_block->data[9];                  // LADRF[15:8]
            csr9.val[7:0] = init_block->data[10];                  // LADRF[23:16]
            csr9.val[15:8] = init_block->data[11];                 // LADRF[31:24]
            csr10.val[7:0] = init_block->data[12];                 // LADRF[39:32]
            csr10.val[15:8] = init_block->data[13];                // LADRF[47:40]
            csr11.val[7:0] = init_block->data[14];                 // LADRF[55:48]
            csr11.val[15:8] = init_block->data[15];                // LADRF[63:56]
            rcv_descr_tbl_addr.val[7:0] = init_block->data[16];    // RDRA[7:0]
            rcv_descr_tbl_addr.val[15:8] = init_block->data[17];   // RDRA[15:8]
            rcv_descr_tbl_addr.val[23:16] = init_block->data[18];  // RDRA[23:16]
            rcv_descr_tbl_length.val =
                (0x1 << (init_block->data[19])[7:5]);           // RLEN (3 bits)
            xmt_descr_tbl_addr.val[7:0] = init_block->data[20];    // TDRA[7:0]
            xmt_descr_tbl_addr.val[15:8] = init_block->data[21];   // TDRA[15:8]
            xmt_descr_tbl_addr.val[23:16] = init_block->data[22];  // TDRA[23:16]
            xmt_descr_tbl_length.val =
                (0x1 << (init_block->data[23])[7:5]);           // TLEN (3 bits)

            // reset descriptor ring indices
            curr_txd.val = 0;
            curr_rxd.val = 0;

            // send IDON interrupt
            csr0.IDON.raise();

            delete init_block;
        }

        method start() {
            log info, 2: "starting";
            if (csr.csr15.DTX.val == 0) {
                TXON.val = 1;
                curr_txd.val = 0;
                log info, 3: "starting transmit";
                poll_txd.post(poll_interval.val);
            } else {
                log info, 3: "transmit disabled at start";
            }
            if (csr.csr15.DRX.val == 0) {
                RXON.val = 1;
                curr_rxd.val = 0;
                log info, 3: "starting receive";
            } else {
                log info, 3: "receive disabled at start";
            }
        }

        method transmit_demand() {
            dev.transmit_done.next();
            send_packet();
        }
    }

    //:: pre am79c960_csr1_2_soft_reset {{
    // should be read/write accessible only when STOP is set
    register csr1 is sticky;

    // should be read/write accessible only when STOP is set
    register csr2 is sticky;
    // }}

    register csr3 {
        field RES    @ [2:0]   is (reserved);
        field EMBA   @ [3]     is (unimpl)  "Enable Modified Back-off Algorithm";
        field DXMT2PD  @ [4]   is (unimpl)  "Disable Transmit Two Part Deferral";
        field RES1   @ [7:5]   is (reserved);
        field IDONM  @ [8]     "IDON Mask";
        field TINTM  @ [9]     "TINT Mask";
        field RINTM  @ [10]    "RINT Mask";
        field MERRM  @ [11]    "MERR Mask";
        field MISSM  @ [12]    "MISS Mask";
        field RES2   @ [13]    is (reserved);
        field BABLM  @ [14]    "BABL Mask";
        field RES3   @ [15]    is (reserved);
    }

    register csr4 is (unimpl);

    register csr8 is (attr_accessor) {
        param attr = logical_address_filter;
        param attr_msb = 15;
        param attr_lsb = 0;
    }

    register csr9 is (attr_accessor) {
        param attr = logical_address_filter;
        param attr_msb = 31;
        param attr_lsb = 16;
    }

    register csr10 is (attr_accessor) {
        param attr = logical_address_filter;
        param attr_msb = 47;
        param attr_lsb = 32;
    }

    register csr11 is (attr_accessor) {
        param attr = logical_address_filter;
        param attr_msb = 63;
        param attr_lsb = 48;
    }

    register csr12 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 15;
        param attr_lsb = 0;
        param mac_register = true;
    }

    register csr13 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 31;
        param attr_lsb = 16;
        param mac_register = true;
    }

    register csr14 is (attr_accessor) {
        param attr = mac_address;
        param attr_msb = 47;
        param attr_lsb = 32;
        param mac_register = true;
    }

    register csr15 {
        field PROM  @ [15] "Promiscuous Mode";

        field DTX  @ [1]   "Disable Transmit";
        field DRX  @ [0]   "Disable Receive";
    }

    register csr88 is (constant) {
        param init_val = 0x3003;
    }
    register csr89 is (constant) {
        param init_val = 0x0000;
    }

    register csr112 {
        is write;
        method write(uint64 value) {
            log unimpl, 1:
                "writes to %s%s are not supported",
                qname, defined desc ? " (" + desc + ")" : "";
            // Do not change $this.
        }
        method incr() {
            if (this.val == 0xffff) {
                this.val = 0;
                // should set csr4.MFCO, which raises irq, etc.
                log unimpl, 1:
                    "overflow of %s%s",
                    qname, defined desc ? " (" + desc + ")" : "";
            }
            else
                this.val = this.val + 1;
        }
    }

}

// Run when the object is created. Sets the default values of attributes.
method init() {
    link.obj = NULL;

    poll_interval.val = 1.6e-3;
    transmit_time.val = 1.0e-3;
}

// Run after all attributes have been set when a device is created or a
// checkpoint is loaded.
method post_init() {
}
