/*
  Â© 2010 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

dml 1.4;

import "utility.dml";
import "pci/pci-capabilities.dml";
import "pci/pcix-capabilities.dml";
import "pci/pcie-capabilities.dml";
import "pci/msi-capabilities.dml";
import "pci/pcie-common.dml";

import "simics/devs/pci.dml";
import "simics/devs/map-demap.dml";
import "simics/devs/memory-space.dml";
import "simics/devs/ram.dml";
import "simics/util/bitcount.dml";

header %{
    static const char *const irq_pin_name[] = {
        "INT#A",
        "INT#B",
        "INT#C",
        "INT#D"
    };

    #include <simics/util/bitcount.h>
    #define convert_le64 CONVERT_LE64
%}

is (sreset, hreset);

extern uint32 convert_le64(uint64 x);

/* Constants and names used for raising/lowering interrupts via e.g.,
   pci_raise_interrupt_pin. Not for use as values to the interrupt_pin
   register, as they are off-by-one (i.e., INT#A is represented by 1). */
extern const char *const *irq_pin_name;    //< Indexed by IRQ_PIN_[A-D]
param IRQ_PIN_A = 0;
param IRQ_PIN_B = 1;
param IRQ_PIN_C = 2;
param IRQ_PIN_D = 3;

loggroup PCI_config;
loggroup PCI_DMA;
loggroup PCI_IRQ;

template pci_device_params {
    /* Set the pci_hotplug parameter to true if the device should support
       hot-plugging. Setting pci_hotplug to true changes the configuration
       parameter of the pci_bus from required to optional */
    param pci_hotplug default false;

    /* Should be set to true for PCI Express devices
       (see also pcie_device template) */
    param pcie_device default false;

#if (pcie_device && dev.simics_api_version != "6") {
    error "The PCIe part of this library is deprecated, please use the new library dml-lib/pcie/*";
}

    param pci_config_bank;
}

template pci_common is pci_device_params {

    is providing_pci_bus_connect;
    is providing_expansion_rom_connect;
    is providing_dma_methods;
    is providing_legacy_interrupts;
    is providing_pci_device_interface;

    implement io_memory is (function_io_memory);

    attribute config_registers is (pseudo_attr, read_only_attr) {
        param documentation
            = "The PCI configuration registers, each 32 bits in size.";
        param type = "[i*]";
        param pci_config_size default 64;    /* not valid for PCI Express */

        method get() -> (attr_value_t) default {
            local attr_value_t value;
            local uint64 val;
            local uint32 i;

            value = SIM_alloc_attr_list(pci_config_size);

            for (i = 0; i < pci_config_size; ++i) {
                try {
                    val = pci_config_bank.get(i * 4, 4);
                } catch {
                    val = 0;
                }
                SIM_attr_list_set_item(&value, i, SIM_make_attr_uint64(val));
            }
            return value;
        }
    }

    attribute is_pcie_device is (pseudo_attr, read_only_attr) {
        param documentation = "Is this a PCIe device (or a PCI device)";
        param type = "b";
        param internal = true;
        method get() -> (attr_value_t) default {
            local attr_value_t value;
            value = SIM_make_attr_boolean(pcie_device);
            return value;
        }
    }
}

template pci_device is pci_common {
    /* list of config banks, for bus_reset */
    param pci_config_bank default pci_config;
    bank pci_config {
        is pci_config_type_0;
    }
}

template pcie_device is pci_device {
    param pcie_device = true;
}

template pci_mf_device is pci_common {
    param mf_banks;
    param pci_config_bank = mf_banks[0];

    method pci_bus_disconnected() {
        #foreach bank in (mf_banks) {
            bank.bus_reset();
        }
    }

    implement pci_multi_function_device {
        // Declared 'default' defensively, for compatibility (previously the
        // interface had to be implemented manually). No reason to override.
        method supported_functions() -> (attr_value_t) default {
            local attr_value_t list;
            local int len = 0;
            #foreach _ in (mf_banks) ++len;
            list = SIM_alloc_attr_list(len);
            local int i = 0;
            #foreach pf in (mf_banks) {
                local attr_value_t elem =
                    SIM_make_attr_list(2,
                                       SIM_make_attr_uint64(pf.mf_fun),
                                       SIM_make_attr_object(pf.obj));
                SIM_attr_list_set_item(&list, i, elem);
                i++;
            }
            return list;
        }
    }
}

// Template to connect the device to a PCI bus, used by connect statements
template pci_bus_connect {
    interface pci_bus;
    interface io_memory;
    interface pci_upstream_operation {
        // TODO: new interface is preferred over io_memory, but cannot be
        // required right now as lots of python tests depend on io_memory
        param required = false;
    }
}

template _maybe_provides_pci_bus_connect {
    param _provides_pci_bus_connect default false;
}
is _maybe_provides_pci_bus_connect;

// Can be instantiated in devices that want to provide a pci_bus without
// using providing_pci_bus_connect
template provides_pci_bus_connect is _maybe_provides_pci_bus_connect {
    param _provides_pci_bus_connect = true;
}

// Define the main PCI bus
template providing_pci_bus_connect is (pci_device_params,
                                       provides_pci_bus_connect) {

    method require_pci_bus() throws {
        if (pci_hotplug && !pci_bus.obj) {
            log info, 2, PCI_config:
                "Trying to access the PCI bus of a hot-pluggable object that "
                + " has not yet been plugged in";
            throw;
        }
    }

    method pci_bus_connected() default {
        log info, 2, PCI_config: "connected to bus";
    }

    method pci_bus_disconnected() default {
        pci_config_bank.bus_reset();
    }

    connect pci_bus is pci_bus_connect {
        param configuration = pci_hotplug ? "optional" : "required";
        param documentation = "The PCI bus this device is connected to,"
            + " implementing the <tt>pci-bus</tt> interface.";
        #if (pcie_device) {
            interface pci_express;
            session map_target_t *upstream;
        }

        // We can probably leave this in until next PCI lib implementation
        method legacy_before_set() default {
            // for existing 4.6 models that have added logic to the before_set
            // method and don't want to re-write it in terms of
            // pci_bus_disconnected (see pex86xx for example)
        }

        method set(conf_object_t *obj) default {
            legacy_before_set();
            if (this.obj) {
                log info, 2, PCI_config: "disconnected from bus";
                pci_bus_disconnected();
            }
            default(obj);
            #if (pcie_device) {
                SIM_free_map_target(upstream);
                upstream = NULL;
                if (obj) {
                    local conf_object_t *upo =
                        SIM_object_descendant(obj, "port.upstream");
                    if (upo)
                        upstream = SIM_new_map_target(upo, NULL, NULL);
                }
            }
            if (obj) {
                pci_bus_connected();
            }
        }

    }
}

// Expansion ROM
template providing_expansion_rom_connect {
    connect expansion_rom {
        param configuration = "optional";
        interface rom;
    }

    attribute expansion_rom_size is (uint64_attr) {
        param documentation = "The size of the expansion ROM mapping.";
        param configuration = "optional";
    }
}

// This template is intended to allow the firmware to customize proper
// subsystem_id, subsystem_vendor_id etc. read-only registers value sometime,
// e.g. during POST, by overriding their default writing behaviors.
// Note that it only supports registers without fields definition.
template read_only_custom_write is (register, write) {
    method can_write(uint64 value) -> (bool) default {
        return get() == value;
    }
    method do_write(uint64 value) default {
        set(value);
    }
    method write(uint64 value) default {
        if (!can_write(value)) {
            session uint8 log_level = 1;
            log spec_viol, log_level, Register_Write:
                "Write to read-only register %s (value written = %#x,"
                + " contents = %#x).", qname, value, get();
            log_level = 2;
            return;
        }
        do_write(value);
    }
}

// Configuration register bank
template pci_config_generic is (function_mapped_bank, _pci_config_generic) {
    param function = 255;
    param mappable = true;
}


template _pci_config_generic_command_reg {
    field io;
    param _io : field;
    param _io = cast(io, field);
    field mem;
    param _mem : field;
    param _mem = cast(mem, field);
    field m;
    param _m : field;
    param _m = cast(m, field);
    field sc;
    param _sc : field;
    param _sc = cast(sc, field);
    field mwi;
    param _mwi : field;
    param _mwi = cast(mwi, field);
    field vga;
    param _vga : field;
    param _vga = cast(vga, field);
    field pe;
    param _pe : field;
    param _pe = cast(pe, field);
    field wc;
    param _wc : field;
    param _wc = cast(wc, field);
    field se;
    param _se : field;
    param _se = cast(se, field);
    field fb;
    param _fb : field;
    param _fb = cast(fb, field);
    field id;
    param _id : field;
    param _id = cast(id, field);
}

// This internal template is intended for multi-function devices
// _without_ bank function parameter set
template _pci_config_generic is (miss_pattern_bank, rbar_capable_bank) {
    param documentation = "The PCI configuration space.";
    param overlapping = true;
    param partial = true;

    param byte_order = "little-endian";

    param pci_miss_pattern default 0;

    param miss_pattern = pci_miss_pattern;

    // Override if the device is not a busmaster
    param busmaster           default true;

    // Override if the device does not support I/O or mem access.
    param io_capable          default true;
    param mem_capable         default true;

    // Override with correct list of enabled address base registers
    param base_address_registers default [];

    register vendor_id           size 2 @ 0x00 is (read_only_custom_write) {
        param documentation = "Vendor ID";
    }
    register device_id           size 2 @ 0x02 is (read_only_custom_write) {
        param documentation = "Device ID";
    }

    register command             size 2 @ 0x04 is _pci_config_generic_command_reg {
        param documentation = "Command Register";
        field io   @ [0:0]   "I/O Space Enable";
        field mem  @ [1:1]   "Memory Space Enable";
        field m    @ [2:2]   "Bus Master Enable";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field sc   @ [3:3]   "Special Cycles Enable";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field mwi  @ [4:4]   "Memory Write and Invalidate";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field vga  @ [5:5]   "VGA Palette Snoop";
        field pe   @ [6:6]   "Parity Error Response";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field wc   @ [7:7]   "IDSEL Steppin/Wait Cycle Control";
        field se   @ [8:8]   "SERR# Enable";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field fb   @ [9:9]   "Fast Back-to-Back Transactions Enable";
        field id   @ [10:10] "Interrupt Disable";
    }
    register status              size 2 @ 0x06 {
        param documentation = "Status Register";
        field ir   @ [0:0]   is ignore_write   "Immediate Readiness";
        field ins  @ [3:3]   is ignore_write   "Interrupt Status";
        field c    @ [4:4]   is ignore_write   "Capabilities List";
        field mhz  @ [5:5]   is ignore_write   "66 MHz Capable";
        field fbb  @ [7:7]   is ignore_write   "Fast Back-to-Back Transactions Capable";
        field pe   @ [8:8]   is write_1_clears "Master Data Parity Error";
        field ds   @ [10:9]  is ignore_write   "DEVSEL timing";
        field sta  @ [11:11] is write_1_clears "Signaled Target Abort";
        field rta  @ [12:12] is write_1_clears "Received Target Abort";
        field rma  @ [13:13] is write_1_clears "Received Master Abort";
        field ssa  @ [14:14] is write_1_clears "Signaled System Abort";
        field dpe  @ [15:15] is write_1_clears "Detected Parity Error";
    }
    register revision_id         size 1 @ 0x08 is (read_only_custom_write) {
        param documentation = "Revision ID";
    }
    register class_code          size 3 @ 0x09 is (read_only_custom_write) {
        param documentation = "Class Code";
    }
    register cache_line_size     size 1 @ 0x0c {
        param documentation = "CacheLine Size";
    }
    register latency_timer       size 1 @ 0x0d {
        param documentation = "Latency Timer";
    }
    register header_type         size 1 @ 0x0e {
        param documentation = "Header Type";
        field type  @ [6:0] is ignore_write "Header Layout";
        field mf    @ [7:7] is ignore_write "Multi-Function Device";
    }
    register bist                size 1 @ 0x0f {
        param documentation = "Build-in Self Test";
         // TODO(ah): for backwards compatibility, we cannot add the fields for
        // this register
        /*
        field cc [3:0] is (ignore_write) "Completion Code";
        field sb [6:6] is (read_write)   "Start BIST";
        field bc [7:7] is (ignore_write) "BIST Capable";
        */
    }
    register expansion_rom_base is (base_address)
        "Expansion ROM base address";

    register capabilities_ptr    size 1 @ 0x34 is (constant) {
        param documentation = "Capabilities Pointer";
    }
    register interrupt_line      size 1 @ 0x3c {
        param documentation = "Interrupt Line";
    }
    register interrupt_pin       size 1 @ 0x3d is (read_only_custom_write) {
        param documentation = "Interrupt Pin";
    }

    register interrupts size 1 is (soft_reset, hard_reset, post_init,
                                   unmapped) {
        param documentation = "Raised _internal_ interrupts";
        method post_init() default {
            pci_lower_all_pins();
        }
        method hard_reset() default {
            default();
            pci_lower_all_pins();
        }
        method soft_reset() default {
            default();
            pci_lower_all_pins();
        }
     }

    inline method irq_bridge_count(inline pin) -> (uint64) default {
        local uint64 count;
        // only used by bridges, default to 0
        count = 0;
        return count;
    }

    // Topological device ID used for memory transactions
    register bus_address size 4 is unmapped {
        param configuration = "pseudo";
        param init_val = 0xffff_ffff;

        method update() default {
            // Set if not already set
            if (this.val == init_val) {
                if (pci_bus.obj != NULL)
                    this.val = pci_bus.pci_bus.get_bus_address(dev.obj);
                else
                    log info, 2, PCI_config:
                        "Trying to access bus_address with the PCI bus"
                        + " disconnected";
            }
        }
    }

    inline method remove_mappings(inline space_type) default {
        log info, 3, PCI_config: "Removing %s mappings", space_type;
        foreach reg in (each base_address in (this)) {
            if (reg.mapped && strcmp(reg.map_type, space_type) == 0) {
                #foreach name in (base_address_registers) {
                    if (strcmp(reg.name, name) == 0)
                        reg.remove_map();
                }
                if (strcmp(reg.name, "expansion_rom_base") == 0)
                    reg.remove_map();
            }
        }
    }

    inline method update_mappings(inline space_type) default {
        log info, 3, PCI_config: "Updating %s mappings", space_type;
        foreach reg in (each base_address in (this)) {
            if (reg.mapped && strcmp(reg.map_type, space_type) == 0) {
                #foreach name in (base_address_registers) {
                    if (strcmp(reg.name, name) == 0)
                        reg.update_mapping();
                }
                if (strcmp(reg.name, "expansion_rom_base") == 0)
                    reg.update_mapping();
            }
        }
    }

    method remove_all_mappings() default {
        remove_mappings("I/O");
        remove_mappings("memory");
    }

    method update_all_mappings() default {
        update_mappings("I/O");
        update_mappings("memory");
    }

    method bus_reset() default {
        log info, 2, PCI_config: "Bus reset";
        dev.soft_reset();
        update_all_mappings();
        secondary_bus_reset();
    }

    method secondary_bus_reset() default {
        // only implemented by bridges that has a secondary bus to reset
    }

    // register implementation
    register command {
        param allocate = true;
        // Disable writes to unimplemented bits (even if a device is io/mem capable)
        param io_bit_implemented  default true;
        param mem_bit_implemented default true;
        param m_bit_implemented   default true;
        param id_bit_implemented  default true;

        field io is write {
            method write(uint64 enable) default {
                if (io_capable && io_bit_implemented) {
                    if (this.get() != enable) {
                        this.set(enable);
                        bank.update_mappings("I/O");
                    }
                }
            }
        }
        field mem is write {
            method write(uint64 enable) default {
                if (mem_capable && mem_bit_implemented) {
                    if (this.get() != enable) {
                        this.set(enable);
                        bank.update_mappings("memory");
                    }
                }
            }
        }
        field m is write {
            method write(uint64 enable) default {
                if (m_bit_implemented) {
                    if (!busmaster && enable != 0) {
                        log spec_viol, 1, PCI_config:
                            "Enabling bus master, but this device doesn't support it";
                        return;
                    }
                    this.set(enable);
                }
            }
        }
        field id is write {
            method write(uint64 value) default {
                if (id_bit_implemented) {
                    if (this.get() != value) {
                        if (value == 1) {
                            /* INTx interrupts disabled */
                            pci_lower_all_pins();
                        }
                        this.set(value);
                    }
                }
            }
        }
    }

    register bist is (read_zero, write, set) {
        param allocate = false;
        method set(uint64 value) default {
            if (value != 0)
                log unimpl, 1, PCI_config: "BIST is not implemented";
        }
        method write(uint64 value) default {
            if (value != 0)
                log unimpl, 1, PCI_config: "BIST is not implemented";
        }
    }

    register expansion_rom_base is base_address {
        param enabled = true;
        param min_size_bits default 1;
        param map_type = "memory";
        param size = 4;
        param map_func = 0;

        method update_mapping() default {
            this.remove_map();
            if (command._mem.get() != 0 && pci_mapping_enabled()) {
                this.add_map();
            }
        }

        param _base = cast(base, field);

        field base @ [base_msb:min_size_bits] is (read, write) {
            param documentation = "The base address";

            method read() -> (uint64) default {
                local uint64 value;
                if (expansion_rom.obj && expansion_rom_size.val != 0) {
                    value = get_base();
                } else {
                    value = 0;
                }
                return value;
            }

            method write(uint64 value) default {
                if (expansion_rom.obj && expansion_rom_size.val != 0) {
                    if (this.get() != value) {
                        this.set(value);
                        update_mapping();
                    }
                }
            }
        }

        field e  @ [0:0] is (read, write) {
            param documentation = "Address decode enable";

            method read() -> (uint64) default {
                local uint64 value;
                if (expansion_rom.obj && expansion_rom_size.val != 0) {
                    value = this.get();
                } else {
                    value = 0;
                }
                return value;
            }

            method write(uint64 value) default {
                if (expansion_rom.obj && expansion_rom_size.val != 0) {
                    if (this.get() != value) {
                        this.set(value);
                        update_mapping();
                    }
                }
            }
        }

        method pci_bar_size_bits() -> (int) {
            local int bits;
            bits = log2_64(expansion_rom_size.val);
            return bits;
        }

        method pci_mapping_enabled() -> (bool) {
            return (e.get() != 0
                    && expansion_rom.obj
                    && expansion_rom_size.val != 0);
        }

        method pci_mapping_object() -> (conf_object_t *) {
            return expansion_rom.obj;
        }
    }

    method pci_raise_interrupt() default {
        pci_raise_interrupt_pin(interrupt_pin.val - 1);
    }

    method pci_lower_interrupt() default {
        pci_lower_interrupt_pin(interrupt_pin.val - 1);
    }

    method pci_system_error() default {
        /* only if SERR# enable in the command register */
        if (command._se.get() == 1) {
            if (pci_bus.obj != NULL)
                pci_bus.pci_bus.system_error();
            else
                log info, 2, PCI_config:
                    "Attempt to access system error with the PCI bus"
                    + " disconnected";
            status.ssa.set(1);
        }
    }
}

/* Type 0 base/internal template used below */
template _pci_config_type_0 {
    register cardbus_cis_ptr     size 4 @ 0x28 is (read_only_custom_write) {
        param documentation = "Cardbus CIS Pointer";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
    }
    register subsystem_vendor_id size 2 @ 0x2c is (read_only_custom_write) {
        param documentation = "Subsystem Vendor ID";
    }
    register subsystem_id        size 2 @ 0x2e is (read_only_custom_write) {
        param documentation = "Subsystem ID";
    }
    register min_gnt             size 1 @ 0x3e is (read_only_custom_write) {
        param documentation = "MIN_GNT";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
    }
    register max_lat             size 1 @ 0x3f is (read_only_custom_write) {
        param documentation = "MAX_LAT";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
    }
    register expansion_rom_base @ 0x30;
}

/* Type 0 Configuration (single function, or one PF per object instance) */
template pci_config_type_0 {
    is pci_config_generic; // with function number set
    is _pci_config_type_0;
}

/* Type 0 Configuration (multi function, more than one PF per object instance) */
template pci_config_type_0_mf is (_pci_config_generic, _pci_config_type_0) {

    param mf_fun;

    register header_type {
        field mf { param init_val = 1; }
    }

    register bus_address {
        method update() {
            if (this.val == this.init_val) {
                if (pci_bus.obj != NULL)
                    this.val = pci_bus.pci_bus.get_bus_address(dev.obj)
                    | (dev.pcie_device ? mf_fun << 12 : mf_fun << 8);
                else
                    log info, 2, PCI_config:
                        "Attempt to access bus_address with the PCI bus"
                        + " disconnected";
            }
        }
    }
}

/* Type 1 Configuration */
template pci_config_type_1 is pci_config_generic {

    register class_code {
        // TODO: fix SIMICS-9271, remove these parameters
        param class_code default 0x06;
        param sub_class_code default 0x04;
        param interface default 0x0;
        param init_val = (class_code << 16
                                      | sub_class_code << 8 | interface);
    }

    register header_type {
        field type { param init_val = 0x1; } // bridge header type
    }

    register primary_bus_number        size 1 @ 0x18 {
        param documentation = "Primary Bus Number";
    }
    register secondary_bus_number      size 1 @ 0x19 {
        param documentation = "Secondary Bus Number";
    }
    register subordinate_bus_number    size 1 @ 0x1a {
        param documentation = "Subordinate Bus Number";
    }
    register secondary_latency_timer   size 1 @ 0x1b {
        param documentation = "Secondary Latency Timer";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
    }
    register io_base                   size 1 @ 0x1c {
        param documentation = "I/O Base";
        field type   @ [3:0] is (silent_constant);
        field addr   @ [7:4];
    }
    register io_limit                  size 1 @ 0x1d {
        param documentation = "I/O Limit";
        field type  @ [3:0] is (silent_constant);
        field addr  @ [7:4];
    }

    register secondary_status          size 2 @ 0x1e {
        param documentation = "Secondary Status";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field mhz  @ [5:5]   is ignore_write   "66 MHz Capable";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field fbb  @ [7:7]   is ignore_write   "Fast Back-to-Back Transactions Capable";
        field pe   @ [8:8]   is write_1_clears "Master Data Parity Error";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field ds   @ [10:9]  is ignore_write   "DEVSEL timing";
        field sta  @ [11:11] is write_1_clears "Signaled Target Abort";
        field rta  @ [12:12] is write_1_clears "Received Target Abort";
        field rma  @ [13:13] is write_1_clears "Received Master Abort";
        field ssa  @ [14:14] is write_1_clears "Received System Abort";
        field dpe  @ [15:15] is write_1_clears "Detected Parity Error";
    }

    register memory_base               size 2 @ 0x20 {
        param documentation = "Memory Base";
        field type   @ [3:0] is (silent_constant);
        field addr  @ [15:4];
    }
    register memory_limit              size 2 @ 0x22 {
        param documentation = "Memory Limit";
        field type   @ [3:0] is (silent_constant);
        field addr  @ [15:4];
    }

    register prefetchable_base         size 2 @ 0x24 {
        param documentation = "Prefetchable Memory Base";
        field sf     @ [3:0] is (silent_constant);
        field addr  @ [15:4];
    }
    register prefetchable_limit        size 2 @ 0x26 {
        param documentation = "Prefetchable Memory Limit";
        field sf     @ [3:0] is (silent_constant);
        field addr  @ [15:4];
    }

    register prefetchable_base_upper   size 4 @ 0x28 {
        param documentation = "Prefetchable Memory Base Upper 32 Bits";
    }
    register prefetchable_limit_upper  size 4 @ 0x2c {
        param documentation = "Prefetchable Memory Limit Upper 32 Bits";
    }
    register io_base_upper             size 2 @ 0x30 {
        param documentation = "I/O Base Upper 16 Bits";
    }
    register io_limit_upper            size 2 @ 0x32 {
        param documentation = "I/O Limit Upper 16 Bits";
    }

    register expansion_rom_base               @ 0x38;

    register bridge_control            size 2 @ 0x3e {
        param documentation = "Bridge Control";
        field pere  @ [0:0]   "Parity Error Response Enable";
        field serr  @ [1:1]   "SERR# Enable";
        field isae  @ [2:2]   "ISA Enable";
        field vgae  @ [3:3]   "VGA Enable";
        field vga16d  @ [4:4] "VGA 16-bit Decode";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field mam   @ [5:5]   "Master Abort Mode";
        field sbr   @ [6:6]   "Secondary Bus Reset";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field fbbe  @ [7:7]   "Fast Back-to-Back Transactions Enable";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field pdt   @ [8:8]   "Primary Discard Timer";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field sdt   @ [9:9]   "Secondary Discard Timer";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field dts   @ [10:10] "Discard Timer Status";
        // TODO(ah): in PCIe, this bit must be 0 and RO (ignore_write)
        field dtse  @ [11:11] "Discard Timer SERR# Enable";
    }

    register irq_pin_count[i < 4] size 1 is (unmapped) {
        param documentation = "Forwarded interrupt count for bridges";
    }

    inline method irq_bridge_count(inline pin) -> (uint64) {
        local uint64 count;
        count = irq_pin_count[pin].val;
        return count;
    }
}

template map_params {
    param map_type : const char*;
    param map_type default "";
    param map_bit : uint64;
    param map_bit = defined(map_type)
                    #? (map_type == "memory" #? 0 #: 1)
                    #: -1;
    param map_func : int64;
}

template base_address is (register, map_params) {
    #if (!_provides_pci_bus_connect) {
        error "Using base_address register in a device that does not " +
              "inherit from 'providing_pci_bus_connect'";
    }

    param enabled default false;         /* is this register used? */
    param base_msb = size == 8 ? 63 : 31;
    param min_size_bits : uint64;
    param size_bits : uint64;
    param size_bits default min_size_bits;

    param configuration = enabled ? "optional" : "pseudo";

    param _base : field;
    param command : _pci_config_generic_command_reg;
    param command default cast(parent.command, _pci_config_generic_command_reg);

    param parent_bank : _pci_config_generic;
    param parent_bank = cast(bank, _pci_config_generic);

    shared method pci_bar_size_bits() -> (int) default {
        local int bits = size_bits;
        return bits;
    }

    shared method pci_mapping_enabled() -> (bool) default {
        // default is always enabled
        return true;
    }

    shared method pci_mapping_object() -> (conf_object_t *) default {
        // default is the PCI object itself
        return dev.obj;
    }

    shared method _get_bank_obj(conf_object_t *obj) -> (conf_object_t *, int) {
        // Before we had bank objects, we were forced to map the device itself
        // into the memory space once for each BAR, distinguishing mappings by
        // function numbers.  Therefore, our API for selecting bank uses the
        // 'function' parameter to distinguish between banks.  However, since
        // Simics 6 it is more natural to map the bank object directly.

        // A BAR specifies target through the map_func parameter and
        // pci_mapping_object() method; this method tries to re-interpret this
        // to a bank object (with function 0) if possible.  The API allows the
        // user to specify a non-zero function of a different object. This is
        // not an intended use case, and we handle it defensively by leaving
        // the mapping unchanged.
        if (obj == dev.obj) {
            foreach bank in (each function_mapped_bank in (dev)) {
                if (bank.function == map_func) {
                    local int len = strlen(bank._qname());
                    local char name[5 + len + 1];
                    memcpy(name, "bank.", 5);
                    memcpy(name + 5, bank._qname(), len + 1);
                    local conf_object_t *bank_obj = SIM_object_descendant(
                        obj, name);
                    assert bank_obj != NULL;
                    // interface does not exist if mappable=false
                    if (SIM_c_get_interface(bank_obj, "io_memory") != NULL
                        || SIM_c_get_interface(bank_obj, "transaction") != NULL)
                        return (bank_obj, 0);
                }
            }
        }
        return (obj, map_func);
    }

    shared method pci_mapping_target() -> (conf_object_t *) default {
        // default target is NULL
        return NULL;
    }

    shared method pci_mapping_customize(map_info_t *info) default {
        // default is not to change anything
    }

    shared method pci_mapping_base() -> (uint64) default {
        return get_base() << _base.lsb;
    }

    shared method pci_mapping_length() -> (uint64) default {
        return 1 << pci_bar_size_bits();
    }

    /* Calculates the value of the base field, taking into account current
       setting of size-bits */
    shared method get_base() -> (uint64) default {
        return _base.get() & ~((1 << (pci_bar_size_bits() - _base.lsb)) - 1);
    }

    shared method remove_map() default {
        if (map_func < 0) {
            log info, 3, PCI_config:
                "Removing mapping for unknown base address %s", this._qname();
        } else {
            #if (!_provides_pci_bus_connect) {
                // Should be unreachable
                log error, 1: "base_address register accessed in device that " +
                       "does not instantiate providing_pci_bus_connect";
                assert false;
            } #else {
                local conf_object_t *map_obj;
                if (pci_bus.obj == NULL) {
                    log info, 2, PCI_config:
                      "Attempt to remove mapping with the PCI bus disconnected";
                    return;
                }

                map_obj = pci_mapping_object();
                if (map_obj) {
                    local addr_space_t type = strcmp(map_type, "memory") == 0
                        ? Sim_Addr_Space_Memory : Sim_Addr_Space_IO;
                    // Unmap *both* by function and by bank object:
                    // The default implementation of add_map maps
                    // bank object, but in Simics 5, add/remove only operated
                    // on function mappings. One supported use case was
                    // to override add_map to add a tweaked function mapping,
                    // and rely on the default remove_map implementation to
                    // remove it. We must unmap both to retain compatibility
                    // with that use case.
                    // This is sometimes needed when loading checkpoints of
                    // pci models previously written in 1.2 that have been
                    // ported to 1.4 after the checkpoint
                    pci_bus.pci_bus.remove_map(map_obj,
                                               type,
                                               map_func);
                    local conf_object_t *bank_obj;
                    local int func;
                    (bank_obj, func) = _get_bank_obj(map_obj);
                    if (bank_obj != map_obj)
                        pci_bus.pci_bus.remove_map(bank_obj, type, func);
                }
            }
        }
    }

    shared method add_map() default {
        if (map_func < 0) {
            log error, 1, PCI_config:
                "Adding mapping for unknown base address %s", _qname();
        } else {
            #if (!_provides_pci_bus_connect) {
                // Should be unreachable
                log error, 1: "base_address register accessed in device that " +
                       "does not instantiate providing_pci_bus_connect";
                assert false;
            } #else {
                local map_info_t info;
                local conf_object_t *map_obj;
                local conf_object_t *map_target;
                if (pci_bus.obj == NULL) {
                    log info, 2, PCI_config:
                        "Attempt to add mapping with the PCI bus"
                        + " disconnected";
                    return;
                }

                // add this new mapping
                info.base = pci_mapping_base();
                info.length = pci_mapping_length();
                info.function = map_func;

                // let the implementer customize the mapping as necessary
                // and here map_obj, map_target and info
                // will be used as parameters
                // when calling map_demap:add_map() in pci_bus.add_map()
                map_obj = pci_mapping_object();
                map_target = pci_mapping_target();
                pci_mapping_customize(&info);

                // but prevent the function number from being changed
                if (info.function != map_func) {
                    log error, 1, PCI_config:
                        "Function number should not be changed when mapping %s",
                        _qname();
                }
                (map_obj, info.function) = _get_bank_obj(map_obj);
                if (info.base == 0)
                    log info, 3, PCI_config: "Zero %s mapping", _qname();

                log info, 3, PCI_config:
                    "New %s space mapping for %s (obj %s, target %s, fn %d):"
                    + " base = %#x, length = %#x",
                    map_type, name, SIM_object_name(map_obj),
                    map_target ? SIM_object_name(map_target) : "(none)",
                    info.function, info.base, info.length;

                pci_bus.pci_bus.add_map(
                    map_obj,
                    strcmp(map_type, "memory") == 0 ? Sim_Addr_Space_Memory
                                          : Sim_Addr_Space_IO,
                    map_target, info);
            }
        }
    }

    shared method update_mapping();
}

template memory_base_address_generic is base_address {
    param enabled = true;
    param map_type = "memory";
    param min_size_bits default 4;
    param _type : field;

    shared method update_mapping() default {
        remove_map();
        if (command._mem.get() != 0 && pci_mapping_enabled()) {
            this.add_map();
        }
    }

    /* Overridden from base_address; needed to handle 64-bit BARs configured
       as 32-bit BAR */
    shared method pci_mapping_base() -> (uint64) {
        local uint64 map_base;
        map_base = get_base();

        map_base <<= _base.lsb;

        if (_type.get() == 0b00)
            map_base &= 0xffffffff;
        return map_base;
    }

    param _base = cast(base, field);
    field base @ [base_msb:min_size_bits] is (read, write) {
        param documentation = "The base address";

        method read() -> (uint64) default {

            local uint64 value;
            value = get_base();

            if (_type.get() == 0b00)
                value &= 0xffffffff >> lsb;

            return value;

        }

        method write(uint64 value) default {
            if (this.get() != value) {
                this.set(value);
                if (command._mem.get() != 0) {
                    // no effect unless decoding is enabled
                    update_mapping();
                }
            }
        }
    }

    field p  @ [3:3] is ignore_write {
        param documentation = "Prefetchable";
    }

    param _type = cast(type, field);
    field type  @ [2:1] is (ignore_write, set) {
        param documentation = "Type (00: anywhere in 32-bit space;"
            + " 10: anywhere in 64-bit space)";
        method set(uint64 value) default {
            if (value == 0b01 || value == 0b11) {
                log spec_viol, 1, PCI_config:
                    "Setting %s to reserved value %d ignored",
                    qname, value;
                return;
            }

            // only 64-bit BAR can be changed to behave like a 32-bit BAR
            if (value != this.get() && size == 4) {
                log spec_viol, 1, PCI_config:
                    "Unable to change type of 32-bit BAR.";
                return;
            }

            default(value);
        }
    }

    field s  @ [0:0] is ignore_write {
        param documentation = "Memory Space Indicator";
        param override_map_bit default undefined;
        param init_val = (defined override_map_bit)
            #? override_map_bit #: map_bit;
    }
}

template memory_base_address_32 is (register, memory_base_address_generic) {
    param size = 4;
    field type { param init_val = 0b00; }
}

template memory_base_address_64 is (register, memory_base_address_generic) {
    param size = 8;
    field type { param init_val = 0b10; }
}

template io_base_address is base_address {
    param enabled = true;
    param map_type = "I/O";
    param min_size_bits default 2;
    param size = 4;

    method update_mapping() default {
        this.remove_map();
        if (command._io.get() != 0 && pci_mapping_enabled()) {
            this.add_map();
        }
    }

    param _base = cast(base, field);
    field base  @ [31:min_size_bits] is (read, write) {
        param documentation = "The base address";
        method read() -> (uint64) default {
            return get_base();
        }
        method write(uint64 value) default {
            if (this.get() != value) {
                this.set(value);
                if (command._io.get() != 0) {
                    // no effect unless decoding is enabled
                    update_mapping();
                }
            }
        }
    }

    field p  @ [1:1] is (silent_constant) "Reserved" {
        param init_val = 0;
    }

    field s  @ [0:0] is ignore_write {
        param documentation = "I/O Space Indicator";
        param override_map_bit default undefined;
        param init_val = (defined override_map_bit)
            #? override_map_bit #: map_bit;
    }
}

template _no_base_address is map_params {
    param map_type = "none";
    param map_func = -1;
    param size;
    field ignore  @ [size * 8 - 1:0] is (silent_constant) {
        param init_val = 0;
    }
}

template no_base_address_32 is (register, _no_base_address) {
    param size = 4;
}

template no_base_address_64 is (register, _no_base_address) {
    param size = 8;
}

import "simics/base/memory.dml"; /* for SIM_describe_pseudo_exception */

// DMA methods
template providing_dma_methods {
    session uint32 _tlp_prefix;

    // Transition parameter that adds TLP Prefix support to DMA methods
    param enable_tlp_prefix_support default false;

    // Sets the TLP Prefix for the _next_ transaction. The Prefix will be
    // cleared by the transaction and must be set again for the next
    // transaction.
    // NOTE: this method is considered internal and may change in future
    // versions to support multiple prefixes
    method pci_set_tlp_prefix(uint32 tlp_prefix) {
        _tlp_prefix = tlp_prefix;
    }

    // (internal) helper method for pci_[value,data]_[from,to]_memory  methods
    method _set_tlp_prefix(pci_memory_transaction_t *trans) {
        if (enable_tlp_prefix_support && _tlp_prefix >> 29 == 4) {
            VT_set_pci_mem_op_tlp_prefix(trans, _tlp_prefix);
            _tlp_prefix = 0;
        }
    }

    method pci_data_from_memory(addr_space_t space, void *buffer,
                                 uint64 address, uint64 size)
            -> (exception_type_t) default {
        local exception_type_t ex;
        if (pci_bus.obj == NULL) {
            log info, 2, PCI_config:
               "Attempt to perform DMA read with the PCI bus disconnected";
            ex = Sim_PE_IO_Not_Taken;
            return ex;
        }

        if (pci_config_bank.command.m.get() == 0
            && space != Sim_Addr_Space_Conf) {
            log spec_viol, 1, PCI_DMA:
                "trying to access PCI bus, but Bus Master Enable bit"
                + " in Command register is not set";
            ex = Sim_PE_IO_Not_Taken;
            return ex;
        }

        log info, 4, PCI_DMA:
            "reading %d bytes from %s %s space",
            size, dev.pcie_device ? "PCIe" : "PCI",
            (space == Sim_Addr_Space_Memory) ?
            "memory" : (space == Sim_Addr_Space_Conf) ?
            "config" : "io";

        // TODO: make this interface required and deprecate io_memory
        // TODO: disabled entirely for now until we have a clear migration path
        // for existing devices
        if (false) {  // $pci_bus.pci_upstream_operation) {
            pci_config_bank.bus_address.update();
            local int rid = pci_config_bank.bus_address.get();
            // simics supports PCI devices on pcie-bus/link and we currently
            // don't have a way for devices to ask the bus about the current
            // bus number. The pci_bus::get_bus_address() returns the address
            // in config space, which needs a context (PCI or PCIe) in order to
            // be correctly translated into a Requester ID. The assumption for
            // now is that PCI devices does not support Requester ID and can
            // set this value to 0.
            rid = pcie_device ? rid >> 12 : 0;
            local buffer_t buf;
            buf.data = buffer;
            buf.len = size;
            ex = pci_bus.pci_upstream_operation.read(dev.obj, rid, space, address, buf);
        } else {
            // legacy/backwards compatibility implementation using io_memory
            local pci_memory_transaction_t trans;
            local map_info_t info;
            SIM_set_mem_op_physical_address(&trans._internal_s, address);
            SIM_set_mem_op_type(&trans._internal_s, Sim_Trans_Load);
            trans._internal_s.size = size;
            trans._internal_s.block_STC = 1;
            trans._internal_s.may_stall = 0;
            SIM_set_mem_op_initiator(&trans._internal_s,
                                     Sim_Initiator_PCI_Device, dev.obj);
            trans._internal_s.real_address = buffer;
            pci_config_bank.bus_address.update();
            trans._internal_bus_address = pci_config_bank.bus_address.val;
            info.function = space;
            _set_tlp_prefix(&trans);
            ex = pci_bus.io_memory.operation(&trans._internal_s, info);
        }

        if (ex == Sim_PE_IO_Not_Taken) {
            // master abort
            log info, 2, PCI_DMA: "Master Abort received";
            pci_config_bank.status.rma.set(1);
        } else if (ex == Sim_PE_IO_Error) {
            // target abort
            log info, 2, PCI_DMA: "Target Abort received";
            pci_config_bank.status.rta.set(1);
        } else if (ex != Sim_PE_No_Exception) {
            log error, 1, PCI_DMA:
                "Unknown exception received on PCI bus: %s (%d)",
                SIM_describe_pseudo_exception(ex), cast(ex, int);
        } else {
            log info, 4, PCI_DMA: "Reading %d bytes from address 0x%x",
                size, address;
        }
        return ex;
    }

    method pci_value_from_memory(addr_space_t space, uint64 address, uint8 size)
        -> (uint64, exception_type_t) /* value, ex */ default {
        local uint64 value;
        local exception_type_t ex;
        local uint64 buf = 0;

        if (size > 8)
            log error, 1, PCI_DMA: "Too large size of DMA access";

        ex = pci_data_from_memory(space, &buf, address, size);
        value = convert_le64(buf);
        return (value, ex);
    }

    method pci_data_to_memory(addr_space_t space, const void *buffer,
                              uint64 address, uint64 size)
        -> (exception_type_t) default {
        local exception_type_t ex;
        if (pci_bus.obj == NULL) {
            log info, 2, PCI_config:
               "Attempt to perform DMA write with the PCI bus disconnected";
            ex = Sim_PE_IO_Not_Taken;
            return ex;
        }

        if (pci_config_bank.command.m.get() == 0
            && space != Sim_Addr_Space_Conf) {
            log spec_viol, 1, PCI_DMA:
                "trying to access PCI bus, but Bus Master Enable bit"
                + " in Command register is not set";
            ex = Sim_PE_IO_Not_Taken;
            return ex;
        }

        log info, 4, PCI_DMA:
            "writing %d bytes to %s %s space",
            size, dev.pcie_device ? "PCIe" : "PCI",
            (space == Sim_Addr_Space_Memory) ?
            "memory" : (space == Sim_Addr_Space_Conf) ?
            "config" : "io";

        // TODO: make this interface required and deprecate io_memory
        // TODO: disabled entirely for now until we have a clear migration path
        // for existing devices
        if (false) {  // $pci_bus.pci_upstream_operation) {
            pci_config_bank.bus_address.update();
            local int rid = pci_config_bank.bus_address.get();
            // simics supports PCI devices on pcie-bus/link and we currently
            // don't have a way for devices to ask the bus about the current
            // bus number. The pci_bus::get_bus_address() returns the address
            // in config space, which needs a context (PCI or PCIe) in order to
            // be correctly translated into a Requester ID. The assumption for
            // now is that PCI devices does not support Requester ID and can
            // set this value to 0.
            rid = pcie_device ? rid >> 12 : 0;
            local bytes_t buf;
            buf.data = buffer;
            buf.len = size;
            ex = pci_bus.pci_upstream_operation.write(dev.obj, rid, space, address, buf);
        } else {
            // legacy/backwards compatibility implementation using io_memory
            local pci_memory_transaction_t trans;
            local map_info_t info;
            SIM_set_mem_op_physical_address(&trans._internal_s, address);
            SIM_set_mem_op_type(&trans._internal_s, Sim_Trans_Store);
            trans._internal_s.size = size;
            trans._internal_s.block_STC = 1;
            trans._internal_s.may_stall = 0;
            SIM_set_mem_op_initiator(&trans._internal_s,
                                     Sim_Initiator_PCI_Device, dev.obj);
            trans._internal_s.real_address = cast(buffer, void *);
            pci_config_bank.bus_address.update();
            trans._internal_bus_address = pci_config_bank.bus_address.val;
            info.function = space;
            _set_tlp_prefix(&trans);
            ex = pci_bus.io_memory.operation(&trans._internal_s, info);
        }

        if (ex == Sim_PE_IO_Not_Taken) {
            // master abort
            log info, 2, PCI_DMA: "Master Abort received";
            pci_config_bank.status.rma.set(1);
        } else if (ex == Sim_PE_IO_Error) {
            // target abort
            log info, 2, PCI_DMA: "Target Abort received";
            pci_config_bank.status.rta.set(1);
        } else if (ex != Sim_PE_No_Exception) {
            log error, 1, PCI_DMA:
                "Unknown exception received on PCI bus: %s (%d)",
                SIM_describe_pseudo_exception(ex), cast(ex, int);
        } else {
            log info, 4, PCI_DMA: "Writing %d bytes to address 0x%x",
                size, address;
        }
        return ex;
    }

    method pci_value_to_memory(addr_space_t space, uint64 value, uint64 address,
                               uint8 size)
        -> (exception_type_t) default {
        local exception_type_t ex;
        local uint64 buf;

        if (size > 8)
            log error, 1, PCI_DMA: "Too large size of DMA access";

        buf = value;
        buf = convert_le64(buf);
        ex = pci_data_to_memory(space, &buf, address, size);
        return ex;
    }
}

// Interrupts
template providing_legacy_interrupts {

    method pci_lower_all_pins() default {
         log info, 3, PCI_IRQ: "Lowering all active pins";
         local int pin = 0;
         for (pin = 0 ; pin < 4; ++pin) {
             if (pci_config_bank.interrupts.val[pin] == 1) {
                 pci_lower_interrupt_pin(pin);
             }
         }
    }

    method pci_raise_interrupt_pin(int pin) default {
        assert 0 <= pin && pin < 4;
        /* always set status bit */
        pci_config_bank.status.ins.set(1);

        /* but only raise signal if not already raised or disabled */
        local int bridge_count;
        bridge_count = pci_config_bank.irq_bridge_count(pin);
        if (pci_config_bank.interrupts.val[pin] == 0 &&
            bridge_count == 0) {
            if (pci_config_bank.command.id.get() == 0) {
                if (pci_bus.obj == NULL) {
                    log info, 2, PCI_config: "Attempt to raise legacy"
                        + " interrupt with the PCI bus disconnected";
                    return;
                }
                log info, 4, PCI_IRQ: "Raising interrupt pin %d (%s)",
                    pin, irq_pin_name[pin];
                pci_bus.pci_bus.raise_interrupt(dev.obj, pin);
                pci_config_bank.interrupts.val[pin] = 1;
            } else {
                log info, 3, PCI_IRQ:
                    "Interrupts disabled, no interrupt raised";
            }
        } else {
            log info, 4, PCI_IRQ: "Signal already raised for pin %d (%s)",
                pin, irq_pin_name[pin];
        }
    }

    method pci_lower_interrupt_pin(int pin) default {
        assert 0 <= pin && pin < 4;
        /* only lower signal if raised */
        local int bridge_count;
        bridge_count = pci_config_bank.irq_bridge_count(pin);
        if (pci_config_bank.interrupts.val[pin] == 1) {
            pci_config_bank.interrupts.val[pin] = 0;
            if (bridge_count == 0) {
                if (pci_bus.obj == NULL) {
                    log info, 2, PCI_config: "Attempt to lower legacy"
                        + " interrupt with the PCI bus disconnected";
                } else {
                    log info, 4, PCI_IRQ: "Lowering interrupt pin %d (%s)",
                        pin, irq_pin_name[pin];
                    pci_bus.pci_bus.lower_interrupt(dev.obj, pin);
                }
            } else {
                log info, 4, PCI_IRQ:
                    "Forwarded interrupts still pending acknowledgement,"
                    + " interrupt pin %d (%s) not lowered",
                    pin, irq_pin_name[pin];
            }
        } else {
            log info, 4, PCI_IRQ: "Signal already lowered for pin %d (%s)",
                pin, irq_pin_name[pin];
        }

        /* clear status bit when _all_ interrupts have been lowered */
        if (pci_config_bank.interrupts.val == 0)
            pci_config_bank.status.ins.set(0);
    }
}

// Interface
template providing_pci_device_interface {

    implement pci_device {
        method bus_reset() default {
            pci_bus_disconnected();
        }
    }
}

/* PCIe devices have an extended configuration space. The capabilities listed
   here are separate from the normal capability list in the normal conf space.
   Thus, software must try reading the first extended capability ID at 0x100.

   If the device doesn't implement any extended capabilities, we can use this
   template to avoid getting read accesses "outside registers" errors. */
template defining_empty_pcie_extended_conf_space {
    register exp_ext_no_capability_id size 2 @ 0x100
        is (read_zero, ignore_write) {
        param configuration = "none";
    }
    register exp_ext_next_ptr         size 2 @ 0x102
        is (read_zero, ignore_write) {
        param configuration = "none";
    }
}
