/*
  e1000-mac-rx.dml

  Â© 2010 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

dml 1.2;

/* Multiple Rx queues parameters (RSS) */
parameter RETA_CNT = 128;

/* VLAN packet filter array size */
parameter VFTA_CNT = 128;

/* RSS Random Key array size */
parameter RSSRK_CNT = 40;

parameter RAH_ASEL_DESTINATION_ADDRESS = 0b00;
parameter RAH_ASEL_SOURCE_ADDRESS = 0b01;      // Currently not supported

parameter NUM_ETHTYPE_FILTERS = 8;

extern int sprintf(char *str, const char *format, ...);
extern int sscanf(const char *str, const char *format, ...);

/*
  The mac address of the device. When accessed as an attribute we handle it as
  a string in the standard format. Internally we store it in an uint64. Byte 0
  of the MAC address is stored in bits 0-7, byte 1 is stored in bit 8-15, and
  so on.
*/

attribute mac_address {
    parameter documentation = "MAC address ('XX:XX:XX:XX:XX:XX' string)";
    parameter configuration = "optional";
    parameter allocate_type = "uint64";
    parameter type = "s";

    method get() -> (attr_value_t value) {
        local char mac_str[18];
        sprintf(mac_str, "%02X:%02X:%02X:%02X:%02X:%02X",
                $this[7:0], $this[15:8], $this[23:16],
                $this[31:24], $this[39:32], $this[47:40]);
        value = SIM_make_attr_string(mac_str);
    }

    method set(attr_value_t value) {
        local int mac_byte[6];
        if (sscanf(SIM_attr_string(value), "%x:%x:%x:%x:%x:%x",
                   &mac_byte[0], &mac_byte[1], &mac_byte[2],
                   &mac_byte[3], &mac_byte[4], &mac_byte[5]) == 6) {

            $this[7:0]   = mac_byte[0];
            $this[15:8]  = mac_byte[1];
            $this[23:16] = mac_byte[2];
            $this[31:24] = mac_byte[3];
            $this[39:32] = mac_byte[4];
            $this[47:40] = mac_byte[5];

            /* copy the MAC address to the RAL/RAH registers */
            memcpy(&$csr.ra[0].low, &$this, 4);
            $csr.ra[0].high.rah = ($this >> 32) & 0xffff;
            $csr.ra[0].high.asel = $RAH_ASEL_DESTINATION_ADDRESS;
            $csr.ra[0].high.av = 1;
            if($HAS_EEPROM) {
                call $update_eeprom_macaddress(mac_byte);
                call $update_eeprom_alt_mac();
            }
        } else {
            throw;
        }
    }
}

bank csr {
    register rx_queue_nbr is (unmapped) "Current RX Queue";

    register rctl    @ 0x00100 "Receive Control";
    register fcrtl   @ 0x02160 "Flow Control Receive Threshold Low";
    register fcrth   @ 0x02168 "Flow Control Receive Threshold High";
    register rxcsum  @ 0x05000 "Receive Checksum Control";
    register rfctl   @ 0x05008 "Receive Filter Control";

    register mta[$MTA_CNT] @ 0x05200 + $i * 4 "Multicast Table Array";

    register fcrtl  is (flow_ctl_register);
    register fcrth  is (flow_ctl_register);

    if($HAS_L2_ETHTYPE_FILTERS) {
        register etqf[$NUM_ETHTYPE_FILTERS] @ 0x5cb0 + $i * 4 "Etype Queue Filter";
        register etqf[$NUM_ETHTYPE_FILTERS] {
            field queue_enable[31];
            field time_stamp[30];
            field immediate_interrupt[29];
            field filter_enable[26];
            field length_enable[25];
            field length[24:20];
            field rx_queue[19:16];  /* Up to 16 queues */
            field etype[15:0];
        }
    }

    if($HAS_RSS_CPU_SELECTION) {
        register cpuvec  @ 0x02c10 "CPU Vector";
        register rssim   @ 0x05864 "RSS Interrupt Mask";
        register rssir   @ 0x05868 "RSS Interrupt Request";

        register cpuvec {
            method read() -> (value) {
                value = $this;
                $rssim &= ~$this;
                $this = 0;
                $icr[7] = 0;
                $icr[16] = 0;
                $icr[17] = 0;
                call $update_interrupt();
            }
            method write(value) {
                $rssim &= ~value;
            }
        }

        register rssim {
            method write(value) {
                $this |= value;
            }
        }

        register rssir is (write_1_clears);
    } else {
        register cpuvec  @ 0x02c10 is (unimplemented) "CPU Vector";
        register rssim   @ 0x05864 is (unimplemented) "RSS Interrupt Mask";
        register rssir   @ 0x05868 is (unimplemented) "RSS Interrupt Request";
    }

    if($HAS_RSS) {
        register reta[$RETA_CNT]   size 1 @ 0x05c00 + $i "Redirection Table";
        register rssrk[$RSSRK_CNT] size 1 @ 0x05c80 + $i "RSS Random Key";
    }

    if($VLAN_PACKET_FILTER) {
        register vfta[$VFTA_CNT] @ 0x05600 + $i * 4 "VLAN Filter Table Array";
    }

    method receive_frame(dbuffer_t *buf, int crc_ok) default {
        if ($rctl.en == 0) {
            log "info", 4: "dropped incoming frame for receiver is disabled";
            return;
        }

        local const uint8 *frame = dbuffer_read_all(buf);
        local frame_info_t info;
        memset(&info, 0, sizeoftype(frame_info_t));
        info.length = dbuffer_len(buf);

        log "info", 4: "received frame (%d bytes, crc_ok: %d)", info.length, crc_ok;
        call $count_total_rx_packet(info.length);
        call $dump_txrx_frame(buf, "Received frame");

        local bool gp;
        inline $rx_frame_precheck(frame, crc_ok, &info) -> (gp);
        if (!gp) {
            inline $count_bad_rx_packet(info.length);
            return;
        }
        inline $count_good_rx_packet(info.length, info.multi, info.bcst);

        local dbuffer_t    *clone   = NULL;
        clone = dbuffer_clone(buf);
        info.drop_it = false;
        info.l2_parse = true;
        info.l3_parse = true;
        try {
            inline $l1_frame_parse(clone, frame, &info);
            if (info.drop_it) {
                log "info", 2: "dropped received frame due to L1 filtering result";
                throw;
            }

            frame = dbuffer_read_all(clone);
            if (info.l2_parse) {
                inline $l2_frame_parse(&frame[info.l2_index], &info);
                if (info.l3_parse) {
                    inline $l3_frame_parse(frame, &info);

                    /* Encapsulated IPv6? */
                    if(info.ipv4_ipv6) {
                        inline $l4_frame_parse(frame, &info);
                    }

                    if ($HAS_TIMESYNC) {
                        if (!info.fragmented) {
                            if (info.udp
                                && (info.l4_prot == UDP_EVENT_PORT_PTP
                                    || info.l4_prot == UDP_GENERAL_PORT_PTP)) {
                                call $check_timesync_post_l3_parse(clone,
                                                                   &info);
                                if (info.drop_it) {
                                    log "info", 2: "drops received frame due"
                                        + " to TimeSync filter";
                                    throw;
                                }
                            }
                        }
                    }
                }
            }

            if($HAS_RSS) {
                if ($mrqc.mrqe == 0b01) {
                    inline $calc_frame_rss_hash(&frame[info.l2_index], &info);
                } else {
                    info.hash = 0;
                    info.rss_type = 0;
                }
            }

            local bool empty;
            inline $multiple_queue_select(&info);
            inline $rx_queue[$rx_queue_nbr].check_descriptor(info.length) -> (empty);
            if (empty) {
                call $count_no_buffer();
                log "info", 2: "discards incoming frame for lack of descriptor buffers";
                throw;
            }

            inline $rx_queue[$rx_queue_nbr].queue_store_packet(frame, &info);

            if($HAS_RSS_CPU_SELECTION) {
                // Set the RSS interrupt request and CPU vector bit
                if ($mrqc.mrqe != 0b00 && info.rss_type != 0) {
                    $rssir |= (1 << info.cpu);
                    $cpuvec = $rssir & $rssim;

                    if ($cpuvec != 0) {
                        log "unimplemented":
                            "raise interrupt to specified CPU is unimplemented";
                    }
                }
            }

            inline $rx_queue[$rx_queue_nbr].rx_interrupt();

            if($HAS_SMALL_PACKET_DETECTION) {
                if ((info.length + 4 * $rctl.secrc) <= $rsrpd) {
                    inline $rx_delay.reinit();
                    inline $raise_interrupt(INTR_SRPD | INTR_RXT0);
                }
            }

            if($HAS_ACK_ACCELERATION) {
                if (info.ack)
                    inline $ack_delay.raise($raid * 1.024e-6);
            }
        } catch {
            // do nothing
        }
        dbuffer_free(clone);
    }

    method rx_frame_precheck(const uint8* frame,
                             int crc_ok, frame_info_t *info) -> (bool ok) {
        local bool fcs_passed = true;
        local bool dst_passed;
        local bool vlan_passed = true;
        local bool len_passed = true;
        local int max_len = $rctl.lpe == 0 ? 1522 : 16384;
        local eth_tagged_header_t *eth = cast(frame, void*);

        inline $exact_address_filter(eth->da) -> (dst_passed);
        info->pif = dst_passed;
        if (!dst_passed)
            inline $packet_address_filter(eth->da, info) -> (dst_passed);

        if($VLAN_PACKET_FILTER) {
            inline $vlan_packet_filter(&eth->vtag, info) -> (vlan_passed);
        }

        if (crc_ok == 0) {
            call $calc_crc32(frame, info->length-4) -> (info->cal_crc);
            info->rxd_crc =
                UNALIGNED_LOAD_BE32(cast(&frame[info->length-4], void*));
            if (info->cal_crc != info->rxd_crc) {
                info->rx_err = 1;
                fcs_passed = false;
                if (dst_passed && vlan_passed)
                    inline $crcerrs.count(1);
                log "info", 2: "received incorrect CRC 0x%x (expected 0x%x)",
                    info->rxd_crc, info->cal_crc;
            }
        }

        if (info->length < 64 || info->length > max_len) {
            len_passed = false;
            inline $rlec.count(1);
            log "info", 2: "received a frame with length error %d", info->length;
            if (dst_passed && vlan_passed) {
                if (fcs_passed) {
                    if (info->length < 64)
                        inline $ruc.count(1);
                    else
                        inline $roc.count(1);
                } else {
                    if (info->length < 64)
                        inline $rfc.count(1);
                    else
                        inline $rjc.count(1);
                }
            }
        }

        fcs_passed = ($rctl.sbp != 0) ? true : fcs_passed;
        ok = fcs_passed && dst_passed && vlan_passed && len_passed;
    }

    method l1_frame_parse(dbuffer_t *buf,
                          const uint8 *frame, frame_info_t *info) default {
        local const ethernet_header_t *eth = cast(frame, void *);

        if ($ctrl.vme == 1 && eth->type == ETH_TYPE_VLAN) {
            local const eth_tagged_header_t *th = cast(frame, void *);
            info->vp = true;
            info->vlan = th->vtag.vlan;
            info->type = th->type;
            info->l2_index = 18;
            log "info", 4: "received VLAN tagged packet (vlan = %d, type = %d)",
                info->vlan, info->type;
        } else if (eth->type == ETH_TYPE_MACSEC) {
            info->type = ETH_TYPE_MACSEC;
            info->l2_parse = false;
if ($ICH10_ETHERNET_LAN) {
            log "info", 4: "a MACsec tagged frame is received";
            call $check_linksec_post_l1_parse(buf, frame, info);
}
        } else if (eth->type == ETH_TYPE_PTP) {
            info->type = ETH_TYPE_PTP;
            info->l2_parse = false;
if ($HAS_TIMESYNC) {
            call $check_timesync_post_l1_parse(buf, frame, info);
}
        } else {
            info->type = eth->type;
            info->l2_index = 14;
        }

        if (info->type == ETH_TYPE_MACSEC)
            return;

        if ($rctl.secrc == 1)
            info->length -= 4;//strip crc from frame

        if (info->vp) {
            dbuffer_remove(buf, 12, 4);//strip vlan tag
            info->length -= 4;//not stored to host memory
            info->l2_index -= 4;//l2_index points to first byte after eth hdr
        }

        // packet checksum
        local uint64 csv;
        call $calc_checksum_value(&frame[$rxcsum.pcss],
                                  info->length - $rxcsum.pcss) -> (csv);
        call $checksum_to_16bit(csv, 0) -> (info->packet_cs);
    }

    method l2_frame_parse(const uint8 *frame, frame_info_t *info) default {
        if (info->type == ETH_TYPE_IPv4) {
            local const ipv4_header_t *ipv4 = cast(frame, void*);
            log "info", 4: "received IPv4 packet";

            info->ipv4 = true;
            info->ip_id = ipv4->id;
            info->l3_index = info->l2_index + ipv4->header.length * 4;
            info->l3_prot = ipv4->protocol;

            if(ipv4->fragment.flags[2] ||
               ipv4->fragment.frag_ofs > 0) {
                info->fragmented = true;
            }

            if ($rxcsum.ipofld == 1) {
                local uint16 iphcs;
                call $calc_ipv4_checksum(frame) -> (iphcs);
                info->ipe = (iphcs != ipv4->checksum);
                log "info", 4: "calculated IPv4 checksum is 0x%04x", iphcs;
            }
        } else if (info->type == ETH_TYPE_IPv6) {
            local const ipv6_header_t *ipv6 = cast(frame, void *);
            local uint16 ipv6_hlen;
            log "info", 4: "received IPv6 packet";

            info->ipv6 = true;
            inline $parse_ipv6_protocol(
                frame, info->length - info->l2_index)
                -> (ipv6_hlen, info->l3_prot);

            info->l3_index = info->l2_index + ipv6_hlen;
            info->ipv6_ext = ipv6_hlen > sizeoftype(ipv6_header_t);
        } else {
            log "info", 4: "Ethernet type is %d",info->type;
        }
    }

    // frame starts from the beginning of the DA of the ethernet header
    method l3_frame_parse(const uint8 *frame, frame_info_t *info) default {
        local uint16 cs = 0;
        local tcp_header_t *th   = cast(frame + info->l3_index, void *);
        local udp_header_t *uh   = cast(frame + info->l3_index, void *);
        local ipv4_header_t *v4h = cast(frame + info->l2_index, void *);
        local ipv6_header_t *v6h = cast(frame + info->l2_index, void *);

        if (info->l3_prot == ETH_PROT_TCP) {
            info->tcp = true;
            info->l4_prot = th->dst_port;
            info->l4_index = info->l3_index + th->control.offset * 4;
            if($HAS_ACK_ACCELERATION) {
                if (($rctl.dtyp == 0b01 || $rfctl.exsten == 1)
                    && $rfctl.ackdis == 0 && th->control.ack == 1) {
                    if ($rfctl.ackd_dis == 1)
                        info->ack = true;
                    else if ((info->length - info->l3_index -
                              4 * (1 - $rctl.secrc)) ==
                             (th->control.offset * 4))
                        info->ack = true; //no cp data
                }
            }
        }

        if (info->l3_prot == ETH_PROT_UDP) {
            info->udp = true;
            info->l4_prot  = uh->dst_port;
            info->l4_index = info->l3_index + 8;
        }

        if (info->l3_prot == ETH_PROT_IPV6_ENCAP) {
            info->ipv4_ipv6 = true;
            info->l4_prot  = uh->dst_port;

            local const ipv6_header_t *ipv6 =
                cast(&frame[info->l3_index], void *);
            local uint16 ipv6_hlen;
            log "info", 4: "received encapsulated IPv6 packet";

            inline $parse_ipv6_protocol(
                cast(&frame[info->l3_index], void *),
                info->length - info->l3_index)
                -> (ipv6_hlen, info->l5_prot);

            info->l4_index = info->l3_index + ipv6_hlen;
        }

        if (!$rxcsum.tuofld ||
            (info->l3_prot != ETH_PROT_TCP && info->l3_prot != ETH_PROT_UDP))
            return;

        // Compare the checksum if required
        if (info->ipv4) {
            if (info->l3_prot == ETH_PROT_UDP && uh->checksum == 0) {
                // UDP checksum may be omitted for IPv4 (see RFC768, RFC2460)
                log "info", 4: "no checksum in received IPv4-UDP packet";
                return;
            }

            local int l3_len = v4h->len - (v4h->header.length * 4);
            if ((l3_len + info->l3_index) <= info->length)
                call $calc_tup_checksum_v4(frame + info->l3_index,
                                           info->l3_prot,
                                           v4h->src,
                                           v4h->dst,
                                           l3_len) -> (cs);
        } else if (info->ipv6) {
            if ((v6h->len + info->l3_index) <= info->length)
                call $calc_tup_checksum_v6(frame + info->l3_index,
                                           info->l3_prot,
                                           cast(&v6h->src[0], uint8 *),
                                           cast(&v6h->dst[0], uint8 *),
                                           v6h->next,
                                           v6h->len) -> (cs);
        }

        log "info", 4:
            "calculated checksum of received %s-%s packet is 0x%04x",
            info->ipv4 ? "IPv4" : "IPv6",
            (info->l3_prot == ETH_PROT_UDP) ? "UDP" : "TCP", cs;
        log "info", 4: "expected checksum is 0x%04x",
            (info->l3_prot == ETH_PROT_UDP) ? uh->checksum : th->checksum;

        if (info->l3_prot == ETH_PROT_TCP)
            info->tupe = (cs != th->checksum);
        else if (info->l3_prot == ETH_PROT_UDP) {
                info->tupe = (cs != uh->checksum);
        }
    }

    // frame starts from the beginning of the DA of the ethernet header
    method l4_frame_parse(const uint8 *frame, frame_info_t *info) default {
        local tcp_header_t *th   = cast(frame + info->l4_index, void *);
        local udp_header_t *uh   = cast(frame + info->l4_index, void *);
        local ipv4_header_t *v4h = cast(frame + info->l3_index, void *);
        local ipv6_header_t *v6h = cast(frame + info->l3_index, void *);

        if (info->l4_prot == ETH_PROT_TCP) {
            info->l5_prot = th->dst_port;
            info->l5_index = info->l4_index + th->control.offset * 4;
        }

        if (info->l4_prot == ETH_PROT_UDP) {
            info->l5_prot  = uh->dst_port;
            info->l5_index = info->l4_index + 8;
        }
    }

    method l2_ethertype_filter(frame_info_t *info) -> (int queue) default {
        local int i;
        for(i = 0;i < $NUM_ETHTYPE_FILTERS;i++) {
            if($etqf[i].filter_enable) {
                if(info->type == $etqf[i].etype) {
                    if($etqf[i].queue_enable) {
                        queue = $etqf[i].rx_queue;
                        log "info", 4:
                            "L2 Etype match in reg %d, queue %d selected",
                            i, queue;
                    }
                }
            }
        }
    }

    method multiple_queue_select(frame_info_t *info) default {
        local int queue = 0;

        if($HAS_L2_ETHTYPE_FILTERS) {
            inline $l2_ethertype_filter(info) -> (queue);
        }

        $rx_queue_nbr = queue;

        if($HAS_RSS) {
            if ($mrqc.mrqe > 0 && info->rss_type != 0) {
                local uint8 index = info->hash & 0x7F;
                $rx_queue_nbr = $reta[index].qidx;
                if($HAS_RSS_CPU_SELECTION)
                    info->cpu = $reta[index].cpu_idx;
            }
        }

        log "info", 4: "rx_queue_nbr = %d", $rx_queue_nbr;
    }

    method compare_mac_addr(uint48 pktaddr, uint64 regaddr) -> (bool match) {
        if (pktaddr[7:0] == regaddr[47:40] &&
            pktaddr[15:8] == regaddr[39:32] &&
            pktaddr[23:16] == regaddr[31:24] &&
            pktaddr[31:24] == regaddr[23:16] &&
            pktaddr[39:32] == regaddr[15:8] &&
            pktaddr[47:40] == regaddr[7:0]) {
            match = true;
        } else {
            match = false;
        }

        log "info", 4: "comparing pktaddr (%02X:%02X:%02X:%02X:%02X:%02X) regaddr (%02X:%02X:%02X:%02X:%02X:%02X), %s",
            pktaddr[47:40], pktaddr[39:32], pktaddr[31:24],
            pktaddr[23:16], pktaddr[15:8], pktaddr[7:0],
            regaddr[7:0], regaddr[15:8], regaddr[23:16],
            regaddr[31:24], regaddr[39:32], regaddr[47:40],
            match ? "match" : "mismatch";
    }

    method packet_address_filter(uint48 da, frame_info_t *info) -> (bool passed) default {
        local bool m;
        passed = true;

        // broadcast filtering
        if (da == ETH_BRCT_MAC) {
            passed = $rctl.bam == 1;
            info->bcst = true;
            log "info", 4:
                "%s a broadcast frame", passed ? "accepted" : "rejected";
            return;
        }

        // multicast filtering
        if ((da & ETH_MULTI_MSK) != 0) {
            info->multi = true;
            if ($rctl.mpe == 1) {
                log "info", 4:
                    "received a multicast frame (mpe = 1, da = 0x%x)", da;
                return;
            }

            // Check the Multicast Table Array
            if ($MTA_CNT == 128) {
                local uint8 byte6 = da[7:0];
                local uint8 byte5 = da[15:8];
                local uint7 dw_address;
                local uint5 bit_address;
                switch($rctl.mo) {
                case 0b00:
                    dw_address = byte6[7:1];
                    bit_address = (byte6[0] << 4) | byte5[3:0];
                    break;
                case 0b01:
                    dw_address = byte6[6:0];
                    bit_address = byte5[4:0];
                    break;
                case 0b10:
                    dw_address = (byte6[5:0] << 1) | byte5[5];
                    bit_address = byte5[4:0];
                    break;
                case 0b11:
                    dw_address = (byte6[3:0] << 3) | byte5[7:5];
                    bit_address = byte5[4:0];
                    break;
                default:
                    assert false;
                }
                passed = ($mta[dw_address] & (1 << bit_address)) != 0;
            } else if ($MTA_CNT == 32) {
                local uint8 byte6 = da[7:0];
                local uint8 byte5 = da[15:8];
                local uint5 dw_address;
                local uint5 bit_address;
                switch($rctl.mo) {
                case 0b00:
                    dw_address = byte6[7:3];
                    bit_address = (byte6[2:0] << 2) | byte5[1:0];
                    break;
                case 0b01:
                    dw_address = byte6[6:2];
                    bit_address = (byte6[1:0] << 3) | byte5[2:0];
                    break;
                case 0b10:
                    dw_address = byte6[5:1];
                    bit_address = (byte6[0] << 4) | byte5[3:0];
                    break;
                case 0b11:
                    dw_address = (byte6[3:0] << 1) | byte5[5];
                    bit_address = byte5[4:0];
                    break;
                default:
                    assert false;
                }
                passed = ($mta[dw_address] & (1 << bit_address)) != 0;
            } else {
                error "Add your code here to handle new MTA_CNT value";
            }
            log "info", 4: "%s a multicast frame (mpe = 0, da = 0x%x)",
                passed ? "accepted" : "rejected", da;
            return;
        }

        // unicast filtering
        if ($rctl.upe == 1) {
            log "info", 4: "accepted an Ethernet frame for unicast promiscuous mode is enabled";
            return;
        }

        log "info", 3: "received an unknown Ethernet frame from da 0x%x", da;
        passed = false;
    }

    method parse_ipv6_protocol(const uint8 *frame, uint16 length)
        -> (uint16 hlen, uint8 prot) default {
        local const ipv6_header_t *ipv6 = cast(frame, void*);

        hlen = sizeoftype(ipv6_header_t);
        prot = ipv6->next;

        while (prot == IPv6_NH_HOPBYHOP || prot == IPv6_NH_DEST_OPT ||
               prot == IPv6_NH_ROUTING) {
            local const ipv6_ext_header_t *eh = cast(&frame[hlen], void*);
            if ((hlen + eh->ext_hlen) >= length) {
                log "spec_violation", 1:
                    "the IPv6 frame doesn't contain a valid protocol field";
                 break;
            }

            prot = eh->next;
            if (eh->ext_hlen == 0) {
                log "spec_violation",1: "the IPv6 frame has zero hlen";
                break;
            }
            hlen += eh->ext_hlen;
        }
    }

    if($HAS_RSS) {
        method load_random_key(uint8 *key) default {
            local int i;

            for (i = 0; i < 40; i++)
                key[i] = $rssrk[i];
        }

        method calc_frame_rss_hash(const uint8 *ip,
                                   frame_info_t *info) default {
            if ($mrqc.rssfe != 0) {
                if (info->ipv4) {
                    if (info->l3_prot == ETH_PROT_TCP && $mrqc.rssfe[0] != 0)
                        info->rss_type = 1;
                    else if ($mrqc.rssfe[1] != 0)
                        info->rss_type = 2;
                } else if (info->ipv6) {
                    if (info->l3_prot == ETH_PROT_TCP && $mrqc.rssfe[2] != 0)
                        info->rss_type = 3;
                    else if ($mrqc.rssfe[3] != 0 && info->ipv6_ext)
                        info->rss_type = 4;
                    else if ($mrqc.rssfe[4] != 0)
                        info->rss_type = 5;
                }
            }

            if (info->rss_type != 0) {
                call $compute_ip_hash(ip, info->ipv6,
                                      info->rss_type == 1 || info->rss_type == 3) -> (info->hash);
                return;
            }

            info->hash = 0;
            info->rss_type = 0;
            $rx_queue_nbr = 0;
        }
    }

    method exact_address_filter(uint48 da) -> (bool passed) default {
        local int i;
        local bool m;
        passed = true;
        for (i = 0; i < $RA_CNT; i++) {
            inline $compare_mac_addr(da, $ra[i].mac) -> (m);
            if ($ra[i].high.av == 1 && m)
                return;
        }
        passed = false;
    }

    if($VLAN_PACKET_FILTER) {
        method vlan_packet_filter(ieee_802_1q_tag_t *vtag, frame_info_t *info)
            -> (bool passed) default {
            passed = true;

            if (vtag->TagVal != $vet)
                return; // not a 802.1q TAG

            if ($rctl.cfien == 1) {
                // Packet.CFI must match rctl.CFI
                passed = $rctl.cfi == vtag->vlan.cfi;
                log "info", 4: "%s Canonical Form Indicator",
                    passed ? "accepted" : "rejected";
                if (!passed)
                    return;
            }

            if ($rctl.vfe == 0)
                return;

            /* Check the VLAN Filter Table.
             * Same algorithm as used for multicast filtering.
             */
            local uint12 index = vtag->vlan.vid;
            passed = ($vfta[index/32] & (1 << (index % 32))) != 0;
            log "info", 4: "%s VLAN Filter Table", passed ? "accepted" : "rejected";
            return;
        }
    }
}

//length of key should be 40B
method compute_hash (
    const uint8 *data, int length, uint8 *key) -> (uint32 hash) default {

    local int i;
    hash = 0;

    for (i = 0; i < length; i++) {
        local uint8 byte = data[i];
        local int j;

        for (j = 7; j >= 0; j--) {
            if ((byte & (1 << j)) != 0)
                hash ^= UNALIGNED_LOAD_BE32(cast(key, void *));

            local int k;
            local uint1 bit0 = 0;
            local uint1 bit1 = 0;
            for (k = 39; k >= 0; k--) {
                bit1 = key[k][7:7];
                key[k] = (key[k] << 1) | bit0;
                bit0 = bit1;
            }
        }
    }
}

method compute_ip_hash(const uint8 *ip, bool v6, bool tcp) -> (uint32 hash) {
    local int start = v6 ? 8 : 12;
    local int length = (v6 ? 32 : 8) + (tcp ? 4 : 0);
    local uint8 key[40];

    inline $csr.load_random_key(key);
    inline $compute_hash(&ip[start], length, key) -> (hash);
}

template rx_mac_register {
    register low {
        method set(val) {
            $this = val;
            $mac[31:0] = $this;
        }
        method write(val) {
            inline $set(val);
        }
    }
    register high {
        field rah[15:0] "Receive Address High" {
            method set(val) {
                $this = val;
                $mac[47:32] = $this & 0xFFFF;
            }
            method write(val) {
                inline $set(val);
            }
        }
        field asel[17:16] "Address Select" {
            method write(val) {
                // no other asel values are currently supported
                $this = $RAH_ASEL_DESTINATION_ADDRESS;
                if (val != $RAH_ASEL_DESTINATION_ADDRESS)
                    log "unimplemented", 1, Register_Write:
                        "%s only supports Destination Address (0)", $qname;
            }
        }
        // reserved[30:18]
        field av[31] "Address Valid" {
        }
    }
    register mac size 8 "Receive MAC address" {
        is unmapped;
    }
}

template intr_delay_evt {
    parameter timebase = "seconds";
    parameter INTR;
    method event(void *data) {
        call $raise_interrupt($INTR);
    }

    method raise(double time) default {
        local bool is_posted;
        inline $posted(NULL) -> (is_posted);
        if (!is_posted)
            inline $post(time, NULL);
    }

    method reinit() default {
        local bool is_posted;
        inline $posted(NULL) -> (is_posted);
        if (is_posted)
            inline $remove(NULL);
    }
}

constant DESC_SIZE = 2*8;
constant SPLIT_DESC_SIZE = 4*8;

template rx_desc_queue {
    parameter BA    default undefined;
    parameter rdmts default undefined;
    parameter dtyp  default undefined;

    register rdbal @ $BA + 0x00 "Receive Descriptor Base Low";
    register rdbah @ $BA + 0x04 "Receive Descriptor Base High";
    register rdlen @ $BA + 0x08 "Receive Descriptor Length";
    register rdh   @ $BA + 0x10 "Receive Descriptor Header";
    register rdt   @ $BA + 0x18 "Receive Descriptor Tail";
    register rxdctl@ $BA + 0x28 "Receive Descriptor Control";

    register rdbal is (write_mask) { parameter mask = 0xFFFFFFF0; }
    register rdbah is (write_mask) { parameter mask = 0xFFFFFFFF; }
    register rdlen is (write_mask) { parameter mask = 0x000FFF80; }
    register rdh   is (write_mask) { parameter mask = 0x0000FFFF; }
    register rdt   is (write_mask) { parameter mask = 0x0000FFFF; }

    method load_descriptor(uint8 *desc,
                           int desc_size) -> (uint64 addr) default {
        addr = (($rdbah << 32) | $rdbal) + $rdh * 16;
        log "info", 4: "load %d-byte descriptor from addr: 0x%x",
            desc_size, addr;
        call $memory_read(&desc[0], addr, desc_size);
    }

    method increase_header(int desc_size) default {
        local uint16 n = $rdlen / DESC_SIZE;
        $rdh = ($rdh + desc_size / DESC_SIZE) % n;

        local int avail = ($rdt >= $rdh) ? ($rdt - $rdh) : (n + $rdt - $rdh);

        if (avail == (n >> ($rdmts + 1)))
            inline $raise_interrupt(INTR_RXDMT0);

        if ($rdh == $rdt)
            log "info", 2: "the receive descriptor ring is empty";
    }

    method save_packet_legacy(const uint8* frame, frame_info_t *info) {
        local uint16 buf_size;
        local uint16 index = 0;
        local uint8 desc[16];
        local uint64 daddr;

        inline $buffer_size() -> (buf_size);
        while (index < info->length) {
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local legacy_rx_desc_t *lrd = cast(desc, void*);
            call $load_descriptor(desc, DESC_SIZE) -> (daddr);
            log "info", 4: "write packet to memory: addr: 0x%x, step: %d", lrd->buf_addr, step;
            call $memory_write(lrd->buf_addr, &frame[index], step);
            index += step;

            if (info->vp) {
                lrd->desc.pri  = info->vlan[15:13];
                lrd->desc.cfi  = info->vlan[12:12];
                lrd->desc.vlan = info->vlan[11:0];
            }
            lrd->desc.rxe    = info->rx_err;
            lrd->desc.ipe    = info->ipe;
            lrd->desc.tcpe   = (info->tupe) ? 1 : 0;
            lrd->desc.ce     = (info->cal_crc == info->rxd_crc) ? 0 : 1;
            lrd->desc.pif    = info->pif;
            lrd->desc.ipcs   = $rxcsum.ipofld;
            lrd->desc.vp     = info->vp ? 1 : 0;
            lrd->desc.eop    = (index == info->length) ? 1 : 0;
            lrd->desc.dd     = 1;
            lrd->desc.fcs    = info->packet_cs;
            lrd->desc.length = step;

            if (lrd->desc.ipcs) {
                lrd->desc.tcpcs = 1;
                lrd->desc.udpcs = info->udp ? 1 : 0;
            } else if (info->ipv6 && (info->tcp || info->udp)) {
                /* Documentation states that IPv6 packets do not have the IPCS
                 * bit set, but might have the TCPCS bit set if a TCP or UDP
                 * packet was recognized.
                 */
                lrd->desc.tcpcs = 1;
            }

            call $memory_write(daddr, desc, DESC_SIZE);

            log "info", 3: "%s(%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d, %s=%04x) at 0x%x",
                "saving legacy descriptor", "rxe", lrd->desc.rxe,
                "ipe", lrd->desc.ipe, "tcpe", lrd->desc.tcpe,
                "ce", lrd->desc.ce, "eop", lrd->desc.eop,
                "length", lrd->desc.length,
                "tcpcs", lrd->desc.tcpcs,
                "udpcs", lrd->desc.udpcs,
                "fcs", lrd->desc.fcs,
                daddr;

            call $increase_header(DESC_SIZE);
        }
    }
}

template rx_desc_queue_alias {
    parameter BA default undefined;
    parameter reggroup default undefined;

    register rdbal  @ $BA + 0x00 is (register_alias) {
        parameter target = $reggroup[$i].rdbal;
    }
    register rdbah  @ $BA + 0x04 is (register_alias) {
        parameter target = $reggroup[$i].rdbah;
    }
    register rdlen  @ $BA + 0x08 is (register_alias) {
        parameter target = $reggroup[$i].rdlen;
    }
    register rdh    @ $BA + 0x10 is (register_alias) {
        parameter target = $reggroup[$i].rdh;
    }
    register rdt    @ $BA + 0x18 is (register_alias) {
        parameter target = $reggroup[$i].rdt;
    }
    register rxdctl @ $BA + 0x28 is (register_alias) {
        parameter target = $reggroup[$i].rxdctl;
    }
}

template ext_rx_desc_queue {
    parameter bsize  default undefined;
    parameter bsex   default undefined;
    parameter flxbuf default undefined;
    parameter psr_sz default undefined;

    register rdtr  @ $BA + 0x20 "Receive Interrupt Packet Delay Timer";

    register rdtr {
        field delay[15:0] is (read_write) "Receive Delay Timer";
        field fpd[31]     is (read_write) "Flush Partial Descriptor" {
            method write(value) {
                if (value == 1) {
                    local bool is_posted;
                    inline $rx_delay.posted(NULL) -> (is_posted);
                    if (is_posted)
                        inline $rx_delay.remove(NULL);
                    inline $raise_interrupt(INTR_RXT0);
                }
            }
        }
    }

    register rxdctl {
        field pthresh[5:0] is (unimplemented) "Prefetch Threshold";
        field hthresh[13:8] is (unimplemented) "Host Threshold";
        field wthresh[21:16] is (unimplemented) "Write-back Threshold";
        field gran[24] is (unimplemented) "Granularity";
    }

    method buffer_size() -> (uint16 len) default {
        len = ($flxbuf != 0
               ? 1024 * $flxbuf : (2048 >> $bsize) * ($bsex == 1 ? 16 : 1));
    }

    method check_descriptor(uint16 length) -> (bool empty) default {
        empty = false;

        if ($rdh == $rdt) {
            log "info", 4: "check RX descriptor: empty based on rdh (%d) and rdt (%d)", $rdh, $rdt;
            empty = true;
            return;
        }

        /* We can only span over non-split descriptors */
        if ($dtyp == 0b00 || $rfctl.exsten == 0) {
            local uint16 buf_size;
            local uint16 desc_cnt = ($rdt > $rdh ? ($rdt - $rdh)
                                     : ($rdlen / 16 + $rdt - $rdh));
            inline $buffer_size() -> (buf_size);
            empty = (desc_cnt * buf_size) < length;
            log "info", 4: "check Rx descriptor: %s based on rdh (%d) and rdt(%d)", empty ? "empty" : "non-empty", $rdh, $rdt;
        }
    }

    method queue_store_packet(const uint8* frame, frame_info_t *info) default {
        if ($dtyp == 0b00 && $rfctl.exsten == 0) {
            inline $save_packet_legacy(frame, info);
        } else if ($dtyp == 0b00 && $rfctl.exsten == 1) {
            inline $save_packet_extended(frame, info);
        } else if ($dtyp == 1 && $rfctl.exsten == 1) {
            inline $save_packet_split(frame, info);
        } else {
            log "spec_violation", 1:
                "invalid configuration: dtyp=%d, exsten=%d, %s",
                $dtyp, $rfctl.exsten, "discards incoming frame";
            throw;
        }
    }

    method rx_interrupt() default {
        // re-initialise and start the RX delay timer
        inline $rx_delay.reinit();

        // MTDq (Direct mapped virtualization) has one RDTR per queue
        if($HAS_MTDq1)
            inline $rx_delay.raise($rdtr.delay * 1.024e-6);
        else
            inline $rx_delay.raise($csr.rx_queue[0].rdtr.delay * 1.024e-6);
    }

    method save_packet_extended(const uint8 *frame,
                                frame_info_t *info) default {
        local uint16 buf_size;
        local uint8  desc[16];
        local uint64 daddr;
        local uint16 index = 0;

        inline $buffer_size() -> (buf_size);
        while (index < info->length) {
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local ext_rd_rx_desc_t *rrd = cast(desc, void*);
            local ext_wb_rx_desc_t *wrd = cast(desc, void*);

            call $load_descriptor(desc, DESC_SIZE) -> (daddr);
            call $memory_write(rrd->buf_addr, &frame[index], step);
            index += step;
            memset(wrd, 0, 16);

            if($HAS_RSS) {
                wrd->desc0.rss_info = $rxcsum.pcsd ?
                    info->hash : (info->packet_cs << 16) | info->ip_id;
                wrd->desc0.queue    = $i;
                wrd->desc0.rss_type = info->rss_type;
            }

            if (info->vp) {
                wrd->desc1.pri  = info->vlan[15:13];
                wrd->desc1.cfi  = info->vlan[12:12];
                wrd->desc1.vlan = info->vlan[11:0];
                wrd->desc1.vp   = 1;
            }
            wrd->desc1.length   = info->length;
            wrd->desc1.rxe      = info->rx_err;
            wrd->desc1.tcpe     = info->tupe ? 1 : 0;
            wrd->desc1.ipe      = info->ipe ? 1 : 0;
            wrd->desc1.ce       = (info->cal_crc == info->rxd_crc) ? 0: 1;
            //      if (info->ipv4)
            //          wrd->desc1.pkttype  = (info->tcp || info->udp) ?
            //              $PKTTYPE_MAC_IPV4_TCP_UDP : $PKTTYPE_MAC_IPV4_PAYLOAD;
            //      else if (info->ipv6)
            //          wrd->desc1.pkttype  = (info->tcp || info->udp) ?
            //              $PKTTYPE_MAC_IPV6_TCP_UDP : $PKTTYPE_MAC_IPV6_PAYLOAD;
            //      else
            //          wrd->desc1.pkttype = 0;
            wrd->desc1.ack      = info->ack ? 1 : 0;
            wrd->desc1.udpv     = 0;
            wrd->desc1.ipidv    = info->ipv4 ? 1 - $rxcsum.pcsd : 0;
            wrd->desc1.tst      = info->tst;
            wrd->desc1.pif      = info->pif;
            wrd->desc1.ipcs     = info->ipv4 ? $rxcsum.ipofld :0;
            wrd->desc1.eop      = index == info->length ? 1 : 0;
            wrd->desc1.dd       = info->length == index ? 1 : 0;

            if (wrd->desc1.ipcs) {
                wrd->desc1.tcpcs = 1;
                wrd->desc1.udpcs = info->udp ? 1 : 0;
            } else if (info->ipv6 && (info->tcp || info->udp)) {
                /* Documentation states that IPv6 packets do not have the IPCS
                 * bit set, but might have the TCPCS bit set if a TCP or UDP
                 * packet was recognized.
                 */
                wrd->desc1.tcpcs = 1;
            }

            log "info", 3:
                "%s(%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d) at 0x%x",
                "saving extended descriptor", "vp", wrd->desc1.vp,
                "rxe", wrd->desc1.rxe, "tcpe", wrd->desc1.tcpe,
                "ipe", wrd->desc1.ipe, "ce", wrd->desc1.ce,
                "ack", wrd->desc1.ack, "length", wrd->desc1.length,
                "eop", wrd->desc1.eop, daddr;

            call $memory_write(daddr, &desc[0], DESC_SIZE);
            call $increase_header(DESC_SIZE);
        }
    }

    method save_packet_split(const uint8* frame, frame_info_t *info) {
        local uint8  desc[32];
        local uint64 daddr;
        call $load_descriptor(desc, SPLIT_DESC_SIZE) -> (daddr);

        local split_rd_rx_desc_t *srd = cast(desc, void*);
        local int i;
        local uint64 paddr[4];
        local uint16 length[4];
        for (i = 0; i < 4; i++)
            paddr[i] = srd->buf_addr[i];

        local uint16 index = 0;
        local split_wb_rx_desc_t *swd = cast(desc, void*);
        memset(desc, 0, 32);
        memset(length, 0, 4 * sizeoftype(uint16));

        for (i = 0; i < 4 && info->length > index; i++) {
            local uint16 remainder = info->length - index;
            inline $split_buffer_size(i) -> (length[i]);
            if (length[i] > remainder)
                length[i] = remainder;

            call $memory_write(paddr[i], &frame[index], length[i]);
            index += length[i];
        }

        if (index < info->length)
            log "spec_violation", 1:
                "%d bytes of ingoing frame dropped for lack of memory space",
                info->length - index;

        //write-back descriptor
        if($HAS_RSS) {
            swd->desc0.rss_info = $rxcsum.pcsd ?
                info->hash : (info->packet_cs << 16) | info->ip_id;
            swd->desc0.queue    = $i;
            swd->desc0.rss_type = info->rss_type;
        }

        if (info->vp) {
            swd->desc1.pri  = info->vlan[15:13];
            swd->desc1.cfi  = info->vlan[12:12];
            swd->desc1.vlan = info->vlan[11:0];
            swd->desc1.vp   = 1;
        }
        swd->desc1.length   = length[0];
        swd->desc1.dd       = 1;

        swd->desc2.length1  = length[1];
        swd->desc2.length2  = length[2];
        swd->desc2.length3  = length[3];
        swd->desc2.hdrsp    = 0;
        swd->desc2.hlen     = 0;

        if($HAS_RSS) {
            log "info", 3:
                "%s(%s=0x%x,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d) at 0x%x",
                "saving split descriptor",
                "rss_info", swd->desc0.rss_info,
                "rss_type", swd->desc0.rss_type,
                "queue", swd->desc0.queue,
                "vp", swd->desc1.vp,
                "length[0]", swd->desc1.length,
                "length[1]", swd->desc2.length1,
                "length[2]", swd->desc2.length2,
                "length[3]", swd->desc2.length3, daddr;
        } else {
            log "info", 3:
                "%s(%s=%d,%s=%d,%s=%d,%s=%d,%s=%d) at 0x%x",
                "saving split descriptor",
                "vp", swd->desc1.vp,
                "length[0]", swd->desc1.length,
                "length[1]", swd->desc2.length1,
                "length[2]", swd->desc2.length2,
                "length[3]", swd->desc2.length3, daddr;
        }
        call $memory_write(daddr, desc, SPLIT_DESC_SIZE);
        call $increase_header(SPLIT_DESC_SIZE);
    }

    method split_buffer_size(uint2 pn) -> (uint16 len) default {
        len = (($psr_sz >> (pn * 8)) & 0x7F) * (pn == 0 ? 128 : 1024);
    }
}

template adv_rx_desc_queue {
    parameter bsize  default undefined;
    parameter bsize_pkt  default undefined;
    parameter bsize_header  default undefined;

    register srrctl @ $BA + 0x0c "Split and Replication Rx Control";

    register rxdctl {
        field pthresh[4:0]   is (read_write) "Prefetch Threshold";
        // reserved[7:5]
        field hthresh[12:8]  is (read_write) "Host Threshold";
        // reserved[15:13]
        field wthresh[20:16] is (read_write) "write-back Threshold";
        // reserved[24:21]
        field en[25]       is (read_write) "Enabled";
        field swflush[26]  is (read_write) "Receive Software Flush" {
            method write(value) {
                if (value == 1) {
                    inline $rx_delay.raise($eitr[$ivar[0].alloc].interval * 1e-6);
                }
            }
        }
        // reserved[31:27]
    }

    register srrctl {
        field bszpkt[6:0]   is (read_write) "RX Buffer size";
        field bszhdr[11:8]  is (read_write) "RX Buffer size for header buffer";
        field rdmts[24:20] is (read_write) "RX desc min threshold size";
        field desctype[27:25] is (read_write) "rx descriptor type";
        field drop_en[31]  is (read_write) "Drop_En";
    }

    method check_descriptor(uint16 length) -> (bool empty) {
        empty = false;
        if ($rdh == $rdt) {
            log "info", 4: "check RX descriptor: empty based on rdh (%d) and rdt (%d)", $rdh, $rdt;
            empty = true;
            return;
        }

        if ($dtyp <= 5) {
            local uint16 buf_size;
            local uint16 header_size;
            local uint16 desc_cnt = ($rdt > $rdh ? ($rdt - $rdh)
                                     : ($rdlen / 16 + $rdt - $rdh));
            inline $buffer_size() -> (buf_size);
            inline $header_size() -> (header_size);
            /* Header size is only included in the first descriptor */
            empty = (header_size + desc_cnt * buf_size) < length;
            log "info", 4: "check RX descriptor: %s based on rdh (%d) and rdt (%d)", empty ? "empty" : "non-empty", $rdh, $rdt;
        }
    }

    method queue_store_packet(const uint8* frame, frame_info_t *info) {
        if ($dtyp == 0b000) {
            inline $save_packet_legacy(frame, info);
        } else if ($dtyp == 1) {
            inline $save_packet_one_buffer(frame, info);
        } else if ($dtyp == 5) {
            inline $save_packet_split_always_use_header(frame, info);
        } else {
            log "spec_violation", 1: "invalid configuration: dtyp=%d, %s",
                $dtyp, "discards incoming frame";
            throw;
        }
    }

    method rx_interrupt() default {
        if ($eitr[$ivar[0].alloc].cntwdis == 1)
            inline $rx_delay.raise($eitr[$ivar[0].alloc].interval * 1e-6);
        else
            inline $rx_delay.raise($eitr[$ivar[0].alloc].counter * 1e-6);
    }

    method get_split_type(const uint8 *frame,
                          frame_info_t *info) -> (uint16 type, uint16 split) {
        split = 0;
        type = 0;

        /* TODO: We're not handling NFS in L4/L5*/

        if(info->ipv4) {
            if(info->fragmented) {
                if($ptype[1]) {
                    /* Type 1: L3 split if fragmented IPv4 */
                    type = 1;
                    split = info->l3_index;
                }
            } else {
                if(info->tcp && $ptype[2]) {
                    /* Type 2: L4 split if IPv4, TCP */
                    type = 2;
                    split = info->l4_index;
                }

                if(info->udp && $ptype[3]) {
                    /* Type 3: L4 split if IPv4, UDP */
                    type = 3;
                    split = info->l4_index;
                }
            }
        }

        if(info->ipv4_ipv6) {
            if(info->fragmented || info->ipv4_ipv6_fragmented) {
                if($ptype[4]) {
                    /* Type 4: L3 split if fragmented IPv4 or IPv6 */
                    type = 4;
                    split = info->l3_index;
                }
            } else {
                if(info->tcp && $ptype[5]) {
                    /* Type 5: L4 split if IPv4, IPv6, TCP */
                    type = 5;
                    split = info->l4_index;
                }

                if(info->udp && $ptype[6]) {
                    /* Type 6: L4 split if IPv4, IPv6, UDP */
                    type = 6;
                    split = info->l4_index;
                }
            }
        }

        if(info->ipv6) {
            if(info->fragmented) {
                if($ptype[7]) {
                    /* Type 7: L3 split if fragmented IPv6 */
                    type = 7;
                    split = info->l3_index;
                }
            } else {
                if(info->tcp && $ptype[8]) {
                    /* Type 8: L4 split if IPv6, TCP */
                    type = 8;
                    split = info->l4_index;
                }

                if(info->udp && $ptype[9]) {
                    /* Type 9: L4 split if IPv6, UDP */
                    type = 9;
                    split = info->l4_index;
                }
            }
        }

        log "info", 4: "ptype: %08x", $ptype;
        log "info", 4: "ipv4: %d, udp: %d, tcp: %d, frag: %d",
            info->ipv4?1:0, info->udp?1:0, info->tcp?1:0, info->fragmented?1:0;
        log "info", 4: "packet split at %d (type %d)", split, type;
    }

    /* 0 - Legacy
       1 - Advanced, one buffer
       2 - Advanced, header splitting
       3 - Advanced, always header replication
       4 - Advanced, large packet only header replication
       5 - advanced, header splitting, always use header buffer
    */
    method save_packet_one_buffer(const uint8 *frame,
                                  frame_info_t *info) {
        local uint16 buf_size;
        local uint8  desc[16];
        local uint64 daddr;
        local uint16 index = 0;
        local uint16 type;
        local uint16 split;

        inline $buffer_size() -> (buf_size);
        while (index < info->length) {
            local uint64 w_addr;
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local adv_rd_rx_desc_t *rrd = cast(desc, void*);
            local adv_wb_rx_desc_t *wrd = cast(desc, void*);

            call $load_descriptor(desc, DESC_SIZE) -> (daddr);

            local uint64 buf_addr = rrd->buf_addr;

            local uint16 buf_len = 0;

            memset(wrd, 0, 16);

            buf_len = step;

            if(buf_len > 0) {
                log "info", 4: "copying %d bytes to main buffer (%llx)",
                    buf_len, buf_addr;
                call $memory_write(buf_addr, &frame[index], buf_len);
                index += buf_len;
            }

            wrd->desc1.length = buf_len;

            wrd->desc0.rss_info = info->hash;
            wrd->desc0.rss_type = info->rss_type;
            wrd->desc0.l2p = 0;
            wrd->desc0.sph = 0; // always no split

            if(info->ipv4)
                wrd->desc0.packet_type[0] = 1;
            if(info->ipv6)
                wrd->desc0.packet_type[2] = 1;
            if(info->tcp)
                wrd->desc0.packet_type[4] = 1;
            if(info->udp)
                wrd->desc0.packet_type[5] = 1;

            if (info->vp) {
                wrd->desc1.pri  = info->vlan[15:13];
                wrd->desc1.cfi  = info->vlan[12:12];
                wrd->desc1.vlan = info->vlan[11:0];
                wrd->desc1.vp   = 1;
            }
            wrd->desc1.rxe      = 0;
            wrd->desc1.l4e      = 0;
            wrd->desc1.ipe      = 0;
            wrd->desc1.ce       = 0;
            wrd->desc1.udpv     = 0;
            wrd->desc1.vext     = 0;
            wrd->desc1.pif      = info->pif;
            wrd->desc1.ipcs     = 0;
            wrd->desc1.l4i      = 0;
            wrd->desc1.udpcs    = 0;
            wrd->desc1.vp       = info->vp ? 1 : 0;
            wrd->desc1.eop      = (index == info->length) ? 1 : 0;
            wrd->desc1.dd       = 1;

            call $memory_write(daddr, &desc[0], DESC_SIZE);
            call $increase_header(DESC_SIZE);
        }
    }

    method save_packet_split_always_use_header(const uint8 *frame,
                                               frame_info_t *info) {
        local uint16 buf_size;
        local uint16 header_size;
        local uint8  desc[16];
        local uint64 daddr;
        local uint16 index = 0;
        local uint16 type;
        local uint16 split;

        inline $get_split_type(frame, info) -> (type, split);

        inline $buffer_size() -> (buf_size);
        inline $header_size() -> (header_size);

        while (index < info->length) {
            local uint64 w_addr;
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local adv_rd_rx_desc_t *rrd = cast(desc, void*);
            local adv_wb_rx_desc_t *wrd = cast(desc, void*);

            call $load_descriptor(desc, DESC_SIZE) -> (daddr);

            local uint64 head_addr = rrd->head_addr;
            local uint64 buf_addr = rrd->buf_addr;

            local uint16 head_len = 0;
            local uint16 buf_len = 0;
            local uint1 sph = 0;

            memset(wrd, 0, 16);

            /* Only use header buffer in the first descriptor */
            if(index == 0) {
                if(type == 0) {
                    log "info", 4:
                        "no split, storing part of frame in header buffer";
                    head_len = (step > header_size) ? header_size : step;
                } else {
                    head_len = split;
                    sph = 1;
                }
            }

            buf_len = (step > head_len) ? step - head_len : 0;

            if(head_len > 0) {
                log "info", 4: "copying %d bytes to header buffer (%llx)",
                    head_len, head_addr;
                call $memory_write(head_addr, &frame[index], head_len);
                index += head_len;
            }

            if(buf_len > 0) {
                log "info", 4: "copying %d bytes to main buffer (%llx)",
                    buf_len, buf_addr;
                call $memory_write(buf_addr, &frame[index], buf_len);
                index += buf_len;
            }

            wrd->desc0.hdr_len = head_len;
            wrd->desc1.length = buf_len;

            wrd->desc0.rss_info = info->hash;
            wrd->desc0.rss_type = info->rss_type;
            wrd->desc0.l2p = 0;
            wrd->desc0.sph = sph;

            if(info->ipv4)
                wrd->desc0.packet_type[0] = 1;
            if(info->ipv6)
                wrd->desc0.packet_type[2] = 1;
            if(info->tcp)
                wrd->desc0.packet_type[4] = 1;
            if(info->udp)
                wrd->desc0.packet_type[5] = 1;

            if (info->vp) {
                wrd->desc1.pri  = info->vlan[15:13];
                wrd->desc1.cfi  = info->vlan[12:12];
                wrd->desc1.vlan = info->vlan[11:0];
                wrd->desc1.vp   = 1;
            }
            wrd->desc1.rxe      = 0;
            wrd->desc1.l4e      = 0;
            wrd->desc1.ipe      = 0;
            wrd->desc1.ce       = 0;
            wrd->desc1.udpv     = 0;
            wrd->desc1.vext     = 0;
            wrd->desc1.pif      = info->pif;
            wrd->desc1.ipcs     = 0;
            wrd->desc1.l4i      = 0;
            wrd->desc1.udpcs    = 0;
            wrd->desc1.vp       = info->vp ? 1 : 0;
            wrd->desc1.eop      = (index == info->length) ? 1 : 0;
            wrd->desc1.dd       = 1;

            call $memory_write(daddr, &desc[0], DESC_SIZE);
            call $increase_header(DESC_SIZE);
        }
    }

    method buffer_size() -> (uint16 buf_len) {
        if($bsize_pkt > 0) {
            buf_len = $bsize_pkt * 1024;
        } else {
            buf_len = 256 << (3 - $bsize);
        }
    }

    method header_size() -> (uint16 header_len) {
        if($dtyp <= 1) {
            header_len = 0;
        } else {
            header_len = $bsize_header * 64;
        }
    }
}

template adv_rx_desc_queue_alias {
    parameter BA default undefined;
    parameter reggroup default undefined;
    register srrctl @ $BA + 0x0c is (register_alias) {
        parameter target = $reggroup[$i].srrctl;
    }
}
