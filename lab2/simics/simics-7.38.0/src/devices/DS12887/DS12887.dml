/*
  DS12887.dml

  Â© 2010 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This DS12887 model is designed to avoid posting events unnecessarily. This
// affects how interrupt events are posted and how the registers of the
// real-time clock are updated.
//
// Interrupt events do of course not need to be (and must not be) posted when
// the cause of the interrupt is disabled. For example, the update-ended
// interrupt can only occur if the oscillator is on and the SET flag is not
// set, so we should only post events for it when these conditions are
// satisfied. But we can also avoid posting interrupts when the interrupt flag
// of the interrupt is already set, since the only effect of the interrupt is
// to set the flag. This also means that when an interrupt flag is changed, we
// may need to post or remove the corresponding interrupt event.
//
// When the real-time clock is running (the oscillator is enabled and the SET
// bit is not set) the time registers are updated lazily, that is, they are
// only updated when they are read. This way we don't need to post events to
// update the time registers every second. When the clock is stopped (the
// oscillator is disabled or the SET bit is set) the time registers always
// contain their actual value. This means that whenever the real-time clock is
// stopped we need to update the time registers.
//
// Together, these measures mean that when running in a booted PC configuration
// with Linux, and the periodic, update-ended and alarm interrupts have been
// triggered once, the DS12887 model will not post any events at all.

dml 1.4;

device DS12887;

param documentation = "This is a simulation model for the DS12887" +
    " real-time clock.";
param desc = "model of DS12887 real-time clock";

param limitations = ("The day of the week value written to the real-time "
                         + "clock by software is ignored. The real-time "
                         + "clock always returns the day of the week value "
                         + "that corresponds to the date according to the "
                         + "real calendar, assuming the year is in the range "
                         + "1930 - 2029.\n\n"

                         + "The year value written to the real-time clock by "
                         + "software will be interpreted as being in the "
                         + "range 1930 - 2029. The DS12887 obviously does "
                         + "not care about century.\n\n"

                         + "Daylight saving time is not implemented.\n\n"

                         + "Square wave output is not implemented.\n\n"

                         + "The time conversion functions (os_gmtime() and "
                         + "os_timegm()) used by in this model implement "
                         + "leap seconds, while the real DS12887 does not. "
                         + "This may cause the real-time clock to return "
                         + "second 60 or 61 and alarm interrupts to occur "
                         + "one or two second off when leap seconds occur.");

import "utility.dml";
import "simics/model-iface/temporal-state.dml";
import "simics/util/os-time.dml";

// We need some functions from the standard C header files.

header %{
#include <stdio.h>
#include <math.h>
%}

extern int snprintf(char *str, size_t size, const char *format, ...);
extern int sscanf(const char *str, const char *format, ...);
extern double floor(double x);

// We use the simple-interrupt interface.

import "simics/devs/interrupt.dml";

param RAM_SIZE = 114;

// The irq_dev and irq_level attributes tell us to what device and at what
// level to send interrupts.

//:: pre ds12887_interrupt_dev {{
connect irq_dev {
    param documentation = "The device that interrupts are sent to,"
        + " or Nil if the interrupt line is not connected to anything.";
    param configuration = "optional";

    interface simple_interrupt;
}
// }}

attribute irq_level is int64_attr {
    param documentation = "The level at which interrupts are sent.";
    param configuration = "required";
}

// The attributes base_time and base_rtc_time keep the time of real-time
// clock. The base_time attribute contains a simulated time in seconds since
// the start of the simulation. The base_rtc_time contains a real-time clock
// time, in seconds since 1970-01-01 00:00:00.
//
// The time is represented differently depending on if the oscillator is
// enabled (the clock is running) or disabled (the clock is stopped).
//
// When the oscillator is disabled base_rtc_time contains an absolute time. The
// base_time attribute is ignored. Getting and setting the current real-time
// clock time can be done simply by reading or writing base_rtc_time.
//
// When the oscillator is enabled base_time contains the simulated time at
// which the oscillator was enabled, and base_rtc_time contains time of the
// real-time clock when the oscillator was enabled.
//
// From these values we can calculate the current real-time clock time by
// adding the difference between the current simulated time and base_time to
// base_rtc_time, adding 0.5 seconds (because the first update starts 0.5
// seconds after the oscillator is enabled), subtracting 244 microseconds
// (because updates and take 244 microseconds), and rounding down.
//
// When a new time is written to the real-time clock we calculate the new
// corresponding base_rtc_time. We can't change base_time since the timing of
// real-time clock updates and periodic interrupts is dependent on the time at
// which the oscillator was enabled, not the time at which the real-time clock
// was last set.

attribute base_time is double_attr {
    param documentation =
        "The simulated time when the oscillator was enabled, "+
        "in seconds since the start of the simulation.";

    // All interrupt events need to be updated if base_time is updated.
    method set(attr_value_t value) throws {
        default(value);
        periodic_interrupt.update_time();
        alarm_interrupt.update_time();
        update_ended_interrupt.update_time();
    }
}

attribute base_rtc_time is int64_attr {
    param documentation =
        "The real-time clock time when the oscillator was enabled, "+
        "in seconds since 1970-01-01 00:00:00.";

    // The alarm interrupt event needs to be updated if base_rtc_time is
    // updated.
    method set(attr_value_t value) throws {
        default(value);
        alarm_interrupt.update_time();
    }
}

//  These functions get and set the real-time clock time, as described above.

method get_rtc_time() -> (int64) {
    local int64 rtc_time;
    local double current_time = SIM_time(dev.obj);

    if (registers.a.DV.val == 0b010)
        rtc_time = base_rtc_time.val
            + floor(current_time - base_time.val + 0.5 - 244.0e-6);
    else
        rtc_time = base_rtc_time.val;
    return rtc_time;
}

method set_rtc_time(int64 rtc_time) {
    local double current_time = SIM_time(dev.obj);
    local char rtc_time_str[32];

    if (registers.a.DV.val == 0b010)
        base_rtc_time.val = rtc_time
            - floor(current_time - base_time.val + 0.5 - 244.0e-6);
    else
        base_rtc_time.val = rtc_time;

    get_rtc_time_str(rtc_time_str, 32);
    log info, 2: "time set to %s", rtc_time_str;
}

// Writes the current real-time clock time to the string rtc_time_str on the
// format "YY-MM-DD hh:mm:ss". The string must have space for str_size characters.

method get_rtc_time_str(char *rtc_time_str, int str_size) {
    local int64 rtc_time;
    local os_tm_t rtc_time_parts;

    // Get the real-time clock time.
    rtc_time = get_rtc_time();

    // Split the time parts.
    rtc_time_parts = gmtime64(rtc_time);

    // We count months from 1, os_tm_t counts from 0.
    rtc_time_parts.tm_mon += 1;

    // We ignore the century.
    rtc_time_parts.tm_year %= 100;

    // Convert the parts to a string.
    snprintf(rtc_time_str, str_size, "%02d-%02d-%02d %02d:%02d:%02d",
             rtc_time_parts.tm_year,
             rtc_time_parts.tm_mon,
             rtc_time_parts.tm_mday,
             rtc_time_parts.tm_hour,
             rtc_time_parts.tm_min,
             rtc_time_parts.tm_sec);
}

// Converts a real-time-clock time to the corresponding simulated time.

method rtc_time_to_time(int64 rtc_time) -> (double) {
    // There is no meaningful way to convert a real-time clock time to a
    // simulated time if the oscillator is disabled, so this method shouldn't
    // be called in that case.
    assert registers.a.DV.val == 0b010;

    return base_time.val + rtc_time - base_rtc_time.val - 0.5 + 244.0e-6;
}

// 64-bit wrapper around os_gmtime(). Performs a sanity check when/if casting
// from larger (int64) to smaller (int32) type. Use this method instead of
// os_gmtime(). Will assert if time can not be safely converted.

method gmtime64(int64 time64) -> (os_tm_t) {
    local os_time_t os_time;

    // Check for year 2038 wraparound using gmtime on 32-bit host
    if (sizeoftype(os_time_t) < sizeoftype(int64)) {
        assert time64 <= 0x7fffffff;
    }

    os_time = cast(time64, os_time_t);
    return os_gmtime(&os_time);
}

// 64-bit wrapper around os_timegm(). Provided for symmetrical reasons, use in
// combination with gmtime64().

method timegm64(os_tm_t os_time_parts) -> (int64) {
    local os_time_t os_time;
    os_time = os_timegm(&os_time_parts);
    return cast(os_time, int64); // safe to cast to larger type
}

// Calculates the amount of simulated time until the next occurrence of a
// real-time clock update or periodic interrupt.

method next_occurrence_delta(double frequency, double bias)
    -> (double) {
    local double current_time = SIM_time(dev.obj);
    local double occurrence_time;
    local uint64 half_cycles;

    // Make sure half_cycles is valid.
    assert 1 + ((current_time - base_time.val - bias)
                * (frequency * 2.0)) >= 0;

    // Complete half-cycles since the oscillator was enabled + 1 half-cycle.
    half_cycles = floor(1 + ((current_time - base_time.val - bias)
                             * (frequency * 2.0)));

    // The next odd half-cycle.
    if (half_cycles % 2 == 0)
        half_cycles +=1;

    // Simulated time of the next odd half-cycle.
    occurrence_time = base_time.val + half_cycles / (frequency * 2.0) + bias;

    // The amount of simulated time until the next occurrence.
    return occurrence_time - current_time;
}

// The number of days of the months.

session int mdays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

// The time attribute is used to get and set the real-time clock time using a
// string in human-readable format.

attribute time {
    param documentation =
        "The internal time of the real-time clock on the "+
        "format \"YY-MM-DD hh:mm:ss\".";
    param configuration = "pseudo";
    param type = "s";

    // Return the real-time clock time as a human-readable string.
    method get() -> (attr_value_t) {
        session char rtc_time_str[32];

        get_rtc_time_str(rtc_time_str, 32);

        return SIM_make_attr_string(rtc_time_str);
    }

    // Set the real-time clock from a human-readable string.
    method set(attr_value_t value) throws {
	local int64 rtc_time;
        local os_tm_t rtc_time_parts;
        local int parts_found;

        // Parse the string into parts.
        parts_found = sscanf(SIM_attr_string(value), "%u-%u-%u %u:%u:%u",
                             &rtc_time_parts.tm_year,
                             &rtc_time_parts.tm_mon,
                             &rtc_time_parts.tm_mday,
                             &rtc_time_parts.tm_hour,
                             &rtc_time_parts.tm_min,
                             &rtc_time_parts.tm_sec);

        // Check that the date format and time are ok.
        if (parts_found != 6 ||
            rtc_time_parts.tm_year < 0 || rtc_time_parts.tm_year > 99 ||
            rtc_time_parts.tm_mon  < 1 || rtc_time_parts.tm_mon  > 12 ||
            rtc_time_parts.tm_hour < 0 || rtc_time_parts.tm_hour > 23 ||
            rtc_time_parts.tm_min  < 0 || rtc_time_parts.tm_min  > 59 ||
            rtc_time_parts.tm_sec  < 0 || rtc_time_parts.tm_sec  > 59) {
            log error: "illegal date";
            throw;
        }
        if (rtc_time_parts.tm_mday < 1 ||
            rtc_time_parts.tm_mday > (mdays[rtc_time_parts.tm_mon - 1] +
                                      ((rtc_time_parts.tm_mon == 2 &&
                                        rtc_time_parts.tm_year % 4 == 0)
                                       ? 1 : 0))) {
            log error: "illegal date";
            throw;
        }

        // We count months from 1, os_tm_t counts months from 0.
        rtc_time_parts.tm_mon -= 1;

        // Count years less than 30 as 20xx, years greater or equal to
        // 30 as 19xx.
        if (rtc_time_parts.tm_year < 30)
            rtc_time_parts.tm_year += 100;

        // Join the time parts.
        rtc_time = timegm64(rtc_time_parts);

        // Set the real-time clock time.
        set_rtc_time(rtc_time);

        // Update the time registers.
        update_time_registers_unconditional();

        // Update the alarm interrupt event.
        alarm_interrupt.update_time();
    }
}

implement temporal_state {
    method save() -> (void *) {
        // do nothing
        return NULL;
    }
    method merge(void *prev, void *killed) {
        // do nothing
    }
    method prepare_restore() {
        // do nothing
    }
    method finish_restore(void *state) {
        log info, 3: "temporal_state: finish restore";
        periodic_interrupt.update_time();
        alarm_interrupt.update_time();
        update_ended_interrupt.update_time();
    }
}

// Layouts of the register banks. The actual register implementations can be
// found near end of this file.

// The DS12887 has 128 directly addressable registers, represented by the
// "registers" bank. When used in a PC the DS12887 is accessed indirectly
// through two register mapped into port space, represented by the
// "port_registers" bank.

bank port_registers {
    param register_size = 1;
    is function_mapped_bank;
    param function = 0;

    register address @ 0;
    register data    @ 1;
}

bank registers {
    param register_size = 1;
    is function_mapped_bank;
    param function = 1;

    register seconds           @ 0;
    register seconds_alarm     @ 1;
    register minutes           @ 2;
    register minutes_alarm     @ 3;
    register hours             @ 4;
    register hours_alarm       @ 5;
    register day_of_the_week   @ 6;
    register date_of_the_month @ 7;
    register month             @ 8;
    register year              @ 9;
    register a                 @ 10;
    register b                 @ 11;
    register c                 @ 12;
    register d                 @ 13;
    register nvram[i < 114]        @ 14 + i;
}

bank partially_persistent_registers {
    param register_size = 1;

    register b is unmapped {
        param documentation = "Persistent backing for registers.b";
        param persistent = true;

        in each field { is (read, write); }

        field DSE @ [0];
        field TWENTYFOUR_TWELVE @ [1];
        field DM @ [2];
        field SQWE @ [3];
        field SET @ [7];
    }
}

// The DS12887 has three different interrupts that we need to post events
// for. This template contains common logic for posting and removing these
// events.
//
// It assumes that each interrupt event type will implement the methods
// should_be_posted() and post(). should_be_posted() should return whether the
// event should be posted or not and post() should actually post the interrupt
// event at the correct time.

template interrupt_event is simple_time_event {
    method should_be_posted() -> (bool) default {
        error "should_be_posted() must be implemented by interrupt events";
    }
    method post_interrupt() default {
        error "post_interrupt() must be implemented by interrupt events";
    }

    // This method should not be called directly. It posts or removes the
    // interrupt event depending on if it should be posted and if it is
    // already posted.
    //
    // If force_repost is true the event is removed and re-posted even if
    // it both is and should be posted. This is needed if the time at which
    // the interrupt will occur has changed.
    method update_internal(bool force_repost) {
        local bool posted;
        local bool should_be_posted;

        // Don't post or remove events until the device is properly
        // configured.
        if (!SIM_object_is_configured(dev.obj))
            return;

        posted = this.posted();
        should_be_posted = this.should_be_posted();

        if (posted && (!should_be_posted || force_repost))
            remove();
        if ((!posted || force_repost) && should_be_posted)
            post_interrupt();
    }

    // Call this method if the interrupt event may need to be posted or
    // removed, and the time at which it would occur has not been changed.
    method update() {
        update_internal(false);
    }

    // Call this method if the interrupt event may need to be posted or
    // removed and/or the time at which the event would occur may have
    // changed.
    method update_time() {
        update_internal(true);
    }
}

// Table of periodic interrupt frequencies, indexed by the RS bits of register
// A.

session double pi_freqs[16] = {
      0.0,   256.0, 128.0, 8192.0, 4096.0, 2048.0, 1024.0, 512.0,
      256.0, 128.0,  64.0,   32.0,   16.0,    8.0,    4.0,   2.0
};

// Event posted for the periodic interrupt.

event periodic_interrupt {
    is interrupt_event;

    param desc = "Periodic interrupt";

    // A periodic interrupt event should be posted if the oscillator is
    // enabled, the periodic interrupt flag is not already set, and a tap
    // from the clock divider stages is selected.
    method should_be_posted() -> (bool) {
        return registers.a.DV.val == 0b010 &&
               registers.c.PF.val == 0 &&
               registers.a.RS.val != 0;
    }

    // Calculates the time of the next interrupt and posts an event for it.
    method post_interrupt() {
        local double frequency = pi_freqs[registers.a.RS.val];
        local double delta;

        delta = next_occurrence_delta(frequency, 0.0);

        post(delta);
    }

    // Called when the interrupt event occurs. Raises the periodic
    // interrupt flag and updates the IRQF flag.
    method event() {
        log info, 3: "periodic interrupt triggered, raising PF";
        registers.c.PF.val = 1;
        update_IRQF();
    }
}

// Event posted for the alarm interrupt.

event alarm_interrupt {
    is interrupt_event;

    param desc = "Alarm interrupt";

    // An alarm interrupt event should be posted if the oscillator is
    // enabled, and the alarm interrupt flag is not already set.
    method should_be_posted() -> (bool) {
        return registers.a.DV.val == 0b010 &&
               registers.c.AF.val == 0;
    }

    // Calculates the time of the next interrupt and posts an event for it.
    method post_interrupt() {
        local double current_time = SIM_time(dev.obj);
        local double alarm_time;
        local int64 rtc_time;
        local os_tm_t rtc_time_parts;

        local bool hour_wildcard   = registers.hours_alarm.val[7:6]   == 0b11;
        local bool minute_wildcard = registers.minutes_alarm.val[7:6] == 0b11;
        local bool second_wildcard = registers.seconds_alarm.val[7:6] == 0b11;

        local int alarm_hour;
        local int alarm_minute;
        local int alarm_second;

        // Get the current real-time clock time and split it to parts.
        rtc_time = get_rtc_time();
        rtc_time_parts = gmtime64(rtc_time);

        // Calculate the hour, minute and second at which the alarm
        // will trigger. This is a little complicated if there are
        // wildcards.
        alarm_hour = (hour_wildcard
                      ? rtc_time_parts.tm_hour
                      : registers.hours_alarm.val);
        alarm_minute = (minute_wildcard
                        ? rtc_time_parts.tm_min
                        : registers.minutes_alarm.val);
        alarm_second = (second_wildcard
                        ? rtc_time_parts.tm_sec
                        : registers.seconds_alarm.val);

        if (second_wildcard)
            if ((!hour_wildcard && alarm_hour != rtc_time_parts.tm_hour) ||
                (!minute_wildcard && alarm_minute != rtc_time_parts.tm_min))
                alarm_second = 0;
            else
                alarm_second = (alarm_second + 1) % 60;

        if (minute_wildcard)
            if (!hour_wildcard && alarm_hour != rtc_time_parts.tm_hour)
                alarm_minute = 0;
            else if (alarm_minute == rtc_time_parts.tm_min &&
                     alarm_second <= rtc_time_parts.tm_sec)
                alarm_minute = (alarm_minute + 1) % 60;

        if (hour_wildcard)
            if (alarm_hour == rtc_time_parts.tm_hour &&
                (alarm_minute < rtc_time_parts.tm_min ||
                 (alarm_minute == rtc_time_parts.tm_min &&
                  alarm_second < rtc_time_parts.tm_sec )))
                alarm_hour = (alarm_hour + 1) % 24;

        // Add the difference between the time that the alarm will
        // occur and the real-time clock time to the real-time clock
        // time.
        rtc_time += (alarm_hour - rtc_time_parts.tm_hour) * 60 * 60;
        rtc_time += (alarm_minute - rtc_time_parts.tm_min) * 60;
        rtc_time += alarm_second - rtc_time_parts.tm_sec;

        // Add a day to the time if the alarm will occur the next day.
        if (alarm_hour < rtc_time_parts.tm_hour ||
            (alarm_hour == rtc_time_parts.tm_hour &&
             (alarm_minute < rtc_time_parts.tm_min ||
              (alarm_minute == rtc_time_parts.tm_min &&
               alarm_second <= rtc_time_parts.tm_sec))))
            rtc_time += 24 * 60 * 60;

        // Calculate the simulated time at which the alarm will occur.
        alarm_time = rtc_time_to_time(rtc_time);

        // Post the event.
        post(alarm_time - current_time);
    }

    // Called when the interrupt event occurs. Raises the alarm interrupt
    // flag and updates the IRQF flag.
    method event() {
        log info, 3: "alarm interrupt triggered, raising AF";
        registers.c.AF.val = 1;
        update_IRQF();
    }
}

// Event posted for the update-ended interrupt.

event update_ended_interrupt {
    is interrupt_event;

    param desc = "Update-ended interrupt";

    // An update-ended interrupt event should be posted if the oscillator
    // is enabled, the update-ended interrupt flag is not already set, and
    // the SET bit of register B is not set.
    method should_be_posted() -> (bool) {
        return registers.a.DV.val == 0b010 &&
               registers.c.UF.val == 0 &&
               registers.b.SET.get() == 0;
    }

    // Calculates the time of the next interrupt and posts an event for it.
    method post_interrupt() {
        local double delta;

        delta = next_occurrence_delta(1.0, 244.0e-6);

        post(delta);
    }

    // Called when the interrupt event occurs. Raises the update-ended
    // interrupt flag and updates the IRQF flag.
    method event() {
        log info, 3: "update-ended interrupt triggered, raising UF";
        registers.c.UF.val = 1;
        update_IRQF();
    }
}

// Updates the IRQF flag in register C, and raises or lowers the interrupt to
// irq_dev accordingly. If irq_dev is not set, just log a message.

method update_IRQF() {
    // Save the old IRQF value and calculate the new value.
    local int old_IRQF = registers.c.IRQF.val;
    registers.c.IRQF.val =
        ((registers.c.UF.val != 0 && registers.b.UIE.get() != 0) ||
         (registers.c.AF.val != 0 && registers.b.AIE.get() != 0) ||
         (registers.c.PF.val != 0 && registers.b.PIE.get() != 0));

    // Don't raise interrupts during attribute setting
    if (SIM_is_restoring_state(dev.obj))
        return;

    // Raise the interrupt if the IRQF flag went from 0 to 1.
    if (old_IRQF == 0 && registers.c.IRQF.val == 1) {
        log info, 3: "raising interrupt";
        if (irq_dev.obj)
            irq_dev.simple_interrupt.interrupt(irq_level.val);
    }

    // Lower the interrupt if the IRQF flag went from 1 to 0.
    if (old_IRQF == 1 && registers.c.IRQF.val == 0) {
        log info, 3: "lowering interrupt";
        if (irq_dev.obj)
            irq_dev.simple_interrupt.interrupt_clear(irq_level.val);
    }
}

// Copies the contents of the internal time counter to the time registers,
// regardless of if real-time clock is running (the oscillator is on and the
// SET bit of register b is set).

method update_time_registers_unconditional() {
    local int64 rtc_time;
    local os_tm_t tm;

    // Get the real-time clock time.
    rtc_time = get_rtc_time();

    // Split the time parts.
    tm = gmtime64(rtc_time);

    // Write the time registers. DS12887 counts day of the week and month
    // from 1, os_tm_t count them from 0. DS12887 doesn't keep track of the
    // century.
    registers.seconds.val = tm.tm_sec;
    registers.minutes.val = tm.tm_min;
    registers.hours.val = tm.tm_hour;
    registers.day_of_the_week.val = tm.tm_wday  + 1;
    registers.date_of_the_month.val = tm.tm_mday;
    registers.month.val = tm.tm_mon + 1;
    registers.year.val = tm.tm_year % 100;
}

// Copies the contents of the internal time counter to the time registers if
// the real-time clock is running (the oscillator is enabled and the SET bit of
// register b is not set).

method update_time_registers_conditional() {
    if(registers.a.DV.val == 0b010 && registers.b.SET.get() == 0)
        update_time_registers_unconditional();
}

// Copies the contents of the time registers to the internal time counter.

method writeback_time_registers() {
    local int64 rtc_time;
    local os_tm_t tm;

    // Read the time registers. DS12887 counts day of the week and month
    // from 1, os_tm_t counts them from 0. Count years less than 30 as
    // 20xx, years greater or equal to 30 as 19xx.
    tm.tm_sec = registers.seconds.val;
    tm.tm_min = registers.minutes.val;
    tm.tm_hour = registers.hours.val;
    tm.tm_wday = registers.day_of_the_week.val - 1;
    tm.tm_mday = registers.date_of_the_month.val;
    tm.tm_mon = registers.month.val - 1;
    if (registers.year.val < 30)
        tm.tm_year = registers.year.val + 100;
    else
        tm.tm_year = registers.year.val;

    // Join the time parts.
    rtc_time = timegm64(tm);

    // Set the real-time clock time.
    set_rtc_time(rtc_time);

    // Alarm interrupt events may have to be moved when the real-time clock
    // time changes.
    alarm_interrupt.update_time();
}

// We want to log when interrupt and interrupt enable flags are raised and
// lowered, so we create a template for them.

template irq_flag {
    is ignore_write;

    is read;
    method read() -> (uint64) {
        local uint64 value;
        value = this.val;
        this.val = 0;
        if (value == 1)
            log info, 3: "%s lowered", name;
        return value;
    }
}

template irq_enable_flag is field {
    is write;
    method write(uint64 value) {
        if (this.val == 0 && value == 1)
            log info, 3: "%s set", name;
        if (this.val == 1 && value == 0)
            log info, 3: "%s cleared", name;
        this.val = value;
        update_IRQF();
    }
}

// This is needed because we have non-persistent fields within persistent
// registers. So we solve this by storing the persistent parts of the register
// in a separate, persistent, storage and aliasing the fields there
template persistent_field is field {
    param storage;

    // This would defeat the purpose
    #if (parent.persistent) {
        error "Persistent field under already persistent register";
    }

    is set;
    method set(uint64 value) default {
        storage.set(value);
    }

    is get;
    method get() -> (uint64) default {
        return storage.get();
    }

    is write;
    method write(uint64 value) default {
        storage.write(value);
    }

    is read;
    method read() -> (uint64) default {
        return storage.read();
    }
}

// This template is used by all time and alarm registers of the real-time
// clock. It contains methods for converting between BCD and binary format and
// for checking that the value is within the allowed range.

template rtc_register {
    param max_value default undefined;
    param min_value default undefined;

    // Converts a value from BCD format to binary format.
    method from_bcd(uint8 value) -> (uint8) {
        local bool illegal = false;
        local uint8 adjusted_value = value;
        if ((adjusted_value >> 4) > 9) {
            illegal = true;
            adjusted_value = 0x90 | (adjusted_value & 0xf);
        }
        if ((adjusted_value & 0xf) > 9) {
            illegal = true;
            adjusted_value = (adjusted_value & 0xf0) | 0x9;
        }
        if (illegal)
            log spec_viol:
                "illegal BCD value 0x%x written to register %s - adjusting to BCD value 0x%x",
                value, qname, adjusted_value;
        return (adjusted_value >> 4) * 10 + (adjusted_value & 0xf);
    }

    // Converts a value from binary format to binary BCD.
    method to_bcd(uint8 value) -> (uint8) {
        local uint8 result;
        if (value > 99) {
            log error:
                "value 0x%x of register %s can not be converted to a BCD value - adjusting to BCD value 0x99",
                value, qname;
            result = 0x99;
        }
        else
            result = ((value / 10) << 4) | (value % 10);
        return result;
    }

    // Checks that that value is within the allowed bounds, and adjusts it
    // if not.
    method check_bounds(uint8 value) -> (uint8) {
        local uint8 result = value;
        #if (defined min_value) {
            if (result < min_value) {
                log spec_viol:
                    "illegal value 0x%x written to register %s - adjusting value to 0x%x",
                    result, qname, min_value;
                return min_value;
            }
        }
        #if (defined max_value) {
            if (result > max_value) {
                log spec_viol:
                    "illegal value 0x%x written to register %s - adjusting value to 0x%x",
                    result, qname, max_value;
                return max_value;
            }
        }
        return result;
    }

    // Convert a value from the current register format to binary format.
    method from_register_format(uint8 value) -> (uint8) default {
        local uint8 result;
        result = value;
        if (registers.b.DM.get() == 0)
            result = from_bcd(result);
        result = check_bounds(result);
        return result;
    }

    // Convert a value from binary format to the current register format.
    method to_register_format(uint8 value) -> (uint8) default {
        local uint8 result;
        result = value;
        if (registers.b.DM.get() == 0)
            result = to_bcd(result);
        return result;
    }
}

// The hour_rtc_register extends rtc_register with the handling of the AM/PM
// bit in the hours and hours_alarm registers.

template hour_rtc_register {
    is rtc_register;

    // Convert a value from the current register format to binary format.
    method from_register_format(uint8 value) -> (uint8) {
        local uint8 result;
        local bool pm = registers.b.TWENTYFOUR_TWELVE.get() == 0
                        && value[7] == 1;
        result = value;
        if (pm)
            result[7] = 0;
        if (registers.b.DM.get() == 0)
            result = from_bcd(result);
        if (registers.b.TWENTYFOUR_TWELVE.get() == 0)
            result -= 1;
        if (pm)
            result += 12;
        result = check_bounds(result);
        return result;
    }

    // Convert a value from binary format to the current register format.
    method to_register_format(uint8 value) -> (uint8) {
        local uint8 result;
        local bool pm = registers.b.TWENTYFOUR_TWELVE.get() == 0 && value > 12;
        result = value;
        if (pm)
            result -= 12;
        if (registers.b.TWENTYFOUR_TWELVE.get() == 0)
            result += 1;
        if (registers.b.DM.get() == 0)
            result = to_bcd(result);
        if (pm)
            result[7] = 1;
        return result;
    }
}

// Handles reads and writes to time registers.

template time_register is register {
    param persistent = true;
    // Update the time registers, convert the register value to the
    // current format and return it.
    is read;
    method read() -> (uint64) {
        update_time_registers_conditional();
        return to_register_format(this.val);
    }

    // Update the time registers, parse the register value from the
    // current format, perform the write, writeback the value of the time
    // registers to the internal time, and maybe update the alarm
    // interrupt event.
    is write;
    method write(uint64 value) {
        update_time_registers_conditional();
        this.val = from_register_format(value);
        writeback_time_registers();
        update_alarm_interrupt();
    }

    // Update the time registers, set the register value, writeback the value
    // of the time registers to the internal time, and maybe update the alarm
    // interrupt event.
    method set(uint64 value) {
        if (SIM_object_is_configured(dev.obj)) {
            update_time_registers_conditional();
            this.val = value;
            writeback_time_registers();
            update_alarm_interrupt();
        } else {
            this.val = value;
        }
    }

    // Update the time registers and return the register value.
    method get() -> (uint64) {
        update_time_registers_conditional();
        return this.val;
    }

    // Update the alarm interrupt event, if it is dependent on this
    // register. Doesn't update the alarm interrupt event by default, but
    // the seconds, minutes and hours registers override it using the
    // time_alarm_register template.
    method update_alarm_interrupt() default {
    }
}

// Template included by the seconds, minutes and hours registers to update the
// alarm interrupt event when they are changed.

template time_alarm_register is time_register {
    method update_alarm_interrupt() {
        alarm_interrupt.update_time();
    }
}

// Handles reads and writes to alarm registers.

template alarm_register is register {
    param persistent = true;
    // Convert the register value to the current format and return it.
    is read;
    method read() -> (uint64) {
        return to_register_format(this.val);
    }

    // Parse the register value from the current format, perform the write,
    // and update the alarm interrupt.
    is write;
    method write(uint64 value) {
        this.val = from_register_format(value);
        alarm_interrupt.update_time();
        log info, 2: "alarm set to %02d:%02d:%02d",
            registers.hours_alarm.val,
            registers.minutes_alarm.val,
            registers.seconds_alarm.val;
    }

    // We need to update alarm interrupt event after the register has been
    // set through an attribute.
    method set(uint64 value) {
        default(value);
        alarm_interrupt.update_time();
    }
}

// Implementations of the port space registers used to access the DS12887
// registers in a PC.

bank port_registers {
    register address {
        param documentation =
            "Port space address register. Specifies the DS12887 register "+
            "that reads and writes to the port space data register are "+
            "forwarded to.";
        // The NMI mask bit is ignored, since it isn't handled by this device
        field nmi     @ [7:7] is (ignore_write);
        field addr    @ [6:0];
    }
    register data {
        param documentation =
            "Port space data register. Forwards reads and writes to the "+
            "DS12887 register specified by the port space address register.";

        // This register only forward accesses to other registers,
        // so we don't create an attribute for it.
        param configuration = "none";

        // Forward read operations to the registers bank, at the
        // address specified by the address register.
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            try {
                return registers.read(port_registers.address.addr.val,
                                      enabled_bytes, aux);
            } catch {
                log error: "Failed to read-forward to the registers";
                return 0;
            }
        }

        // Forward write operations to the registers bank, at the
        // address specified by the address register.
        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            try {
                registers.write(port_registers.address.addr.val,
                                value, enabled_bytes, aux);
            } catch {
                log error: "Failed to write-forward to the registers";
            }
        }
    }
}

// Implementations of the DS12887 registers.

bank registers {
    register seconds is (time_register, time_alarm_register, rtc_register) {
        param documentation =
            "Seconds register. In binary format in the range " +
            "0-59, regardless of the current register mode.";
        param max_value = 59;
    }
    register seconds_alarm is (alarm_register, rtc_register) {
        param documentation =
            "Seconds alarm register. In binary format in the " +
            "range 0-59, regardless of the current register mode.";
        param max_value = 59;
    }
    register minutes is (time_register, time_alarm_register, rtc_register) {
        param documentation =
            "Minutes register. In binary format in the range " +
            "0-59, regardless of the current register mode.";
        param max_value = 59;
    }
    register minutes_alarm is (alarm_register, rtc_register) {
        param documentation =
            "Minutes alarm register. In binary format in the" +
            "range 0-59, regardless of the current register mode.";
        param max_value = 59;
    }
    register hours is (time_register, time_alarm_register, hour_rtc_register) {
        param documentation =
            "Hours register. In binary format in the range " +
            "0-23, regardless of the current register mode.";
        param max_value = 23;
    }
    register hours_alarm is (alarm_register, hour_rtc_register) {
        param documentation =
            "Hours alarm register. In binary format in the " +
            "range 0-23, regardless of the current register mode.";
        param max_value = 23;
    }
    register day_of_the_week is (time_register, rtc_register) {
        param documentation =
            "Day of the week register. In binary format in the " +
            "range 1-7, regardless of the current register mode.";
        param min_value = 1;
        param max_value = 7;
    }
    register date_of_the_month is (time_register, rtc_register) {
        param documentation =
            "Day of the month register. In binary format in the " +
            "range 1-31, regardless of the current register mode.";
        param min_value = 1;
        param max_value = 31;
    }
    register month is (time_register, rtc_register) {
        param documentation =
            "Month register. In binary format in the range " +
            "1-12, regardless of the current register mode.";
        param min_value = 1;
        param max_value = 12;
    }
    register year is (time_register, rtc_register) {
        param documentation =
            "Year register. In binary format in the range 0-99, " +
            "regardless of the current register mode.";
        param max_value = 99;
    }
    register a {
        param documentation = "Register A.";
        param persistent = true;
        // RS field, determines periodic interrupt frequency.
        field RS  @ [3:0] {
            is write;
            is set;
            method set(uint64 value) {
                // Changing the RS field may enable or disabled
                // periodic interrupts, or change the periodic
                // interrupt frequency.
                if (this.val != value) {
                    if (value == 0)
                        log info, 3: "periodic interrupts disabled";
                    else
                        log info, 3:
                            "periodic interrupt frequency set to %f Hz",
                            pi_freqs[value];
                }

                this.val = value;

                periodic_interrupt.update_time();
            }
        }
        // DV field, enables or disables the oscillator. A value of
        // 0b010 enables the oscillator, all other value disable the
        // oscillator (or at least hold the clock divider in reset).
        field DV  @ [6:4] {
            is write;
            method write(uint64 value) {
                // The oscillator is being enabled, so we set
                // base_time. We read the real-time clock time
                // before enabling the oscillator and write it
                // back after, since the time representation is
                // changed.
                if (value == 0b010 && this.val != 0b010) {
                    local int64 rtc_time = get_rtc_time();
                    base_time.val = SIM_time(dev.obj);
                    this.val = value;
                    log info, 2: "oscillator enabled, clock starting";
                    set_rtc_time(rtc_time);
                }
                // The oscillator is being disabled. We need to
                // update the time registers, since they can no
                // longer be update lazily. We read the
                // real-time clock time before disabling the
                // oscillator and write it back after, since
                // the time representation is changed.
                if (value != 0b010 && this.val == 0b010) {
                    update_time_registers_conditional();
                    local int64 rtc_time = get_rtc_time();
                    this.val = value;
                    log info, 2: "oscillator disabled, clock stopping";
                    set_rtc_time(rtc_time);
                }

                set(value);
            }
            is set;
            method set(uint64 value) {
                // We need to update all interrupts if the
                // oscillator is being enabled or disabled.
                if ((value == 0b010 && this.val != 0b010) ||
                    (value != 0b010 && this.val == 0b010)) {
                    periodic_interrupt.update_time();
                    alarm_interrupt.update_time();
                    update_ended_interrupt.update_time();
                }
                this.val = value;
            }
        }
        // UIP bit, set when there is less than 244 microseconds to the
        // next real-time clock update.
        field UIP  @ [7] is ignore_write {
            // The UIP bit is calculated from other state, so we
            // don't need any storage for it.

            is read;

            // The UIP bit should be 1 if the oscillator is
            // enabled, the SET bit is not set, and a real-time
            // clock update will occur within 244 microseconds.
            is get;
            method get() -> (uint64) {
                if (registers.a.DV.val == 0b010 && registers.b.SET.get() == 0) {
                    if (next_occurrence_delta(1.0, 244.0e-6) <= 244.0e-6)
                        return 1;
                }
                return 0;
            }
        }
    }
    register b {
        param documentation = "Register B.";
        // DSE bit, enables daylight saving mode. Not implemented.
        field DSE  @ [0] {
            is persistent_field;
            param storage = partially_persistent_registers.b.DSE;

            is write;
            method write(uint64 value) {
                set(value);
            }
            is set;
            method set(uint64 value) {
                default(value);
                if (get() == 1)
                    log unimpl, 1:
                        "daylight saving time enabled";
            }
        }
        // 24/12 bit, select 24 or 12 hour mode.
        field TWENTYFOUR_TWELVE  @ [1] {
            is persistent_field;
            param storage = partially_persistent_registers.b.TWENTYFOUR_TWELVE;
        }
        // DM bit, selects binary or BCD time register format.
        field DM  @ [2] {
            is persistent_field;
            param storage = partially_persistent_registers.b.DM;
        }
        // SQWE bit, enables square wave output. Not implemented.
        field SQWE  @ [3] {
            is persistent_field;
            param storage = partially_persistent_registers.b.SQWE;

            is write;

            is set;
            method set(uint64 value) {
                default(value);
                if (get() == 1)
                    log unimpl, 1:
                        "square wave enabled";
            }
        }
        // Interrupt enable flags for update-ended, alarm and periodic
        // interrupts.
        field UIE  @ [4] is irq_enable_flag;
        field AIE  @ [5] is irq_enable_flag;
        field PIE  @ [6] is irq_enable_flag;
        // SET bit, inhibits real-time clock register updates.
        field SET  @ [7] {
            is persistent_field;
            param storage = partially_persistent_registers.b.SET;

            is write;
            method write(uint64 value) {
                if (value != get())
                    log info, 3: "SET %s", value == 0 ? "cleared" : "set";
                set(value);
            }
            is set;
            method set(uint64 value) {
                // When the SET bit is set, we need to update
                // the time registers, since they can no longer
                // be update lazily.
                if (value == 1 && get() == 0)
                    update_time_registers_conditional();

                // We need to update the update-ended interrupt
                // event when the SET bit is changed.
                if (value != get())
                    update_ended_interrupt.update();

                default(value);
            }
        }

        // Writing this register or setting it through an attribute may
        // enable interrupts, so we need to update the IRQF flag.

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            update_IRQF();
        }

        method set(uint64 value) {
            default(value);
            update_IRQF();
        }
    }
    register c {
        param documentation = "Register C.";
        // Reserved bits, just return 0.
        field RESERVED  @ [3:0] is (silent_constant) {
            param value = 0;
        }
        // Interrupt flags for update-ended, alarm and periodic interrupts.
        field UF  @ [4] is (irq_flag);
        field AF  @ [5] is (irq_flag);
        field PF  @ [6] is (irq_flag);
        // IRQF bit, indicates if there is a raised unmasked interrupt.
        field IRQF  @ [7] is (read_only);

        // Reading this register or setting it through an attribute may
        // change the interrupt flags, so we need to update the
        // interrupt events and the IRQF flag.

        method update() {
            update_ended_interrupt.update();
            alarm_interrupt.update();
            periodic_interrupt.update();
            update_IRQF();
        }

        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            local uint64 value = default(enabled_bytes, aux);
            update();
            return value;
        }

        method set(uint64 value) {
            default(value);
            update();
        }
    }
    register d {
        param documentation = "Register D.";
        param persistent = true;
        // Reserved bits, just return 0.
        field RESERVED  @ [6:0] is (silent_constant) {
            param value = 0;
        }
        // VRT bit, indicates battery status. Always 1.
        field VRT  @ [7] is (silent_constant) {
            param value = 1;
        }
    }

    // NVRAM registers. Simply read-write registers that ignore reset.
    register nvram[i < RAM_SIZE] {
        param documentation =
            "NVRAM registers, corresponding to the offsets 14 to 127.";
        param persistent = true;

        is read;
        method read() -> (uint64) {
            if (ram_ctrl[i].val == 0)
                return this.val;
            else
                return volatile_ram[i].val;
        }

        is write;
        method write(uint64 value) {
            this.val = value;
            volatile_ram[i].val = value;
        }
    }

    register volatile_ram[i < RAM_SIZE] is unmapped
        "Volatile RAM Register. Writes to the RAM register will also update"
        + " the corresponding volatile_ram register. See also ram_ctrl.";

    register ram_ctrl[i < RAM_SIZE] is unmapped
        "Volatile RAM Control Register. If an entry in this attribute is non"
        + "-zero a read from the ram register will read the corresponding"
        + " entry in the volatile_ram attribute instead.";
}

implement io_memory is function_io_memory;

// Run after all attributes have been set when a device is created or a
// checkpoint is loaded.
method post_init() {
    // The device is configured, so we can start posting interrupts.
    SIM_set_object_configured(dev.obj);

    // updating time registers will access the clock to ask for current time
    //:: pre ds12887_get_clock {{
    local conf_object_t *clock = SIM_object_clock(dev.obj);
    if (clock == NULL) {
        log error: "device does not have a time queue/clock";
    } else {
        SIM_require_object(clock);
    }
    // }}

    // Make sure time is updated after loading a persistent state
    writeback_time_registers();

    // Post any interrupt events that should be posted.
    periodic_interrupt.update();
    alarm_interrupt.update();
    update_ended_interrupt.update();
}
