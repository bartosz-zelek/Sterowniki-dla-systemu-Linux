// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_DEVS_RAM_H
#define SIMICS_CPP_DEVS_RAM_H

#include "simics/devs/ram.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class RamInterface {
  public:
    using ctype = ram_interface_t;

    // Function override and implemented by user
    virtual page_t * get_page(physical_address_t addr) = 0;
    virtual void fill(physical_address_t start, uint64 length, uint8 value) = 0;
    virtual exception_type_t read(conf_object_t *initiator, uint64 addr, buffer_t data, ram_operation_flags_t flags) = 0;
    virtual exception_type_t write(conf_object_t *initiator, uint64 addr, bytes_t data, ram_operation_flags_t flags) = 0;
    virtual exception_type_t touch(conf_object_t *initiator, uint64 addr, uint64 size, read_or_write_t rw, ram_operation_flags_t flags) = 0;
    virtual uint64 size() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static page_t * get_page(conf_object_t *obj, physical_address_t addr) {
            return detail::get_interface<RamInterface>(obj)->get_page(addr);
        }
        static void fill(conf_object_t *obj, physical_address_t start, uint64 length, uint8 value) {
            detail::get_interface<RamInterface>(obj)->fill(start, length, value);
        }
        static exception_type_t read(conf_object_t *obj, conf_object_t *initiator, uint64 addr, buffer_t data, ram_operation_flags_t flags) {
            return detail::get_interface<RamInterface>(obj)->read(initiator, addr, data, flags);
        }
        static exception_type_t write(conf_object_t *obj, conf_object_t *initiator, uint64 addr, bytes_t data, ram_operation_flags_t flags) {
            return detail::get_interface<RamInterface>(obj)->write(initiator, addr, data, flags);
        }
        static exception_type_t touch(conf_object_t *obj, conf_object_t *initiator, uint64 addr, uint64 size, read_or_write_t rw, ram_operation_flags_t flags) {
            return detail::get_interface<RamInterface>(obj)->touch(initiator, addr, size, rw, flags);
        }
        static uint64 size(conf_object_t *obj) {
            return detail::get_interface<RamInterface>(obj)->size();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const RamInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        page_t * get_page(physical_address_t addr) const {
            return iface_->get_page(obj_, addr);
        }
        void fill(physical_address_t start, uint64 length, uint8 value) const {
            iface_->fill(obj_, start, length, value);
        }
        exception_type_t read(conf_object_t *initiator, uint64 addr, buffer_t data, ram_operation_flags_t flags) const {
            return iface_->read(obj_, initiator, addr, data, flags);
        }
        exception_type_t write(conf_object_t *initiator, uint64 addr, bytes_t data, ram_operation_flags_t flags) const {
            return iface_->write(obj_, initiator, addr, data, flags);
        }
        exception_type_t touch(conf_object_t *initiator, uint64 addr, uint64 size, read_or_write_t rw, ram_operation_flags_t flags) const {
            return iface_->touch(obj_, initiator, addr, size, rw, flags);
        }
        uint64 size() const {
            return iface_->size(obj_);
        }

        const RamInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const RamInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return RAM_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr RamInterface::ctype funcs {
                FromC::get_page,
                FromC::fill,
                FromC::read,
                FromC::write,
                FromC::touch,
                FromC::size,
            };
            return &funcs;
        }
    };
};

class RomInterface {
  public:
    using ctype = rom_interface_t;

    // Function override and implemented by user
    virtual page_t * get_page(physical_address_t addr) = 0;
    virtual void fill(physical_address_t start, uint64 length, uint8 value) = 0;
    virtual exception_type_t read(conf_object_t *initiator, uint64 addr, buffer_t data, ram_operation_flags_t flags) = 0;
    virtual exception_type_t write(conf_object_t *initiator, uint64 addr, bytes_t data, ram_operation_flags_t flags) = 0;
    virtual exception_type_t touch(conf_object_t *initiator, uint64 addr, uint64 size, read_or_write_t rw, ram_operation_flags_t flags) = 0;
    virtual uint64 size() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static page_t * get_page(conf_object_t *obj, physical_address_t addr) {
            return detail::get_interface<RomInterface>(obj)->get_page(addr);
        }
        static void fill(conf_object_t *obj, physical_address_t start, uint64 length, uint8 value) {
            detail::get_interface<RomInterface>(obj)->fill(start, length, value);
        }
        static exception_type_t read(conf_object_t *obj, conf_object_t *initiator, uint64 addr, buffer_t data, ram_operation_flags_t flags) {
            return detail::get_interface<RomInterface>(obj)->read(initiator, addr, data, flags);
        }
        static exception_type_t write(conf_object_t *obj, conf_object_t *initiator, uint64 addr, bytes_t data, ram_operation_flags_t flags) {
            return detail::get_interface<RomInterface>(obj)->write(initiator, addr, data, flags);
        }
        static exception_type_t touch(conf_object_t *obj, conf_object_t *initiator, uint64 addr, uint64 size, read_or_write_t rw, ram_operation_flags_t flags) {
            return detail::get_interface<RomInterface>(obj)->touch(initiator, addr, size, rw, flags);
        }
        static uint64 size(conf_object_t *obj) {
            return detail::get_interface<RomInterface>(obj)->size();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const RomInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        page_t * get_page(physical_address_t addr) const {
            return iface_->get_page(obj_, addr);
        }
        void fill(physical_address_t start, uint64 length, uint8 value) const {
            iface_->fill(obj_, start, length, value);
        }
        exception_type_t read(conf_object_t *initiator, uint64 addr, buffer_t data, ram_operation_flags_t flags) const {
            return iface_->read(obj_, initiator, addr, data, flags);
        }
        exception_type_t write(conf_object_t *initiator, uint64 addr, bytes_t data, ram_operation_flags_t flags) const {
            return iface_->write(obj_, initiator, addr, data, flags);
        }
        exception_type_t touch(conf_object_t *initiator, uint64 addr, uint64 size, read_or_write_t rw, ram_operation_flags_t flags) const {
            return iface_->touch(obj_, initiator, addr, size, rw, flags);
        }
        uint64 size() const {
            return iface_->size(obj_);
        }

        const RomInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const RomInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ROM_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr RomInterface::ctype funcs {
                FromC::get_page,
                FromC::fill,
                FromC::read,
                FromC::write,
                FromC::touch,
                FromC::size,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
