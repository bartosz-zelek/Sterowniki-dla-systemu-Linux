// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_ARCH_X86_H
#define SIMICS_CPP_ARCH_X86_H

#include "simics/arch/x86.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class X86AccessTypeInterface {
  public:
    using ctype = x86_access_type_interface_t;

    // Function override and implemented by user
    virtual const char * get_enum_name(x86_access_type_t at) = 0;
    virtual const char * get_short_name(x86_access_type_t at) = 0;
    virtual const char * get_description(x86_access_type_t at) = 0;
    virtual bool implicit(x86_access_type_t at) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static const char * get_enum_name(conf_object_t *obj, x86_access_type_t at) {
            return detail::get_interface<X86AccessTypeInterface>(obj)->get_enum_name(at);
        }
        static const char * get_short_name(conf_object_t *obj, x86_access_type_t at) {
            return detail::get_interface<X86AccessTypeInterface>(obj)->get_short_name(at);
        }
        static const char * get_description(conf_object_t *obj, x86_access_type_t at) {
            return detail::get_interface<X86AccessTypeInterface>(obj)->get_description(at);
        }
        static bool implicit(conf_object_t *obj, x86_access_type_t at) {
            return detail::get_interface<X86AccessTypeInterface>(obj)->implicit(at);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86AccessTypeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        const char * get_enum_name(x86_access_type_t at) const {
            return iface_->get_enum_name(obj_, at);
        }
        const char * get_short_name(x86_access_type_t at) const {
            return iface_->get_short_name(obj_, at);
        }
        const char * get_description(x86_access_type_t at) const {
            return iface_->get_description(obj_, at);
        }
        bool implicit(x86_access_type_t at) const {
            return iface_->implicit(obj_, at);
        }

        const X86AccessTypeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86AccessTypeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_ACCESS_TYPE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86AccessTypeInterface::ctype funcs {
                FromC::get_enum_name,
                FromC::get_short_name,
                FromC::get_description,
                FromC::implicit,
            };
            return &funcs;
        }
    };
};

class X86TlbInterface {
  public:
    using ctype = x86_tlb_interface_t;

    // Function override and implemented by user
    virtual void flush_all(int keep_global_entries) = 0;
    virtual void flush_page(linear_address_t laddr) = 0;
    virtual int lookup(x86_memory_transaction_t *mem_tr) = 0;
    virtual void add(processor_mode_t mode, read_or_write_t read_or_write, data_or_instr_t data_or_instr, int global_page, x86_memory_type_t pat_type, x86_memory_type_t mtrr_type, linear_address_t laddr, physical_address_t paddr, int page_size) = 0;
    virtual tagged_physical_address_t itlb_lookup(linear_address_t laddr, processor_mode_t mode) = 0;
    virtual void set_pae_mode(bool pae_mode) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void flush_all(conf_object_t *obj, int keep_global_entries) {
            detail::get_interface<X86TlbInterface>(obj)->flush_all(keep_global_entries);
        }
        static void flush_page(conf_object_t *obj, linear_address_t laddr) {
            detail::get_interface<X86TlbInterface>(obj)->flush_page(laddr);
        }
        static int lookup(conf_object_t *obj, x86_memory_transaction_t *mem_tr) {
            return detail::get_interface<X86TlbInterface>(obj)->lookup(mem_tr);
        }
        static void add(conf_object_t *obj, processor_mode_t mode, read_or_write_t read_or_write, data_or_instr_t data_or_instr, int global_page, x86_memory_type_t pat_type, x86_memory_type_t mtrr_type, linear_address_t laddr, physical_address_t paddr, int page_size) {
            detail::get_interface<X86TlbInterface>(obj)->add(mode, read_or_write, data_or_instr, global_page, pat_type, mtrr_type, laddr, paddr, page_size);
        }
        static tagged_physical_address_t itlb_lookup(conf_object_t *obj, linear_address_t laddr, processor_mode_t mode) {
            return detail::get_interface<X86TlbInterface>(obj)->itlb_lookup(laddr, mode);
        }
        static void set_pae_mode(conf_object_t *obj, bool pae_mode) {
            detail::get_interface<X86TlbInterface>(obj)->set_pae_mode(pae_mode);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86TlbInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void flush_all(int keep_global_entries) const {
            iface_->flush_all(obj_, keep_global_entries);
        }
        void flush_page(linear_address_t laddr) const {
            iface_->flush_page(obj_, laddr);
        }
        int lookup(x86_memory_transaction_t *mem_tr) const {
            return iface_->lookup(obj_, mem_tr);
        }
        void add(processor_mode_t mode, read_or_write_t read_or_write, data_or_instr_t data_or_instr, int global_page, x86_memory_type_t pat_type, x86_memory_type_t mtrr_type, linear_address_t laddr, physical_address_t paddr, int page_size) const {
            iface_->add(obj_, mode, read_or_write, data_or_instr, global_page, pat_type, mtrr_type, laddr, paddr, page_size);
        }
        tagged_physical_address_t itlb_lookup(linear_address_t laddr, processor_mode_t mode) const {
            return iface_->itlb_lookup(obj_, laddr, mode);
        }
        void set_pae_mode(bool pae_mode) const {
            iface_->set_pae_mode(obj_, pae_mode);
        }

        const X86TlbInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86TlbInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_TLB_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86TlbInterface::ctype funcs {
                FromC::flush_all,
                FromC::flush_page,
                FromC::lookup,
                FromC::add,
                FromC::itlb_lookup,
                FromC::set_pae_mode,
            };
            return &funcs;
        }
    };
};

class X86TlbV2Interface {
  public:
    using ctype = x86_tlb_v2_interface_t;

    // Function override and implemented by user
    virtual void flush_all(int keep_global_entries) = 0;
    virtual void flush_page(linear_address_t laddr) = 0;
    virtual const x86_tlb_entry_t * lookup(x86_memory_transaction_t *mem_tr) = 0;
    virtual void add(linear_address_t laddr, physical_address_t paddr, x86_tlb_attrs_t attrs) = 0;
    virtual tagged_physical_address_t itlb_lookup(linear_address_t laddr, processor_mode_t mode) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void flush_all(conf_object_t *obj, int keep_global_entries) {
            detail::get_interface<X86TlbV2Interface>(obj)->flush_all(keep_global_entries);
        }
        static void flush_page(conf_object_t *obj, linear_address_t laddr) {
            detail::get_interface<X86TlbV2Interface>(obj)->flush_page(laddr);
        }
        static const x86_tlb_entry_t * lookup(conf_object_t *obj, x86_memory_transaction_t *mem_tr) {
            return detail::get_interface<X86TlbV2Interface>(obj)->lookup(mem_tr);
        }
        static void add(conf_object_t *obj, linear_address_t laddr, physical_address_t paddr, x86_tlb_attrs_t attrs) {
            detail::get_interface<X86TlbV2Interface>(obj)->add(laddr, paddr, attrs);
        }
        static tagged_physical_address_t itlb_lookup(conf_object_t *obj, linear_address_t laddr, processor_mode_t mode) {
            return detail::get_interface<X86TlbV2Interface>(obj)->itlb_lookup(laddr, mode);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86TlbV2Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void flush_all(int keep_global_entries) const {
            iface_->flush_all(obj_, keep_global_entries);
        }
        void flush_page(linear_address_t laddr) const {
            iface_->flush_page(obj_, laddr);
        }
        const x86_tlb_entry_t * lookup(x86_memory_transaction_t *mem_tr) const {
            return iface_->lookup(obj_, mem_tr);
        }
        void add(linear_address_t laddr, physical_address_t paddr, x86_tlb_attrs_t attrs) const {
            iface_->add(obj_, laddr, paddr, attrs);
        }
        tagged_physical_address_t itlb_lookup(linear_address_t laddr, processor_mode_t mode) const {
            return iface_->itlb_lookup(obj_, laddr, mode);
        }

        const X86TlbV2Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86TlbV2Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_TLB_V2_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86TlbV2Interface::ctype funcs {
                FromC::flush_all,
                FromC::flush_page,
                FromC::lookup,
                FromC::add,
                FromC::itlb_lookup,
            };
            return &funcs;
        }
    };
};

class X86TlbV3Interface {
  public:
    using ctype = x86_tlb_v3_interface_t;

    // Function override and implemented by user
    virtual void add(uint64 hint, linear_address_t laddr, physical_address_t paddr, x86_tlb_attrs_v3_t attrs) = 0;
    virtual const x86_tlb_entry_v3_t * lookup(uint64 hint, x86_memory_transaction_t *mem_tr) = 0;
    virtual tagged_physical_address_t itlb_lookup(uint64 hint, linear_address_t laddr, processor_mode_t mode) = 0;
    virtual void invalidate_page(uint64 hint, linear_address_t laddr) = 0;
    virtual void invalidate(uint32 type, uint64 hint, linear_address_t la) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void add(conf_object_t *obj, uint64 hint, linear_address_t laddr, physical_address_t paddr, x86_tlb_attrs_v3_t attrs) {
            detail::get_interface<X86TlbV3Interface>(obj)->add(hint, laddr, paddr, attrs);
        }
        static const x86_tlb_entry_v3_t * lookup(conf_object_t *obj, uint64 hint, x86_memory_transaction_t *mem_tr) {
            return detail::get_interface<X86TlbV3Interface>(obj)->lookup(hint, mem_tr);
        }
        static tagged_physical_address_t itlb_lookup(conf_object_t *obj, uint64 hint, linear_address_t laddr, processor_mode_t mode) {
            return detail::get_interface<X86TlbV3Interface>(obj)->itlb_lookup(hint, laddr, mode);
        }
        static void invalidate_page(conf_object_t *obj, uint64 hint, linear_address_t laddr) {
            detail::get_interface<X86TlbV3Interface>(obj)->invalidate_page(hint, laddr);
        }
        static void invalidate(conf_object_t *obj, uint32 type, uint64 hint, linear_address_t la) {
            detail::get_interface<X86TlbV3Interface>(obj)->invalidate(type, hint, la);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86TlbV3Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void add(uint64 hint, linear_address_t laddr, physical_address_t paddr, x86_tlb_attrs_v3_t attrs) const {
            iface_->add(obj_, hint, laddr, paddr, attrs);
        }
        const x86_tlb_entry_v3_t * lookup(uint64 hint, x86_memory_transaction_t *mem_tr) const {
            return iface_->lookup(obj_, hint, mem_tr);
        }
        tagged_physical_address_t itlb_lookup(uint64 hint, linear_address_t laddr, processor_mode_t mode) const {
            return iface_->itlb_lookup(obj_, hint, laddr, mode);
        }
        void invalidate_page(uint64 hint, linear_address_t laddr) const {
            iface_->invalidate_page(obj_, hint, laddr);
        }
        void invalidate(uint32 type, uint64 hint, linear_address_t la) const {
            iface_->invalidate(obj_, type, hint, la);
        }

        const X86TlbV3Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86TlbV3Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_TLB_V3_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86TlbV3Interface::ctype funcs {
                FromC::add,
                FromC::lookup,
                FromC::itlb_lookup,
                FromC::invalidate_page,
                FromC::invalidate,
            };
            return &funcs;
        }
    };
};

class X86Interface {
  public:
    using ctype = x86_interface_t;

    // Function override and implemented by user
    virtual void set_pin_status(x86_pin_t pin, int status) = 0;
    virtual void start_up(uint32 start_address) = 0;
    virtual int interrupt(int (*ack)(conf_object_t *obj), conf_object_t *data) = 0;
    virtual void uninterrupt(int (*ack)(conf_object_t *obj)) = 0;
    virtual int has_pending_interrupt() = 0;
    virtual int has_waiting_interrupt() = 0;
    virtual tagged_linear_address_t logical_to_linear(int segment, logical_address_t addr) = 0;
    virtual physical_address_t linear_to_physical(data_or_instr_t d_or_i, linear_address_t addr) = 0;
    virtual void enter_acpi_c2_state() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void set_pin_status(conf_object_t *obj, x86_pin_t pin, int status) {
            detail::get_interface<X86Interface>(obj)->set_pin_status(pin, status);
        }
        static void start_up(conf_object_t *obj, uint32 start_address) {
            detail::get_interface<X86Interface>(obj)->start_up(start_address);
        }
        static int interrupt(conf_object_t *obj, int (*ack)(conf_object_t *obj), conf_object_t *data) {
            return detail::get_interface<X86Interface>(obj)->interrupt(ack, data);
        }
        static void uninterrupt(conf_object_t *obj, int (*ack)(conf_object_t *obj)) {
            detail::get_interface<X86Interface>(obj)->uninterrupt(ack);
        }
        static int has_pending_interrupt(conf_object_t *obj) {
            return detail::get_interface<X86Interface>(obj)->has_pending_interrupt();
        }
        static int has_waiting_interrupt(conf_object_t *obj) {
            return detail::get_interface<X86Interface>(obj)->has_waiting_interrupt();
        }
        static tagged_linear_address_t logical_to_linear(conf_object_t *obj, int segment, logical_address_t addr) {
            return detail::get_interface<X86Interface>(obj)->logical_to_linear(segment, addr);
        }
        static physical_address_t linear_to_physical(conf_object_t *obj, data_or_instr_t d_or_i, linear_address_t addr) {
            return detail::get_interface<X86Interface>(obj)->linear_to_physical(d_or_i, addr);
        }
        static void enter_acpi_c2_state(conf_object_t *obj) {
            detail::get_interface<X86Interface>(obj)->enter_acpi_c2_state();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void set_pin_status(x86_pin_t pin, int status) const {
            iface_->set_pin_status(obj_, pin, status);
        }
        void start_up(uint32 start_address) const {
            iface_->start_up(obj_, start_address);
        }
        int interrupt(int (*ack)(conf_object_t *obj), conf_object_t *data) const {
            return iface_->interrupt(obj_, ack, data);
        }
        void uninterrupt(int (*ack)(conf_object_t *obj)) const {
            iface_->uninterrupt(obj_, ack);
        }
        int has_pending_interrupt() const {
            return iface_->has_pending_interrupt(obj_);
        }
        int has_waiting_interrupt() const {
            return iface_->has_waiting_interrupt(obj_);
        }
        tagged_linear_address_t logical_to_linear(int segment, logical_address_t addr) const {
            return iface_->logical_to_linear(obj_, segment, addr);
        }
        physical_address_t linear_to_physical(data_or_instr_t d_or_i, linear_address_t addr) const {
            return iface_->linear_to_physical(obj_, d_or_i, addr);
        }
        void enter_acpi_c2_state() const {
            iface_->enter_acpi_c2_state(obj_);
        }

        const X86Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86Interface::ctype funcs {
                FromC::set_pin_status,
                FromC::start_up,
                FromC::interrupt,
                FromC::uninterrupt,
                FromC::has_pending_interrupt,
                FromC::has_waiting_interrupt,
                FromC::logical_to_linear,
                FromC::linear_to_physical,
                FromC::enter_acpi_c2_state,
            };
            return &funcs;
        }
    };
};

class X86CpuidInterface {
  public:
    using ctype = x86_cpuid_interface_t;

    // Function override and implemented by user
    virtual cpuid_ret_t cpuid(conf_object_t *cpu, uint32 in_eax, uint32 in_ebx, uint32 in_ecx, uint32 in_edx) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpuid_ret_t cpuid(conf_object_t *obj, conf_object_t *cpu, uint32 in_eax, uint32 in_ebx, uint32 in_ecx, uint32 in_edx) {
            return detail::get_interface<X86CpuidInterface>(obj)->cpuid(cpu, in_eax, in_ebx, in_ecx, in_edx);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86CpuidInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpuid_ret_t cpuid(conf_object_t *cpu, uint32 in_eax, uint32 in_ebx, uint32 in_ecx, uint32 in_edx) const {
            return iface_->cpuid(obj_, cpu, in_eax, in_ebx, in_ecx, in_edx);
        }

        const X86CpuidInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86CpuidInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_CPUID_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86CpuidInterface::ctype funcs {
                FromC::cpuid,
            };
            return &funcs;
        }
    };
};

class X86CpuidQueryInterface {
  public:
    using ctype = x86_cpuid_query_interface_t;

    // Function override and implemented by user
    virtual cpuid_value_t cpuid_query(uint32 leaf, uint32 subleaf) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpuid_value_t cpuid_query(conf_object_t *obj, uint32 leaf, uint32 subleaf) {
            return detail::get_interface<X86CpuidQueryInterface>(obj)->cpuid_query(leaf, subleaf);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86CpuidQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpuid_value_t cpuid_query(uint32 leaf, uint32 subleaf) const {
            return iface_->cpuid_query(obj_, leaf, subleaf);
        }

        const X86CpuidQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86CpuidQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_CPUID_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86CpuidQueryInterface::ctype funcs {
                FromC::cpuid_query,
            };
            return &funcs;
        }
    };
};

class ApicCpuInterface {
  public:
    using ctype = apic_cpu_interface_t;

    // Function override and implemented by user
    virtual uint64 tpr_r() = 0;
    virtual void tpr_w(uint64 tpr) = 0;
    virtual void local_int(local_apic_interrupt_t int_type) = 0;
    virtual void power_on(bool bsp, int apic_id) = 0;
    virtual void init() = 0;
    virtual bool enabled_r() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 tpr_r(conf_object_t *obj) {
            return detail::get_interface<ApicCpuInterface>(obj)->tpr_r();
        }
        static void tpr_w(conf_object_t *obj, uint64 tpr) {
            detail::get_interface<ApicCpuInterface>(obj)->tpr_w(tpr);
        }
        static void local_int(conf_object_t *obj, local_apic_interrupt_t int_type) {
            detail::get_interface<ApicCpuInterface>(obj)->local_int(int_type);
        }
        static void power_on(conf_object_t *obj, bool bsp, int apic_id) {
            detail::get_interface<ApicCpuInterface>(obj)->power_on(bsp, apic_id);
        }
        static void init(conf_object_t *obj) {
            detail::get_interface<ApicCpuInterface>(obj)->init();
        }
        static bool enabled_r(conf_object_t *obj) {
            return detail::get_interface<ApicCpuInterface>(obj)->enabled_r();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ApicCpuInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 tpr_r() const {
            return iface_->tpr_r(obj_);
        }
        void tpr_w(uint64 tpr) const {
            iface_->tpr_w(obj_, tpr);
        }
        void local_int(local_apic_interrupt_t int_type) const {
            iface_->local_int(obj_, int_type);
        }
        void power_on(bool bsp, int apic_id) const {
            iface_->power_on(obj_, bsp, apic_id);
        }
        void init() const {
            iface_->init(obj_);
        }
        bool enabled_r() const {
            return iface_->enabled_r(obj_);
        }

        const ApicCpuInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ApicCpuInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return APIC_CPU_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ApicCpuInterface::ctype funcs {
                FromC::tpr_r,
                FromC::tpr_w,
                FromC::local_int,
                FromC::power_on,
                FromC::init,
                FromC::enabled_r,
            };
            return &funcs;
        }
    };
};

class A20Interface {
  public:
    using ctype = a20_interface_t;

    // Function override and implemented by user
    virtual void set_a20_line(int value) = 0;
    virtual int get_a20_line() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void set_a20_line(conf_object_t *obj, int value) {
            detail::get_interface<A20Interface>(obj)->set_a20_line(value);
        }
        static int get_a20_line(conf_object_t *obj) {
            return detail::get_interface<A20Interface>(obj)->get_a20_line();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const A20Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void set_a20_line(int value) const {
            iface_->set_a20_line(obj_, value);
        }
        int get_a20_line() const {
            return iface_->get_a20_line(obj_);
        }

        const A20Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const A20Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return A20_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr A20Interface::ctype funcs {
                FromC::set_a20_line,
                FromC::get_a20_line,
            };
            return &funcs;
        }
    };
};

class X86MsrInterface {
  public:
    using ctype = x86_msr_interface_t;

    // Function override and implemented by user
    virtual void register_handlers(int64 number, x86_msr_getter_func_t getter, lang_void *getter_data, x86_msr_setter_func_t setter, lang_void *setter_data, const char *name) = 0;
    virtual void unregister_handlers(int64 number) = 0;
    virtual x86_msr_getter_ret_t get(int64 number, x86_msr_access_type_t type) = 0;
    virtual x86_msr_ret_t set(int64 number, uint64 value, x86_msr_access_type_t type) = 0;
    virtual const char * get_name(int64 number) = 0;
    virtual int64 get_number(const char *name) = 0;
    virtual attr_value_t get_all_valid_numbers() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void register_handlers(conf_object_t *cpu, int64 number, x86_msr_getter_func_t getter, lang_void *getter_data, x86_msr_setter_func_t setter, lang_void *setter_data, const char *name) {
            detail::get_interface<X86MsrInterface>(cpu)->register_handlers(number, getter, getter_data, setter, setter_data, name);
        }
        static void unregister_handlers(conf_object_t *cpu, int64 number) {
            detail::get_interface<X86MsrInterface>(cpu)->unregister_handlers(number);
        }
        static x86_msr_getter_ret_t get(conf_object_t *cpu, int64 number, x86_msr_access_type_t type) {
            return detail::get_interface<X86MsrInterface>(cpu)->get(number, type);
        }
        static x86_msr_ret_t set(conf_object_t *cpu, int64 number, uint64 value, x86_msr_access_type_t type) {
            return detail::get_interface<X86MsrInterface>(cpu)->set(number, value, type);
        }
        static const char * get_name(conf_object_t *cpu, int64 number) {
            return detail::get_interface<X86MsrInterface>(cpu)->get_name(number);
        }
        static int64 get_number(conf_object_t *cpu, const char *name) {
            return detail::get_interface<X86MsrInterface>(cpu)->get_number(name);
        }
        static attr_value_t get_all_valid_numbers(conf_object_t *cpu) {
            return detail::get_interface<X86MsrInterface>(cpu)->get_all_valid_numbers();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86MsrInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void register_handlers(int64 number, x86_msr_getter_func_t getter, lang_void *getter_data, x86_msr_setter_func_t setter, lang_void *setter_data, const char *name) const {
            iface_->register_handlers(obj_, number, getter, getter_data, setter, setter_data, name);
        }
        void unregister_handlers(int64 number) const {
            iface_->unregister_handlers(obj_, number);
        }
        x86_msr_getter_ret_t get(int64 number, x86_msr_access_type_t type) const {
            return iface_->get(obj_, number, type);
        }
        x86_msr_ret_t set(int64 number, uint64 value, x86_msr_access_type_t type) const {
            return iface_->set(obj_, number, value, type);
        }
        const char * get_name(int64 number) const {
            return iface_->get_name(obj_, number);
        }
        int64 get_number(const char *name) const {
            return iface_->get_number(obj_, name);
        }
        attr_value_t get_all_valid_numbers() const {
            return iface_->get_all_valid_numbers(obj_);
        }

        const X86MsrInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86MsrInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_MSR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86MsrInterface::ctype funcs {
                FromC::register_handlers,
                FromC::unregister_handlers,
                FromC::get,
                FromC::set,
                FromC::get_name,
                FromC::get_number,
                FromC::get_all_valid_numbers,
            };
            return &funcs;
        }
    };
};

class X86CacheFlushInterface {
  public:
    using ctype = x86_cache_flush_interface_t;

    // Function override and implemented by user
    virtual void flush(conf_object_t *cpu, bool writeback) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void flush(conf_object_t *obj, conf_object_t *cpu, bool writeback) {
            detail::get_interface<X86CacheFlushInterface>(obj)->flush(cpu, writeback);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86CacheFlushInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void flush(conf_object_t *cpu, bool writeback) const {
            iface_->flush(obj_, cpu, writeback);
        }

        const X86CacheFlushInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86CacheFlushInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_CACHE_FLUSH_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86CacheFlushInterface::ctype funcs {
                FromC::flush,
            };
            return &funcs;
        }
    };
};

class X86SmmStateInterface {
  public:
    using ctype = x86_smm_state_interface_t;

    // Function override and implemented by user
    virtual void get_state(smm_reg_state_t *state) = 0;
    virtual void set_state(const smm_reg_state_t *state) = 0;
    virtual uint64 smram_read(unsigned smram_offs, unsigned len) = 0;
    virtual void smram_write(unsigned smram_offs, unsigned len, uint64 val) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void get_state(conf_object_t *cpu, smm_reg_state_t *state) {
            detail::get_interface<X86SmmStateInterface>(cpu)->get_state(state);
        }
        static void set_state(conf_object_t *cpu, const smm_reg_state_t *state) {
            detail::get_interface<X86SmmStateInterface>(cpu)->set_state(state);
        }
        static uint64 smram_read(conf_object_t *obj, unsigned smram_offs, unsigned len) {
            return detail::get_interface<X86SmmStateInterface>(obj)->smram_read(smram_offs, len);
        }
        static void smram_write(conf_object_t *obj, unsigned smram_offs, unsigned len, uint64 val) {
            detail::get_interface<X86SmmStateInterface>(obj)->smram_write(smram_offs, len, val);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86SmmStateInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void get_state(smm_reg_state_t *state) const {
            iface_->get_state(obj_, state);
        }
        void set_state(const smm_reg_state_t *state) const {
            iface_->set_state(obj_, state);
        }
        uint64 smram_read(unsigned smram_offs, unsigned len) const {
            return iface_->smram_read(obj_, smram_offs, len);
        }
        void smram_write(unsigned smram_offs, unsigned len, uint64 val) const {
            iface_->smram_write(obj_, smram_offs, len, val);
        }

        const X86SmmStateInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86SmmStateInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_SMM_STATE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86SmmStateInterface::ctype funcs {
                FromC::get_state,
                FromC::set_state,
                FromC::smram_read,
                FromC::smram_write,
            };
            return &funcs;
        }
    };
};

class X86SmmInterface {
  public:
    using ctype = x86_smm_interface_t;

    // Function override and implemented by user
    virtual void save_state(conf_object_t *cpu) = 0;
    virtual void restore_state(conf_object_t *cpu) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void save_state(conf_object_t *obj, conf_object_t *cpu) {
            detail::get_interface<X86SmmInterface>(obj)->save_state(cpu);
        }
        static void restore_state(conf_object_t *obj, conf_object_t *cpu) {
            detail::get_interface<X86SmmInterface>(obj)->restore_state(cpu);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86SmmInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void save_state(conf_object_t *cpu) const {
            iface_->save_state(obj_, cpu);
        }
        void restore_state(conf_object_t *cpu) const {
            iface_->restore_state(obj_, cpu);
        }

        const X86SmmInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86SmmInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_SMM_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86SmmInterface::ctype funcs {
                FromC::save_state,
                FromC::restore_state,
            };
            return &funcs;
        }
    };
};

class X86RegAccessInterface {
  public:
    using ctype = x86_reg_access_interface_t;

    // Function override and implemented by user
    virtual uint64 get_gpr(unsigned index) = 0;
    virtual void set_gpr(unsigned index, uint64 val) = 0;
    virtual uint64 get_rip() = 0;
    virtual void set_rip(uint64 rip) = 0;
    virtual uint64 get_rflags() = 0;
    virtual void set_rflags(uint64 rflags) = 0;
    virtual void set_status_flags(uint16 flags) = 0;
    virtual x86_seg_reg_t get_seg(x86_seg_t n) = 0;
    virtual void set_seg(x86_seg_t n, x86_seg_reg_t seg) = 0;
    virtual x86_system_seg_reg_t get_system_seg(x86_system_seg_t n) = 0;
    virtual void set_system_seg(x86_system_seg_t n, x86_system_seg_reg_t seg) = 0;
    virtual uint64 get_cr(x86_cr_t n) = 0;
    virtual void set_cr(x86_cr_t n, uint64 val) = 0;
    virtual uint64 get_efer() = 0;
    virtual void set_efer(uint64 efer) = 0;
    virtual uint64 get_xcr(x86_xcr_t n) = 0;
    virtual void set_xcr(x86_xcr_t n, uint64 val) = 0;
    virtual x86_fpu_reg_t get_freg(unsigned index) = 0;
    virtual void set_freg(unsigned index, x86_fpu_reg_t freg) = 0;
    virtual x86_fpu_env_t get_fpu_env() = 0;
    virtual void set_fpu_env(x86_fpu_env_t state) = 0;
    virtual xmm_reg_t get_xmm(unsigned index) = 0;
    virtual void set_xmm(unsigned index, xmm_reg_t val) = 0;
    virtual ymm_reg_t get_ymm(unsigned index) = 0;
    virtual void set_ymm(unsigned index, ymm_reg_t val) = 0;
    virtual uint32 get_mxcsr() = 0;
    virtual void set_mxcsr(uint32 mxcsr) = 0;
    virtual uint64 get_dr(x86_dr_t n) = 0;
    virtual void set_dr(x86_dr_t n, uint64 val) = 0;
    virtual bool get_in_smm() = 0;
    virtual void set_in_smm(bool val) = 0;
    virtual uint64 get_smm_base() = 0;
    virtual void set_smm_base(uint64 val) = 0;
    virtual x86_monitor_info_t get_monitor_info() = 0;
    virtual void set_monitor_info(x86_monitor_info_t val) = 0;
    virtual x86_mwait_info_t get_mwait_info() = 0;
    virtual void set_mwait_info(x86_mwait_info_t val) = 0;
    virtual x86_activity_t get_activity_state() = 0;
    virtual void set_activity_state(x86_activity_t val) = 0;
    virtual x86_intstate_t get_interruptibility_state() = 0;
    virtual void set_interruptibility_state(x86_intstate_t val) = 0;
    virtual x86_pending_debug_exc_t get_pending_debug_exc() = 0;
    virtual void set_pending_debug_exc(x86_pending_debug_exc_t val) = 0;
    virtual x86_xmode_info_t get_xmode_info() = 0;
    virtual x86_exec_mode_t get_exec_mode() = 0;
    virtual uint32 get_mxcsr_mask() = 0;
    virtual uint64 get_ext_state_dirty_bits() = 0;
    virtual void or_ext_state_dirty_bits(uint64 dirty_bits) = 0;
    virtual void and_ext_state_dirty_bits(uint64 dirty_bits) = 0;
    virtual uint64 get_pdpte(int num) = 0;
    virtual void set_pdpte(int num, uint64 val) = 0;
    virtual uint32 get_vmx_mode() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 get_gpr(conf_object_t *cpu, unsigned index) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_gpr(index);
        }
        static void set_gpr(conf_object_t *cpu, unsigned index, uint64 val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_gpr(index, val);
        }
        static uint64 get_rip(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_rip();
        }
        static void set_rip(conf_object_t *cpu, uint64 rip) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_rip(rip);
        }
        static uint64 get_rflags(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_rflags();
        }
        static void set_rflags(conf_object_t *cpu, uint64 rflags) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_rflags(rflags);
        }
        static void set_status_flags(conf_object_t *cpu, uint16 flags) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_status_flags(flags);
        }
        static x86_seg_reg_t get_seg(conf_object_t *cpu, x86_seg_t n) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_seg(n);
        }
        static void set_seg(conf_object_t *cpu, x86_seg_t n, x86_seg_reg_t seg) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_seg(n, seg);
        }
        static x86_system_seg_reg_t get_system_seg(conf_object_t *cpu, x86_system_seg_t n) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_system_seg(n);
        }
        static void set_system_seg(conf_object_t *cpu, x86_system_seg_t n, x86_system_seg_reg_t seg) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_system_seg(n, seg);
        }
        static uint64 get_cr(conf_object_t *cpu, x86_cr_t n) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_cr(n);
        }
        static void set_cr(conf_object_t *cpu, x86_cr_t n, uint64 val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_cr(n, val);
        }
        static uint64 get_efer(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_efer();
        }
        static void set_efer(conf_object_t *cpu, uint64 efer) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_efer(efer);
        }
        static uint64 get_xcr(conf_object_t *cpu, x86_xcr_t n) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_xcr(n);
        }
        static void set_xcr(conf_object_t *cpu, x86_xcr_t n, uint64 val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_xcr(n, val);
        }
        static x86_fpu_reg_t get_freg(conf_object_t *cpu, unsigned index) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_freg(index);
        }
        static void set_freg(conf_object_t *cpu, unsigned index, x86_fpu_reg_t freg) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_freg(index, freg);
        }
        static x86_fpu_env_t get_fpu_env(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_fpu_env();
        }
        static void set_fpu_env(conf_object_t *cpu, x86_fpu_env_t state) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_fpu_env(state);
        }
        static xmm_reg_t get_xmm(conf_object_t *cpu, unsigned index) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_xmm(index);
        }
        static void set_xmm(conf_object_t *cpu, unsigned index, xmm_reg_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_xmm(index, val);
        }
        static ymm_reg_t get_ymm(conf_object_t *cpu, unsigned index) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_ymm(index);
        }
        static void set_ymm(conf_object_t *cpu, unsigned index, ymm_reg_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_ymm(index, val);
        }
        static uint32 get_mxcsr(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_mxcsr();
        }
        static void set_mxcsr(conf_object_t *cpu, uint32 mxcsr) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_mxcsr(mxcsr);
        }
        static uint64 get_dr(conf_object_t *cpu, x86_dr_t n) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_dr(n);
        }
        static void set_dr(conf_object_t *cpu, x86_dr_t n, uint64 val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_dr(n, val);
        }
        static bool get_in_smm(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_in_smm();
        }
        static void set_in_smm(conf_object_t *cpu, bool val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_in_smm(val);
        }
        static uint64 get_smm_base(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_smm_base();
        }
        static void set_smm_base(conf_object_t *cpu, uint64 val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_smm_base(val);
        }
        static x86_monitor_info_t get_monitor_info(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_monitor_info();
        }
        static void set_monitor_info(conf_object_t *cpu, x86_monitor_info_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_monitor_info(val);
        }
        static x86_mwait_info_t get_mwait_info(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_mwait_info();
        }
        static void set_mwait_info(conf_object_t *cpu, x86_mwait_info_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_mwait_info(val);
        }
        static x86_activity_t get_activity_state(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_activity_state();
        }
        static void set_activity_state(conf_object_t *cpu, x86_activity_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_activity_state(val);
        }
        static x86_intstate_t get_interruptibility_state(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_interruptibility_state();
        }
        static void set_interruptibility_state(conf_object_t *cpu, x86_intstate_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_interruptibility_state(val);
        }
        static x86_pending_debug_exc_t get_pending_debug_exc(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_pending_debug_exc();
        }
        static void set_pending_debug_exc(conf_object_t *cpu, x86_pending_debug_exc_t val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_pending_debug_exc(val);
        }
        static x86_xmode_info_t get_xmode_info(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_xmode_info();
        }
        static x86_exec_mode_t get_exec_mode(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_exec_mode();
        }
        static uint32 get_mxcsr_mask(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_mxcsr_mask();
        }
        static uint64 get_ext_state_dirty_bits(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_ext_state_dirty_bits();
        }
        static void or_ext_state_dirty_bits(conf_object_t *cpu, uint64 dirty_bits) {
            detail::get_interface<X86RegAccessInterface>(cpu)->or_ext_state_dirty_bits(dirty_bits);
        }
        static void and_ext_state_dirty_bits(conf_object_t *cpu, uint64 dirty_bits) {
            detail::get_interface<X86RegAccessInterface>(cpu)->and_ext_state_dirty_bits(dirty_bits);
        }
        static uint64 get_pdpte(conf_object_t *cpu, int num) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_pdpte(num);
        }
        static void set_pdpte(conf_object_t *cpu, int num, uint64 val) {
            detail::get_interface<X86RegAccessInterface>(cpu)->set_pdpte(num, val);
        }
        static uint32 get_vmx_mode(conf_object_t *cpu) {
            return detail::get_interface<X86RegAccessInterface>(cpu)->get_vmx_mode();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86RegAccessInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 get_gpr(unsigned index) const {
            return iface_->get_gpr(obj_, index);
        }
        void set_gpr(unsigned index, uint64 val) const {
            iface_->set_gpr(obj_, index, val);
        }
        uint64 get_rip() const {
            return iface_->get_rip(obj_);
        }
        void set_rip(uint64 rip) const {
            iface_->set_rip(obj_, rip);
        }
        uint64 get_rflags() const {
            return iface_->get_rflags(obj_);
        }
        void set_rflags(uint64 rflags) const {
            iface_->set_rflags(obj_, rflags);
        }
        void set_status_flags(uint16 flags) const {
            iface_->set_status_flags(obj_, flags);
        }
        x86_seg_reg_t get_seg(x86_seg_t n) const {
            return iface_->get_seg(obj_, n);
        }
        void set_seg(x86_seg_t n, x86_seg_reg_t seg) const {
            iface_->set_seg(obj_, n, seg);
        }
        x86_system_seg_reg_t get_system_seg(x86_system_seg_t n) const {
            return iface_->get_system_seg(obj_, n);
        }
        void set_system_seg(x86_system_seg_t n, x86_system_seg_reg_t seg) const {
            iface_->set_system_seg(obj_, n, seg);
        }
        uint64 get_cr(x86_cr_t n) const {
            return iface_->get_cr(obj_, n);
        }
        void set_cr(x86_cr_t n, uint64 val) const {
            iface_->set_cr(obj_, n, val);
        }
        uint64 get_efer() const {
            return iface_->get_efer(obj_);
        }
        void set_efer(uint64 efer) const {
            iface_->set_efer(obj_, efer);
        }
        uint64 get_xcr(x86_xcr_t n) const {
            return iface_->get_xcr(obj_, n);
        }
        void set_xcr(x86_xcr_t n, uint64 val) const {
            iface_->set_xcr(obj_, n, val);
        }
        x86_fpu_reg_t get_freg(unsigned index) const {
            return iface_->get_freg(obj_, index);
        }
        void set_freg(unsigned index, x86_fpu_reg_t freg) const {
            iface_->set_freg(obj_, index, freg);
        }
        x86_fpu_env_t get_fpu_env() const {
            return iface_->get_fpu_env(obj_);
        }
        void set_fpu_env(x86_fpu_env_t state) const {
            iface_->set_fpu_env(obj_, state);
        }
        xmm_reg_t get_xmm(unsigned index) const {
            return iface_->get_xmm(obj_, index);
        }
        void set_xmm(unsigned index, xmm_reg_t val) const {
            iface_->set_xmm(obj_, index, val);
        }
        ymm_reg_t get_ymm(unsigned index) const {
            return iface_->get_ymm(obj_, index);
        }
        void set_ymm(unsigned index, ymm_reg_t val) const {
            iface_->set_ymm(obj_, index, val);
        }
        uint32 get_mxcsr() const {
            return iface_->get_mxcsr(obj_);
        }
        void set_mxcsr(uint32 mxcsr) const {
            iface_->set_mxcsr(obj_, mxcsr);
        }
        uint64 get_dr(x86_dr_t n) const {
            return iface_->get_dr(obj_, n);
        }
        void set_dr(x86_dr_t n, uint64 val) const {
            iface_->set_dr(obj_, n, val);
        }
        bool get_in_smm() const {
            return iface_->get_in_smm(obj_);
        }
        void set_in_smm(bool val) const {
            iface_->set_in_smm(obj_, val);
        }
        uint64 get_smm_base() const {
            return iface_->get_smm_base(obj_);
        }
        void set_smm_base(uint64 val) const {
            iface_->set_smm_base(obj_, val);
        }
        x86_monitor_info_t get_monitor_info() const {
            return iface_->get_monitor_info(obj_);
        }
        void set_monitor_info(x86_monitor_info_t val) const {
            iface_->set_monitor_info(obj_, val);
        }
        x86_mwait_info_t get_mwait_info() const {
            return iface_->get_mwait_info(obj_);
        }
        void set_mwait_info(x86_mwait_info_t val) const {
            iface_->set_mwait_info(obj_, val);
        }
        x86_activity_t get_activity_state() const {
            return iface_->get_activity_state(obj_);
        }
        void set_activity_state(x86_activity_t val) const {
            iface_->set_activity_state(obj_, val);
        }
        x86_intstate_t get_interruptibility_state() const {
            return iface_->get_interruptibility_state(obj_);
        }
        void set_interruptibility_state(x86_intstate_t val) const {
            iface_->set_interruptibility_state(obj_, val);
        }
        x86_pending_debug_exc_t get_pending_debug_exc() const {
            return iface_->get_pending_debug_exc(obj_);
        }
        void set_pending_debug_exc(x86_pending_debug_exc_t val) const {
            iface_->set_pending_debug_exc(obj_, val);
        }
        x86_xmode_info_t get_xmode_info() const {
            return iface_->get_xmode_info(obj_);
        }
        x86_exec_mode_t get_exec_mode() const {
            return iface_->get_exec_mode(obj_);
        }
        uint32 get_mxcsr_mask() const {
            return iface_->get_mxcsr_mask(obj_);
        }
        uint64 get_ext_state_dirty_bits() const {
            return iface_->get_ext_state_dirty_bits(obj_);
        }
        void or_ext_state_dirty_bits(uint64 dirty_bits) const {
            iface_->or_ext_state_dirty_bits(obj_, dirty_bits);
        }
        void and_ext_state_dirty_bits(uint64 dirty_bits) const {
            iface_->and_ext_state_dirty_bits(obj_, dirty_bits);
        }
        uint64 get_pdpte(int num) const {
            return iface_->get_pdpte(obj_, num);
        }
        void set_pdpte(int num, uint64 val) const {
            iface_->set_pdpte(obj_, num, val);
        }
        uint32 get_vmx_mode() const {
            return iface_->get_vmx_mode(obj_);
        }

        const X86RegAccessInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86RegAccessInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_REG_ACCESS_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86RegAccessInterface::ctype funcs {
                FromC::get_gpr,
                FromC::set_gpr,
                FromC::get_rip,
                FromC::set_rip,
                FromC::get_rflags,
                FromC::set_rflags,
                FromC::set_status_flags,
                FromC::get_seg,
                FromC::set_seg,
                FromC::get_system_seg,
                FromC::set_system_seg,
                FromC::get_cr,
                FromC::set_cr,
                FromC::get_efer,
                FromC::set_efer,
                FromC::get_xcr,
                FromC::set_xcr,
                FromC::get_freg,
                FromC::set_freg,
                FromC::get_fpu_env,
                FromC::set_fpu_env,
                FromC::get_xmm,
                FromC::set_xmm,
                FromC::get_ymm,
                FromC::set_ymm,
                FromC::get_mxcsr,
                FromC::set_mxcsr,
                FromC::get_dr,
                FromC::set_dr,
                FromC::get_in_smm,
                FromC::set_in_smm,
                FromC::get_smm_base,
                FromC::set_smm_base,
                FromC::get_monitor_info,
                FromC::set_monitor_info,
                FromC::get_mwait_info,
                FromC::set_mwait_info,
                FromC::get_activity_state,
                FromC::set_activity_state,
                FromC::get_interruptibility_state,
                FromC::set_interruptibility_state,
                FromC::get_pending_debug_exc,
                FromC::set_pending_debug_exc,
                FromC::get_xmode_info,
                FromC::get_exec_mode,
                FromC::get_mxcsr_mask,
                FromC::get_ext_state_dirty_bits,
                FromC::or_ext_state_dirty_bits,
                FromC::and_ext_state_dirty_bits,
                FromC::get_pdpte,
                FromC::set_pdpte,
                FromC::get_vmx_mode,
            };
            return &funcs;
        }
    };
};

class X86ExceptionInterface {
  public:
    using ctype = x86_exception_interface_t;

    // Function override and implemented by user
    virtual void DE_fault() = 0;
    virtual void BR_fault() = 0;
    virtual void UD_fault() = 0;
    virtual void NM_fault() = 0;
    virtual void DF_abort(const char *desc) = 0;
    virtual void TS_fault(uint16 sel) = 0;
    virtual void NP_fault(uint16 sel_vec, bool is_vec) = 0;
    virtual void SS_fault(uint16 sel) = 0;
    virtual void GP_fault(uint16 sel_vec, bool is_vec, const char *desc) = 0;
    virtual void PF_fault(linear_address_t laddr, uint32 ecode) = 0;
    virtual void MF_fault() = 0;
    virtual void AC_fault() = 0;
    virtual void XM_fault() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void DE_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->DE_fault();
        }
        static void BR_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->BR_fault();
        }
        static void UD_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->UD_fault();
        }
        static void NM_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->NM_fault();
        }
        static void DF_abort(conf_object_t *cpu, const char *desc) {
            detail::get_interface<X86ExceptionInterface>(cpu)->DF_abort(desc);
        }
        static void TS_fault(conf_object_t *cpu, uint16 sel) {
            detail::get_interface<X86ExceptionInterface>(cpu)->TS_fault(sel);
        }
        static void NP_fault(conf_object_t *cpu, uint16 sel_vec, bool is_vec) {
            detail::get_interface<X86ExceptionInterface>(cpu)->NP_fault(sel_vec, is_vec);
        }
        static void SS_fault(conf_object_t *cpu, uint16 sel) {
            detail::get_interface<X86ExceptionInterface>(cpu)->SS_fault(sel);
        }
        static void GP_fault(conf_object_t *cpu, uint16 sel_vec, bool is_vec, const char *desc) {
            detail::get_interface<X86ExceptionInterface>(cpu)->GP_fault(sel_vec, is_vec, desc);
        }
        static void PF_fault(conf_object_t *cpu, linear_address_t laddr, uint32 ecode) {
            detail::get_interface<X86ExceptionInterface>(cpu)->PF_fault(laddr, ecode);
        }
        static void MF_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->MF_fault();
        }
        static void AC_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->AC_fault();
        }
        static void XM_fault(conf_object_t *cpu) {
            detail::get_interface<X86ExceptionInterface>(cpu)->XM_fault();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86ExceptionInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void DE_fault() const {
            iface_->DE_fault(obj_);
        }
        void BR_fault() const {
            iface_->BR_fault(obj_);
        }
        void UD_fault() const {
            iface_->UD_fault(obj_);
        }
        void NM_fault() const {
            iface_->NM_fault(obj_);
        }
        void DF_abort(const char *desc) const {
            iface_->DF_abort(obj_, desc);
        }
        void TS_fault(uint16 sel) const {
            iface_->TS_fault(obj_, sel);
        }
        void NP_fault(uint16 sel_vec, bool is_vec) const {
            iface_->NP_fault(obj_, sel_vec, is_vec);
        }
        void SS_fault(uint16 sel) const {
            iface_->SS_fault(obj_, sel);
        }
        void GP_fault(uint16 sel_vec, bool is_vec, const char *desc) const {
            iface_->GP_fault(obj_, sel_vec, is_vec, desc);
        }
        void PF_fault(linear_address_t laddr, uint32 ecode) const {
            iface_->PF_fault(obj_, laddr, ecode);
        }
        void MF_fault() const {
            iface_->MF_fault(obj_);
        }
        void AC_fault() const {
            iface_->AC_fault(obj_);
        }
        void XM_fault() const {
            iface_->XM_fault(obj_);
        }

        const X86ExceptionInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86ExceptionInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_EXCEPTION_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86ExceptionInterface::ctype funcs {
                FromC::DE_fault,
                FromC::BR_fault,
                FromC::UD_fault,
                FromC::NM_fault,
                FromC::DF_abort,
                FromC::TS_fault,
                FromC::NP_fault,
                FromC::SS_fault,
                FromC::GP_fault,
                FromC::PF_fault,
                FromC::MF_fault,
                FromC::AC_fault,
                FromC::XM_fault,
            };
            return &funcs;
        }
    };
};

class X86MemoryAccessInterface {
  public:
    using ctype = x86_memory_access_interface_t;

    // Function override and implemented by user
    virtual uint64 read_logical(logical_address_t offs, x86_seg_t seg, unsigned len, x86_processor_mode_t mode, x86_access_type_t access_type) = 0;
    virtual void read_logical_buf(logical_address_t offs, x86_seg_t seg, unsigned len, void *p, x86_processor_mode_t mode, x86_access_type_t access_type, x86_alignment_t alignment) = 0;
    virtual void write_logical(logical_address_t offs, x86_seg_t seg, unsigned len, uint64 val, x86_processor_mode_t mode, x86_access_type_t access_type) = 0;
    virtual void write_logical_buf(logical_address_t offs, x86_seg_t seg, unsigned len, const void *p, x86_processor_mode_t mode, x86_access_type_t access_type, x86_alignment_t alignment) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 read_logical(conf_object_t *cpu, logical_address_t offs, x86_seg_t seg, unsigned len, x86_processor_mode_t mode, x86_access_type_t access_type) {
            return detail::get_interface<X86MemoryAccessInterface>(cpu)->read_logical(offs, seg, len, mode, access_type);
        }
        static void read_logical_buf(conf_object_t *cpu, logical_address_t offs, x86_seg_t seg, unsigned len, void *p, x86_processor_mode_t mode, x86_access_type_t access_type, x86_alignment_t alignment) {
            detail::get_interface<X86MemoryAccessInterface>(cpu)->read_logical_buf(offs, seg, len, p, mode, access_type, alignment);
        }
        static void write_logical(conf_object_t *cpu, logical_address_t offs, x86_seg_t seg, unsigned len, uint64 val, x86_processor_mode_t mode, x86_access_type_t access_type) {
            detail::get_interface<X86MemoryAccessInterface>(cpu)->write_logical(offs, seg, len, val, mode, access_type);
        }
        static void write_logical_buf(conf_object_t *cpu, logical_address_t offs, x86_seg_t seg, unsigned len, const void *p, x86_processor_mode_t mode, x86_access_type_t access_type, x86_alignment_t alignment) {
            detail::get_interface<X86MemoryAccessInterface>(cpu)->write_logical_buf(offs, seg, len, p, mode, access_type, alignment);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86MemoryAccessInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 read_logical(logical_address_t offs, x86_seg_t seg, unsigned len, x86_processor_mode_t mode, x86_access_type_t access_type) const {
            return iface_->read_logical(obj_, offs, seg, len, mode, access_type);
        }
        void read_logical_buf(logical_address_t offs, x86_seg_t seg, unsigned len, void *p, x86_processor_mode_t mode, x86_access_type_t access_type, x86_alignment_t alignment) const {
            iface_->read_logical_buf(obj_, offs, seg, len, p, mode, access_type, alignment);
        }
        void write_logical(logical_address_t offs, x86_seg_t seg, unsigned len, uint64 val, x86_processor_mode_t mode, x86_access_type_t access_type) const {
            iface_->write_logical(obj_, offs, seg, len, val, mode, access_type);
        }
        void write_logical_buf(logical_address_t offs, x86_seg_t seg, unsigned len, const void *p, x86_processor_mode_t mode, x86_access_type_t access_type, x86_alignment_t alignment) const {
            iface_->write_logical_buf(obj_, offs, seg, len, p, mode, access_type, alignment);
        }

        const X86MemoryAccessInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86MemoryAccessInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_MEMORY_ACCESS_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86MemoryAccessInterface::ctype funcs {
                FromC::read_logical,
                FromC::read_logical_buf,
                FromC::write_logical,
                FromC::write_logical_buf,
            };
            return &funcs;
        }
    };
};

class X86MemoryOperationInterface {
  public:
    using ctype = x86_memory_operation_interface_t;

    // Function override and implemented by user
    virtual uint64 read_logical(x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) = 0;
    virtual void read_logical_buf(uint8 *dst, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) = 0;
    virtual void write_logical(uint64 val, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) = 0;
    virtual void write_logical_buf(const uint8 *src, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) = 0;
    virtual x86_read_physical_ret_t read_physical(physical_address_t address, unsigned size, x86_access_type_t access_type) = 0;
    virtual exception_type_t read_physical_buf(uint8 *dst, physical_address_t address, unsigned size, x86_access_type_t access_type) = 0;
    virtual exception_type_t write_physical(uint64 val, physical_address_t address, unsigned size, x86_access_type_t access_type) = 0;
    virtual exception_type_t write_physical_buf(const uint8 *src, physical_address_t address, unsigned size, x86_access_type_t access_type) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 read_logical(conf_object_t *cpu, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) {
            return detail::get_interface<X86MemoryOperationInterface>(cpu)->read_logical(seg, offs, size, mode, access_type);
        }
        static void read_logical_buf(conf_object_t *cpu, uint8 *dst, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) {
            detail::get_interface<X86MemoryOperationInterface>(cpu)->read_logical_buf(dst, seg, offs, size, mode, access_type);
        }
        static void write_logical(conf_object_t *cpu, uint64 val, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) {
            detail::get_interface<X86MemoryOperationInterface>(cpu)->write_logical(val, seg, offs, size, mode, access_type);
        }
        static void write_logical_buf(conf_object_t *cpu, const uint8 *src, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) {
            detail::get_interface<X86MemoryOperationInterface>(cpu)->write_logical_buf(src, seg, offs, size, mode, access_type);
        }
        static x86_read_physical_ret_t read_physical(conf_object_t *cpu, physical_address_t address, unsigned size, x86_access_type_t access_type) {
            return detail::get_interface<X86MemoryOperationInterface>(cpu)->read_physical(address, size, access_type);
        }
        static exception_type_t read_physical_buf(conf_object_t *cpu, uint8 *dst, physical_address_t address, unsigned size, x86_access_type_t access_type) {
            return detail::get_interface<X86MemoryOperationInterface>(cpu)->read_physical_buf(dst, address, size, access_type);
        }
        static exception_type_t write_physical(conf_object_t *cpu, uint64 val, physical_address_t address, unsigned size, x86_access_type_t access_type) {
            return detail::get_interface<X86MemoryOperationInterface>(cpu)->write_physical(val, address, size, access_type);
        }
        static exception_type_t write_physical_buf(conf_object_t *cpu, const uint8 *src, physical_address_t address, unsigned size, x86_access_type_t access_type) {
            return detail::get_interface<X86MemoryOperationInterface>(cpu)->write_physical_buf(src, address, size, access_type);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86MemoryOperationInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 read_logical(x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) const {
            return iface_->read_logical(obj_, seg, offs, size, mode, access_type);
        }
        void read_logical_buf(uint8 *dst, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) const {
            iface_->read_logical_buf(obj_, dst, seg, offs, size, mode, access_type);
        }
        void write_logical(uint64 val, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) const {
            iface_->write_logical(obj_, val, seg, offs, size, mode, access_type);
        }
        void write_logical_buf(const uint8 *src, x86_seg_t seg, logical_address_t offs, unsigned size, x86_processor_mode_t mode, x86_access_type_t access_type) const {
            iface_->write_logical_buf(obj_, src, seg, offs, size, mode, access_type);
        }
        x86_read_physical_ret_t read_physical(physical_address_t address, unsigned size, x86_access_type_t access_type) const {
            return iface_->read_physical(obj_, address, size, access_type);
        }
        exception_type_t read_physical_buf(uint8 *dst, physical_address_t address, unsigned size, x86_access_type_t access_type) const {
            return iface_->read_physical_buf(obj_, dst, address, size, access_type);
        }
        exception_type_t write_physical(uint64 val, physical_address_t address, unsigned size, x86_access_type_t access_type) const {
            return iface_->write_physical(obj_, val, address, size, access_type);
        }
        exception_type_t write_physical_buf(const uint8 *src, physical_address_t address, unsigned size, x86_access_type_t access_type) const {
            return iface_->write_physical_buf(obj_, src, address, size, access_type);
        }

        const X86MemoryOperationInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86MemoryOperationInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_MEMORY_OPERATION_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86MemoryOperationInterface::ctype funcs {
                FromC::read_logical,
                FromC::read_logical_buf,
                FromC::write_logical,
                FromC::write_logical_buf,
                FromC::read_physical,
                FromC::read_physical_buf,
                FromC::write_physical,
                FromC::write_physical_buf,
            };
            return &funcs;
        }
    };
};

class X86VmpControlInterface {
  public:
    using ctype = x86_vmp_control_interface_t;

    // Function override and implemented by user
    virtual unsigned get_block_count() = 0;
    virtual void set_block_count(unsigned cnt) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static unsigned get_block_count(conf_object_t *cpu) {
            return detail::get_interface<X86VmpControlInterface>(cpu)->get_block_count();
        }
        static void set_block_count(conf_object_t *cpu, unsigned cnt) {
            detail::get_interface<X86VmpControlInterface>(cpu)->set_block_count(cnt);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86VmpControlInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        unsigned get_block_count() const {
            return iface_->get_block_count(obj_);
        }
        void set_block_count(unsigned cnt) const {
            iface_->set_block_count(obj_, cnt);
        }

        const X86VmpControlInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86VmpControlInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_VMP_CONTROL_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86VmpControlInterface::ctype funcs {
                FromC::get_block_count,
                FromC::set_block_count,
            };
            return &funcs;
        }
    };
};

class VmpInterface {
  public:
    using ctype = vmp_interface_t;

    // Function override and implemented by user
    virtual bool class_has_support() = 0;
    virtual bool host_support() = 0;
    virtual bool compatible_config() = 0;
    virtual bool enable() = 0;
    virtual void disable() = 0;
    virtual bool enabled() = 0;
    virtual void set_threshold(int threshold) = 0;
    virtual bool get_feature(vmp_feature_t feature) = 0;
    virtual bool set_feature(vmp_feature_t feature, bool val) = 0;
    virtual uint64 get_info(vmp_info_t info) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static bool class_has_support(conf_object_t *obj) {
            return detail::get_interface<VmpInterface>(obj)->class_has_support();
        }
        static bool host_support(conf_object_t *obj) {
            return detail::get_interface<VmpInterface>(obj)->host_support();
        }
        static bool compatible_config(conf_object_t *obj) {
            return detail::get_interface<VmpInterface>(obj)->compatible_config();
        }
        static bool enable(conf_object_t *obj) {
            return detail::get_interface<VmpInterface>(obj)->enable();
        }
        static void disable(conf_object_t *obj) {
            detail::get_interface<VmpInterface>(obj)->disable();
        }
        static bool enabled(conf_object_t *obj) {
            return detail::get_interface<VmpInterface>(obj)->enabled();
        }
        static void set_threshold(conf_object_t *obj, int threshold) {
            detail::get_interface<VmpInterface>(obj)->set_threshold(threshold);
        }
        static bool get_feature(conf_object_t *obj, vmp_feature_t feature) {
            return detail::get_interface<VmpInterface>(obj)->get_feature(feature);
        }
        static bool set_feature(conf_object_t *obj, vmp_feature_t feature, bool val) {
            return detail::get_interface<VmpInterface>(obj)->set_feature(feature, val);
        }
        static uint64 get_info(conf_object_t *obj, vmp_info_t info) {
            return detail::get_interface<VmpInterface>(obj)->get_info(info);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const VmpInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        bool class_has_support() const {
            return iface_->class_has_support(obj_);
        }
        bool host_support() const {
            return iface_->host_support(obj_);
        }
        bool compatible_config() const {
            return iface_->compatible_config(obj_);
        }
        bool enable() const {
            return iface_->enable(obj_);
        }
        void disable() const {
            iface_->disable(obj_);
        }
        bool enabled() const {
            return iface_->enabled(obj_);
        }
        void set_threshold(int threshold) const {
            iface_->set_threshold(obj_, threshold);
        }
        bool get_feature(vmp_feature_t feature) const {
            return iface_->get_feature(obj_, feature);
        }
        bool set_feature(vmp_feature_t feature, bool val) const {
            return iface_->set_feature(obj_, feature, val);
        }
        uint64 get_info(vmp_info_t info) const {
            return iface_->get_info(obj_, info);
        }

        const VmpInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const VmpInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return VMP_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr VmpInterface::ctype funcs {
                FromC::class_has_support,
                FromC::host_support,
                FromC::compatible_config,
                FromC::enable,
                FromC::disable,
                FromC::enabled,
                FromC::set_threshold,
                FromC::get_feature,
                FromC::set_feature,
                FromC::get_info,
            };
            return &funcs;
        }
    };
};

class XedAccessInterface {
  public:
    using ctype = xed_access_interface_t;

    // Function override and implemented by user
    virtual int get_last(xed_data_type_t type) = 0;
    virtual int decode(xed_data_type_t type, bytes_t bytes) = 0;
    virtual const char * to_string(xed_data_type_t type, int value) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static int get_last(conf_object_t *obj, xed_data_type_t type) {
            return detail::get_interface<XedAccessInterface>(obj)->get_last(type);
        }
        static int decode(conf_object_t *obj, xed_data_type_t type, bytes_t bytes) {
            return detail::get_interface<XedAccessInterface>(obj)->decode(type, bytes);
        }
        static const char * to_string(conf_object_t *obj, xed_data_type_t type, int value) {
            return detail::get_interface<XedAccessInterface>(obj)->to_string(type, value);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const XedAccessInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        int get_last(xed_data_type_t type) const {
            return iface_->get_last(obj_, type);
        }
        int decode(xed_data_type_t type, bytes_t bytes) const {
            return iface_->decode(obj_, type, bytes);
        }
        const char * to_string(xed_data_type_t type, int value) const {
            return iface_->to_string(obj_, type, value);
        }

        const XedAccessInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const XedAccessInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return XED_ACCESS_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr XedAccessInterface::ctype funcs {
                FromC::get_last,
                FromC::decode,
                FromC::to_string,
            };
            return &funcs;
        }
    };
};

class X86EptInterface {
  public:
    using ctype = x86_ept_interface_t;

    // Function override and implemented by user
    virtual physical_block_t guest_physical_to_physical(generic_address_t address, x86_processor_mode_t cpu_mode, access_t access) = 0;
    virtual bool is_ept_active() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static physical_block_t guest_physical_to_physical(conf_object_t *obj, generic_address_t address, x86_processor_mode_t cpu_mode, access_t access) {
            return detail::get_interface<X86EptInterface>(obj)->guest_physical_to_physical(address, cpu_mode, access);
        }
        static bool is_ept_active(conf_object_t* obj) {
            return detail::get_interface<X86EptInterface>(obj)->is_ept_active();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const X86EptInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        physical_block_t guest_physical_to_physical(generic_address_t address, x86_processor_mode_t cpu_mode, access_t access) const {
            return iface_->guest_physical_to_physical(obj_, address, cpu_mode, access);
        }
        bool is_ept_active() const {
            return iface_->is_ept_active(obj_);
        }

        const X86EptInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const X86EptInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return X86_EPT_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr X86EptInterface::ctype funcs {
                FromC::guest_physical_to_physical,
                FromC::is_ept_active,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
