// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_CYCLE_H
#define SIMICS_CPP_MODEL_IFACE_CYCLE_H

#include "simics/model-iface/cycle.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class CycleInterface {
  public:
    using ctype = cycle_interface_t;

    // Function override and implemented by user
    virtual cycles_t get_cycle_count() = 0;
    virtual double get_time() = 0;
    virtual cycles_t cycles_delta(double when) = 0;
    virtual uint64 get_frequency() = 0;
    virtual void post_cycle(event_class_t *evclass, conf_object_t *obj, cycles_t cycles, lang_void *user_data) = 0;
    virtual void post_time(event_class_t *evclass, conf_object_t *obj, double seconds, lang_void *user_data) = 0;
    virtual void cancel(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) = 0;
    virtual cycles_t find_next_cycle(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) = 0;
    virtual double find_next_time(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) = 0;
    virtual attr_value_t events() = 0;
    virtual local_time_t get_time_in_ps() = 0;
    virtual cycles_t cycles_delta_from_ps(local_time_t when) = 0;
    virtual void post_time_in_ps(event_class_t *evclass, conf_object_t *obj, duration_t picoseconds, lang_void *user_data) = 0;
    virtual duration_t find_next_time_in_ps(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cycles_t get_cycle_count(conf_object_t *queue) {
            return detail::get_interface<CycleInterface>(queue)->get_cycle_count();
        }
        static double get_time(conf_object_t *queue) {
            return detail::get_interface<CycleInterface>(queue)->get_time();
        }
        static cycles_t cycles_delta(conf_object_t *clock, double when) {
            return detail::get_interface<CycleInterface>(clock)->cycles_delta(when);
        }
        static uint64 get_frequency(conf_object_t *queue) {
            return detail::get_interface<CycleInterface>(queue)->get_frequency();
        }
        static void post_cycle(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, cycles_t cycles, lang_void *user_data) {
            detail::get_interface<CycleInterface>(queue)->post_cycle(evclass, obj, cycles, user_data);
        }
        static void post_time(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, double seconds, lang_void *user_data) {
            detail::get_interface<CycleInterface>(queue)->post_time(evclass, obj, seconds, user_data);
        }
        static void cancel(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) {
            detail::get_interface<CycleInterface>(queue)->cancel(evclass, obj, pred, match_data);
        }
        static cycles_t find_next_cycle(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) {
            return detail::get_interface<CycleInterface>(queue)->find_next_cycle(evclass, obj, pred, match_data);
        }
        static double find_next_time(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) {
            return detail::get_interface<CycleInterface>(queue)->find_next_time(evclass, obj, pred, match_data);
        }
        static attr_value_t events(conf_object_t *obj) {
            return detail::get_interface<CycleInterface>(obj)->events();
        }
        static local_time_t get_time_in_ps(conf_object_t *queue) {
            return detail::get_interface<CycleInterface>(queue)->get_time_in_ps();
        }
        static cycles_t cycles_delta_from_ps(conf_object_t *clock, local_time_t when) {
            return detail::get_interface<CycleInterface>(clock)->cycles_delta_from_ps(when);
        }
        static void post_time_in_ps(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, duration_t picoseconds, lang_void *user_data) {
            detail::get_interface<CycleInterface>(queue)->post_time_in_ps(evclass, obj, picoseconds, user_data);
        }
        static duration_t find_next_time_in_ps(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) {
            return detail::get_interface<CycleInterface>(queue)->find_next_time_in_ps(evclass, obj, pred, match_data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CycleInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cycles_t get_cycle_count() const {
            return iface_->get_cycle_count(obj_);
        }
        double get_time() const {
            return iface_->get_time(obj_);
        }
        cycles_t cycles_delta(double when) const {
            return iface_->cycles_delta(obj_, when);
        }
        uint64 get_frequency() const {
            return iface_->get_frequency(obj_);
        }
        void post_cycle(event_class_t *evclass, conf_object_t *obj, cycles_t cycles, lang_void *user_data) const {
            iface_->post_cycle(obj_, evclass, obj, cycles, user_data);
        }
        void post_time(event_class_t *evclass, conf_object_t *obj, double seconds, lang_void *user_data) const {
            iface_->post_time(obj_, evclass, obj, seconds, user_data);
        }
        void cancel(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) const {
            iface_->cancel(obj_, evclass, obj, pred, match_data);
        }
        cycles_t find_next_cycle(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) const {
            return iface_->find_next_cycle(obj_, evclass, obj, pred, match_data);
        }
        double find_next_time(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) const {
            return iface_->find_next_time(obj_, evclass, obj, pred, match_data);
        }
        attr_value_t events() const {
            return iface_->events(obj_);
        }
        local_time_t get_time_in_ps() const {
            return iface_->get_time_in_ps(obj_);
        }
        cycles_t cycles_delta_from_ps(local_time_t when) const {
            return iface_->cycles_delta_from_ps(obj_, when);
        }
        void post_time_in_ps(event_class_t *evclass, conf_object_t *obj, duration_t picoseconds, lang_void *user_data) const {
            iface_->post_time_in_ps(obj_, evclass, obj, picoseconds, user_data);
        }
        duration_t find_next_time_in_ps(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) const {
            return iface_->find_next_time_in_ps(obj_, evclass, obj, pred, match_data);
        }

        const CycleInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CycleInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CYCLE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CycleInterface::ctype funcs {
                FromC::get_cycle_count,
                FromC::get_time,
                FromC::cycles_delta,
                FromC::get_frequency,
                FromC::post_cycle,
                FromC::post_time,
                FromC::cancel,
                FromC::find_next_cycle,
                FromC::find_next_time,
                FromC::events,
                FromC::get_time_in_ps,
                FromC::cycles_delta_from_ps,
                FromC::post_time_in_ps,
                FromC::find_next_time_in_ps,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
