// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_ARCH_PPC_H
#define SIMICS_CPP_ARCH_PPC_H

#include "simics/arch/ppc.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class PpcInterface {
  public:
    using ctype = ppc_interface_t;

    // Function override and implemented by user
    virtual void clear_atomic_reservation_bit() = 0;
    virtual void raise_machine_check_exception(ppc_mc_exc_t exc) = 0;
    virtual unsigned get_timebase_enabled() = 0;
    virtual void set_timebase_enabled(unsigned enabled) = 0;
    virtual ppc_sleep_state_t get_sleep_state() = 0;
    virtual void set_sleep_state(ppc_sleep_state_t state) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void clear_atomic_reservation_bit(conf_object_t *cpu) {
            detail::get_interface<PpcInterface>(cpu)->clear_atomic_reservation_bit();
        }
        static void raise_machine_check_exception(conf_object_t *cpu, ppc_mc_exc_t exc) {
            detail::get_interface<PpcInterface>(cpu)->raise_machine_check_exception(exc);
        }
        static unsigned get_timebase_enabled(conf_object_t *cpu) {
            return detail::get_interface<PpcInterface>(cpu)->get_timebase_enabled();
        }
        static void set_timebase_enabled(conf_object_t *cpu, unsigned enabled) {
            detail::get_interface<PpcInterface>(cpu)->set_timebase_enabled(enabled);
        }
        static ppc_sleep_state_t get_sleep_state(conf_object_t *cpu) {
            return detail::get_interface<PpcInterface>(cpu)->get_sleep_state();
        }
        static void set_sleep_state(conf_object_t *cpu, ppc_sleep_state_t state) {
            detail::get_interface<PpcInterface>(cpu)->set_sleep_state(state);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const PpcInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void clear_atomic_reservation_bit() const {
            iface_->clear_atomic_reservation_bit(obj_);
        }
        void raise_machine_check_exception(ppc_mc_exc_t exc) const {
            iface_->raise_machine_check_exception(obj_, exc);
        }
        unsigned get_timebase_enabled() const {
            return iface_->get_timebase_enabled(obj_);
        }
        void set_timebase_enabled(unsigned enabled) const {
            iface_->set_timebase_enabled(obj_, enabled);
        }
        ppc_sleep_state_t get_sleep_state() const {
            return iface_->get_sleep_state(obj_);
        }
        void set_sleep_state(ppc_sleep_state_t state) const {
            iface_->set_sleep_state(obj_, state);
        }

        const PpcInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const PpcInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PPC_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr PpcInterface::ctype funcs {
                FromC::clear_atomic_reservation_bit,
                FromC::raise_machine_check_exception,
                FromC::get_timebase_enabled,
                FromC::set_timebase_enabled,
                FromC::get_sleep_state,
                FromC::set_sleep_state,
            };
            return &funcs;
        }
    };
};

class SprInterface {
  public:
    using ctype = spr_interface_t;

    // Function override and implemented by user
    virtual void register_user_handlers(int64 spr_number, gen_spr_user_getter_func_t getter, lang_void *user_getter_data, gen_spr_user_setter_func_t setter, lang_void *user_setter_data, int privilege_checks) = 0;
    virtual void unregister_user_handlers(int64 spr_number) = 0;
    virtual void set_target_value(uint64 value) = 0;
    virtual void stash_value(int64 spr_number, uint64 value) = 0;
    virtual uint64 fetch_value(int64 spr_number) = 0;
    virtual gen_spr_ret_t default_getter(int64 spr_number, gen_spr_access_type_t type) = 0;
    virtual gen_spr_ret_t default_setter(int64 spr_number, uint64 value, gen_spr_access_type_t type) = 0;
    virtual const char * get_name(int64 spr_number) = 0;
    virtual int64 get_number(const char *spr_name) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void register_user_handlers(conf_object_t *cpu, int64 spr_number, gen_spr_user_getter_func_t getter, lang_void *user_getter_data, gen_spr_user_setter_func_t setter, lang_void *user_setter_data, int privilege_checks) {
            detail::get_interface<SprInterface>(cpu)->register_user_handlers(spr_number, getter, user_getter_data, setter, user_setter_data, privilege_checks);
        }
        static void unregister_user_handlers(conf_object_t *cpu, int64 spr_number) {
            detail::get_interface<SprInterface>(cpu)->unregister_user_handlers(spr_number);
        }
        static void set_target_value(conf_object_t *cpu, uint64 value) {
            detail::get_interface<SprInterface>(cpu)->set_target_value(value);
        }
        static void stash_value(conf_object_t *cpu, int64 spr_number, uint64 value) {
            detail::get_interface<SprInterface>(cpu)->stash_value(spr_number, value);
        }
        static uint64 fetch_value(conf_object_t *cpu, int64 spr_number) {
            return detail::get_interface<SprInterface>(cpu)->fetch_value(spr_number);
        }
        static gen_spr_ret_t default_getter(conf_object_t *cpu, int64 spr_number, gen_spr_access_type_t type) {
            return detail::get_interface<SprInterface>(cpu)->default_getter(spr_number, type);
        }
        static gen_spr_ret_t default_setter(conf_object_t *cpu, int64 spr_number, uint64 value, gen_spr_access_type_t type) {
            return detail::get_interface<SprInterface>(cpu)->default_setter(spr_number, value, type);
        }
        static const char * get_name(conf_object_t *cpu, int64 spr_number) {
            return detail::get_interface<SprInterface>(cpu)->get_name(spr_number);
        }
        static int64 get_number(conf_object_t *cpu, const char *spr_name) {
            return detail::get_interface<SprInterface>(cpu)->get_number(spr_name);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const SprInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void register_user_handlers(int64 spr_number, gen_spr_user_getter_func_t getter, lang_void *user_getter_data, gen_spr_user_setter_func_t setter, lang_void *user_setter_data, int privilege_checks) const {
            iface_->register_user_handlers(obj_, spr_number, getter, user_getter_data, setter, user_setter_data, privilege_checks);
        }
        void unregister_user_handlers(int64 spr_number) const {
            iface_->unregister_user_handlers(obj_, spr_number);
        }
        void set_target_value(uint64 value) const {
            iface_->set_target_value(obj_, value);
        }
        void stash_value(int64 spr_number, uint64 value) const {
            iface_->stash_value(obj_, spr_number, value);
        }
        uint64 fetch_value(int64 spr_number) const {
            return iface_->fetch_value(obj_, spr_number);
        }
        gen_spr_ret_t default_getter(int64 spr_number, gen_spr_access_type_t type) const {
            return iface_->default_getter(obj_, spr_number, type);
        }
        gen_spr_ret_t default_setter(int64 spr_number, uint64 value, gen_spr_access_type_t type) const {
            return iface_->default_setter(obj_, spr_number, value, type);
        }
        const char * get_name(int64 spr_number) const {
            return iface_->get_name(obj_, spr_number);
        }
        int64 get_number(const char *spr_name) const {
            return iface_->get_number(obj_, spr_name);
        }

        const SprInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const SprInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return SPR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr SprInterface::ctype funcs {
                FromC::register_user_handlers,
                FromC::unregister_user_handlers,
                FromC::set_target_value,
                FromC::stash_value,
                FromC::fetch_value,
                FromC::default_getter,
                FromC::default_setter,
                FromC::get_name,
                FromC::get_number,
            };
            return &funcs;
        }
    };
};

class PmrInterface {
  public:
    using ctype = pmr_interface_t;

    // Function override and implemented by user
    virtual uint64 get(int pmr_number, bool instruction_read) = 0;
    virtual void set(int pmr_number, uint64 value, bool instruction_write) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 get(conf_object_t *obj, int pmr_number, bool instruction_read) {
            return detail::get_interface<PmrInterface>(obj)->get(pmr_number, instruction_read);
        }
        static void set(conf_object_t *obj, int pmr_number, uint64 value, bool instruction_write) {
            detail::get_interface<PmrInterface>(obj)->set(pmr_number, value, instruction_write);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const PmrInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 get(int pmr_number, bool instruction_read) const {
            return iface_->get(obj_, pmr_number, instruction_read);
        }
        void set(int pmr_number, uint64 value, bool instruction_write) const {
            iface_->set(obj_, pmr_number, value, instruction_write);
        }

        const PmrInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const PmrInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PMR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr PmrInterface::ctype funcs {
                FromC::get,
                FromC::set,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
