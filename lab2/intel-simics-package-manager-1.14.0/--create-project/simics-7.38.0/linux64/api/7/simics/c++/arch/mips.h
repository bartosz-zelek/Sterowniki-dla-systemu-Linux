// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_ARCH_MIPS_H
#define SIMICS_CPP_ARCH_MIPS_H

#include "simics/arch/mips.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class MipsCoprocessorInterface {
  public:
    using ctype = mips_coprocessor_interface_t;

    // Function override and implemented by user
    virtual uint64 read_register(uint32 thread_id, uint32 reg, uint32 sel) = 0;
    virtual void write_register(uint32 thread_id, uint64 value, uint32 reg, uint32 sel) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 read_register(conf_object_t *obj, uint32 thread_id, uint32 reg, uint32 sel) {
            return detail::get_interface<MipsCoprocessorInterface>(obj)->read_register(thread_id, reg, sel);
        }
        static void write_register(conf_object_t *obj, uint32 thread_id, uint64 value, uint32 reg, uint32 sel) {
            detail::get_interface<MipsCoprocessorInterface>(obj)->write_register(thread_id, value, reg, sel);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const MipsCoprocessorInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 read_register(uint32 thread_id, uint32 reg, uint32 sel) const {
            return iface_->read_register(obj_, thread_id, reg, sel);
        }
        void write_register(uint32 thread_id, uint64 value, uint32 reg, uint32 sel) const {
            iface_->write_register(obj_, thread_id, value, reg, sel);
        }

        const MipsCoprocessorInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const MipsCoprocessorInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return MIPS_COPROCESSOR_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr MipsCoprocessorInterface::ctype funcs {
                FromC::read_register,
                FromC::write_register,
            };
            return &funcs;
        }
    };
};

class FmnStationControlInterface {
  public:
    using ctype = fmn_station_control_interface_t;

    // Function override and implemented by user
    virtual uint64 send_message(uint32 thread_id, uint64 rt_value) = 0;
    virtual void load_message(uint32 thread_id, uint8 bucket) = 0;
    virtual int wait(uint32 thread_id, uint8 vector) = 0;
    virtual void sync(uint32 thread_id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 send_message(conf_object_t *obj, uint32 thread_id, uint64 rt_value) {
            return detail::get_interface<FmnStationControlInterface>(obj)->send_message(thread_id, rt_value);
        }
        static void load_message(conf_object_t *obj, uint32 thread_id, uint8 bucket) {
            detail::get_interface<FmnStationControlInterface>(obj)->load_message(thread_id, bucket);
        }
        static int wait(conf_object_t *obj, uint32 thread_id, uint8 vector) {
            return detail::get_interface<FmnStationControlInterface>(obj)->wait(thread_id, vector);
        }
        static void sync(conf_object_t *obj, uint32 thread_id) {
            detail::get_interface<FmnStationControlInterface>(obj)->sync(thread_id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const FmnStationControlInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 send_message(uint32 thread_id, uint64 rt_value) const {
            return iface_->send_message(obj_, thread_id, rt_value);
        }
        void load_message(uint32 thread_id, uint8 bucket) const {
            iface_->load_message(obj_, thread_id, bucket);
        }
        int wait(uint32 thread_id, uint8 vector) const {
            return iface_->wait(obj_, thread_id, vector);
        }
        void sync(uint32 thread_id) const {
            iface_->sync(obj_, thread_id);
        }

        const FmnStationControlInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const FmnStationControlInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return FMN_STATION_CONTROL_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr FmnStationControlInterface::ctype funcs {
                FromC::send_message,
                FromC::load_message,
                FromC::wait,
                FromC::sync,
            };
            return &funcs;
        }
    };
};

class FmnStationControlV2Interface {
  public:
    using ctype = fmn_station_control_v2_interface_t;

    // Function override and implemented by user
    virtual uint64 send_message(uint32 thread_id, uint64 rt_value) = 0;
    virtual uint64 load_message(uint32 thread_id, uint64 rt_value) = 0;
    virtual int wait(uint32 thread_id, uint64 rt_value) = 0;
    virtual void sync(uint32 thread_id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint64 send_message(conf_object_t *obj, uint32 thread_id, uint64 rt_value) {
            return detail::get_interface<FmnStationControlV2Interface>(obj)->send_message(thread_id, rt_value);
        }
        static uint64 load_message(conf_object_t *obj, uint32 thread_id, uint64 rt_value) {
            return detail::get_interface<FmnStationControlV2Interface>(obj)->load_message(thread_id, rt_value);
        }
        static int wait(conf_object_t *obj, uint32 thread_id, uint64 rt_value) {
            return detail::get_interface<FmnStationControlV2Interface>(obj)->wait(thread_id, rt_value);
        }
        static void sync(conf_object_t *obj, uint32 thread_id) {
            detail::get_interface<FmnStationControlV2Interface>(obj)->sync(thread_id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const FmnStationControlV2Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint64 send_message(uint32 thread_id, uint64 rt_value) const {
            return iface_->send_message(obj_, thread_id, rt_value);
        }
        uint64 load_message(uint32 thread_id, uint64 rt_value) const {
            return iface_->load_message(obj_, thread_id, rt_value);
        }
        int wait(uint32 thread_id, uint64 rt_value) const {
            return iface_->wait(obj_, thread_id, rt_value);
        }
        void sync(uint32 thread_id) const {
            iface_->sync(obj_, thread_id);
        }

        const FmnStationControlV2Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const FmnStationControlV2Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return FMN_STATION_CONTROL_V2_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr FmnStationControlV2Interface::ctype funcs {
                FromC::send_message,
                FromC::load_message,
                FromC::wait,
                FromC::sync,
            };
            return &funcs;
        }
    };
};

class MipsCacheInstructionInterface {
  public:
    using ctype = mips_cache_instruction_interface_t;

    // Function override and implemented by user
    virtual int cache_instruction(conf_object_t *cpu, uint32 op, logical_address_t vaddr) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static int cache_instruction(conf_object_t *self, conf_object_t *cpu, uint32 op, logical_address_t vaddr) {
            return detail::get_interface<MipsCacheInstructionInterface>(self)->cache_instruction(cpu, op, vaddr);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const MipsCacheInstructionInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        int cache_instruction(conf_object_t *cpu, uint32 op, logical_address_t vaddr) const {
            return iface_->cache_instruction(obj_, cpu, op, vaddr);
        }

        const MipsCacheInstructionInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const MipsCacheInstructionInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return MIPS_CACHE_INSTRUCTION_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr MipsCacheInstructionInterface::ctype funcs {
                FromC::cache_instruction,
            };
            return &funcs;
        }
    };
};

class MipsIteInterface {
  public:
    using ctype = mips_ite_interface_t;

    // Function override and implemented by user
    virtual void set_dtag_lo(uint32 value) = 0;
    virtual uint32 get_dtag_lo() = 0;
    virtual uint32 get_errctl() = 0;
    virtual void block_tc() = 0;
    virtual void gated_exception() = 0;
    virtual int current_tc_num() = 0;
    virtual void unblock_tc(int tc_num) = 0;
    virtual bool is_big_endian() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void set_dtag_lo(conf_object_t *obj, uint32 value) {
            detail::get_interface<MipsIteInterface>(obj)->set_dtag_lo(value);
        }
        static uint32 get_dtag_lo(conf_object_t *obj) {
            return detail::get_interface<MipsIteInterface>(obj)->get_dtag_lo();
        }
        static uint32 get_errctl(conf_object_t *obj) {
            return detail::get_interface<MipsIteInterface>(obj)->get_errctl();
        }
        static void block_tc(conf_object_t *obj) {
            detail::get_interface<MipsIteInterface>(obj)->block_tc();
        }
        static void gated_exception(conf_object_t *obj) {
            detail::get_interface<MipsIteInterface>(obj)->gated_exception();
        }
        static int current_tc_num(conf_object_t *obj) {
            return detail::get_interface<MipsIteInterface>(obj)->current_tc_num();
        }
        static void unblock_tc(conf_object_t *obj, int tc_num) {
            detail::get_interface<MipsIteInterface>(obj)->unblock_tc(tc_num);
        }
        static bool is_big_endian(conf_object_t *obj) {
            return detail::get_interface<MipsIteInterface>(obj)->is_big_endian();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const MipsIteInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void set_dtag_lo(uint32 value) const {
            iface_->set_dtag_lo(obj_, value);
        }
        uint32 get_dtag_lo() const {
            return iface_->get_dtag_lo(obj_);
        }
        uint32 get_errctl() const {
            return iface_->get_errctl(obj_);
        }
        void block_tc() const {
            iface_->block_tc(obj_);
        }
        void gated_exception() const {
            iface_->gated_exception(obj_);
        }
        int current_tc_num() const {
            return iface_->current_tc_num(obj_);
        }
        void unblock_tc(int tc_num) const {
            iface_->unblock_tc(obj_, tc_num);
        }
        bool is_big_endian() const {
            return iface_->is_big_endian(obj_);
        }

        const MipsIteInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const MipsIteInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return MIPS_ITE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr MipsIteInterface::ctype funcs {
                FromC::set_dtag_lo,
                FromC::get_dtag_lo,
                FromC::get_errctl,
                FromC::block_tc,
                FromC::gated_exception,
                FromC::current_tc_num,
                FromC::unblock_tc,
                FromC::is_big_endian,
            };
            return &funcs;
        }
    };
};

class MipsEicInterface {
  public:
    using ctype = mips_eic_interface_t;

    // Function override and implemented by user
    virtual void cpu_pending_irqs(uint32 cause) = 0;
    virtual uint32 requested_ipl() = 0;
    virtual uint32 requested_offset() = 0;
    virtual uint32 requested_vect_num() = 0;
    virtual uint32 reg_set() = 0;
    virtual void handled() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void cpu_pending_irqs(conf_object_t *obj, uint32 cause) {
            detail::get_interface<MipsEicInterface>(obj)->cpu_pending_irqs(cause);
        }
        static uint32 requested_ipl(conf_object_t *obj) {
            return detail::get_interface<MipsEicInterface>(obj)->requested_ipl();
        }
        static uint32 requested_offset(conf_object_t *obj) {
            return detail::get_interface<MipsEicInterface>(obj)->requested_offset();
        }
        static uint32 requested_vect_num(conf_object_t *obj) {
            return detail::get_interface<MipsEicInterface>(obj)->requested_vect_num();
        }
        static uint32 reg_set(conf_object_t *obj) {
            return detail::get_interface<MipsEicInterface>(obj)->reg_set();
        }
        static void handled(conf_object_t *obj) {
            detail::get_interface<MipsEicInterface>(obj)->handled();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const MipsEicInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void cpu_pending_irqs(uint32 cause) const {
            iface_->cpu_pending_irqs(obj_, cause);
        }
        uint32 requested_ipl() const {
            return iface_->requested_ipl(obj_);
        }
        uint32 requested_offset() const {
            return iface_->requested_offset(obj_);
        }
        uint32 requested_vect_num() const {
            return iface_->requested_vect_num(obj_);
        }
        uint32 reg_set() const {
            return iface_->reg_set(obj_);
        }
        void handled() const {
            iface_->handled(obj_);
        }

        const MipsEicInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const MipsEicInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return MIPS_EIC_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr MipsEicInterface::ctype funcs {
                FromC::cpu_pending_irqs,
                FromC::requested_ipl,
                FromC::requested_offset,
                FromC::requested_vect_num,
                FromC::reg_set,
                FromC::handled,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
