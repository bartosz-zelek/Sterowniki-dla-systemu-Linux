// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_CPU_INSTRUMENTATION_H
#define SIMICS_CPP_MODEL_IFACE_CPU_INSTRUMENTATION_H

#include "simics/model-iface/cpu-instrumentation.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class CpuInstructionQueryInterface {
  public:
    using ctype = cpu_instruction_query_interface_t;

    // Function override and implemented by user
    virtual logical_address_t logical_address(instruction_handle_t *handle) = 0;
    virtual physical_address_t physical_address(instruction_handle_t *handle) = 0;
    virtual cpu_bytes_t get_instruction_bytes(instruction_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static logical_address_t logical_address(conf_object_t *cpu, instruction_handle_t *handle) {
            return detail::get_interface<CpuInstructionQueryInterface>(cpu)->logical_address(handle);
        }
        static physical_address_t physical_address(conf_object_t *cpu, instruction_handle_t *handle) {
            return detail::get_interface<CpuInstructionQueryInterface>(cpu)->physical_address(handle);
        }
        static cpu_bytes_t get_instruction_bytes(conf_object_t *cpu, instruction_handle_t *handle) {
            return detail::get_interface<CpuInstructionQueryInterface>(cpu)->get_instruction_bytes(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuInstructionQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        logical_address_t logical_address(instruction_handle_t *handle) const {
            return iface_->logical_address(obj_, handle);
        }
        physical_address_t physical_address(instruction_handle_t *handle) const {
            return iface_->physical_address(obj_, handle);
        }
        cpu_bytes_t get_instruction_bytes(instruction_handle_t *handle) const {
            return iface_->get_instruction_bytes(obj_, handle);
        }

        const CpuInstructionQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuInstructionQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_INSTRUCTION_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuInstructionQueryInterface::ctype funcs {
                FromC::logical_address,
                FromC::physical_address,
                FromC::get_instruction_bytes,
            };
            return &funcs;
        }
    };
};

class CpuMemoryQueryInterface {
  public:
    using ctype = cpu_memory_query_interface_t;

    // Function override and implemented by user
    virtual logical_address_t logical_address(memory_handle_t *handle) = 0;
    virtual physical_address_t physical_address(memory_handle_t *handle) = 0;
    virtual void set_host_ptr(memory_handle_t *handle, void *p) = 0;
    virtual cpu_bytes_t get_bytes(memory_handle_t *handle) = 0;
    virtual void set_bytes(memory_handle_t *handle, cpu_bytes_t bytes) = 0;
    virtual bool atomic(memory_handle_t *handle) = 0;
    virtual ini_type_t arch(memory_handle_t *handle) = 0;
    virtual page_crossing_info_t get_page_crossing_info(memory_handle_t *handle) = 0;
    virtual buffer_t get_surrounding_bytes(memory_handle_t *handle, unsigned granularity_log2) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static logical_address_t logical_address(conf_object_t *cpu, memory_handle_t *handle) {
            return detail::get_interface<CpuMemoryQueryInterface>(cpu)->logical_address(handle);
        }
        static physical_address_t physical_address(conf_object_t *cpu, memory_handle_t *handle) {
            return detail::get_interface<CpuMemoryQueryInterface>(cpu)->physical_address(handle);
        }
        static void set_host_ptr(conf_object_t *cpu, memory_handle_t *handle, void *p) {
            detail::get_interface<CpuMemoryQueryInterface>(cpu)->set_host_ptr(handle, p);
        }
        static cpu_bytes_t get_bytes(conf_object_t *cpu, memory_handle_t *handle) {
            return detail::get_interface<CpuMemoryQueryInterface>(cpu)->get_bytes(handle);
        }
        static void set_bytes(conf_object_t *cpu, memory_handle_t *handle, cpu_bytes_t bytes) {
            detail::get_interface<CpuMemoryQueryInterface>(cpu)->set_bytes(handle, bytes);
        }
        static bool atomic(conf_object_t *obj, memory_handle_t *handle) {
            return detail::get_interface<CpuMemoryQueryInterface>(obj)->atomic(handle);
        }
        static ini_type_t arch(conf_object_t *obj, memory_handle_t *handle) {
            return detail::get_interface<CpuMemoryQueryInterface>(obj)->arch(handle);
        }
        static page_crossing_info_t get_page_crossing_info(conf_object_t *obj, memory_handle_t *handle) {
            return detail::get_interface<CpuMemoryQueryInterface>(obj)->get_page_crossing_info(handle);
        }
        static buffer_t get_surrounding_bytes(conf_object_t *cpu, memory_handle_t *handle, unsigned granularity_log2) {
            return detail::get_interface<CpuMemoryQueryInterface>(cpu)->get_surrounding_bytes(handle, granularity_log2);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuMemoryQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        logical_address_t logical_address(memory_handle_t *handle) const {
            return iface_->logical_address(obj_, handle);
        }
        physical_address_t physical_address(memory_handle_t *handle) const {
            return iface_->physical_address(obj_, handle);
        }
        void set_host_ptr(memory_handle_t *handle, void *p) const {
            iface_->set_host_ptr(obj_, handle, p);
        }
        cpu_bytes_t get_bytes(memory_handle_t *handle) const {
            return iface_->get_bytes(obj_, handle);
        }
        void set_bytes(memory_handle_t *handle, cpu_bytes_t bytes) const {
            iface_->set_bytes(obj_, handle, bytes);
        }
        bool atomic(memory_handle_t *handle) const {
            return iface_->atomic(obj_, handle);
        }
        ini_type_t arch(memory_handle_t *handle) const {
            return iface_->arch(obj_, handle);
        }
        page_crossing_info_t get_page_crossing_info(memory_handle_t *handle) const {
            return iface_->get_page_crossing_info(obj_, handle);
        }
        buffer_t get_surrounding_bytes(memory_handle_t *handle, unsigned granularity_log2) const {
            return iface_->get_surrounding_bytes(obj_, handle, granularity_log2);
        }

        const CpuMemoryQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuMemoryQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_MEMORY_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuMemoryQueryInterface::ctype funcs {
                FromC::logical_address,
                FromC::physical_address,
                FromC::set_host_ptr,
                FromC::get_bytes,
                FromC::set_bytes,
                FromC::atomic,
                FromC::arch,
                FromC::get_page_crossing_info,
                FromC::get_surrounding_bytes,
            };
            return &funcs;
        }
    };
};

class CpuExceptionQueryInterface {
  public:
    using ctype = cpu_exception_query_interface_t;

    // Function override and implemented by user
    virtual int exception_number(exception_handle_t *handle) = 0;
    virtual logical_address_t fault_pc(exception_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static int exception_number(conf_object_t *cpu, exception_handle_t *handle) {
            return detail::get_interface<CpuExceptionQueryInterface>(cpu)->exception_number(handle);
        }
        static logical_address_t fault_pc(conf_object_t *cpu, exception_handle_t *handle) {
            return detail::get_interface<CpuExceptionQueryInterface>(cpu)->fault_pc(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuExceptionQueryInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        int exception_number(exception_handle_t *handle) const {
            return iface_->exception_number(obj_, handle);
        }
        logical_address_t fault_pc(exception_handle_t *handle) const {
            return iface_->fault_pc(obj_, handle);
        }

        const CpuExceptionQueryInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuExceptionQueryInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_EXCEPTION_QUERY_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuExceptionQueryInterface::ctype funcs {
                FromC::exception_number,
                FromC::fault_pc,
            };
            return &funcs;
        }
    };
};

class CpuCachedInstructionInterface {
  public:
    using ctype = cpu_cached_instruction_interface_t;

    // Function override and implemented by user
    virtual void register_instruction_before_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void register_instruction_after_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void register_read_before_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void register_read_after_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void register_write_before_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void register_write_after_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void add_counter(cached_instruction_handle_t *ci_handle, uint64 *counter, bool use_atomic_increment) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void register_instruction_before_cb(conf_object_t *cpu, cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionInterface>(cpu)->register_instruction_before_cb(ci_handle, cb, user_data, free_cb);
        }
        static void register_instruction_after_cb(conf_object_t *obj, cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionInterface>(obj)->register_instruction_after_cb(ci_handle, cb, user_data, free_cb);
        }
        static void register_read_before_cb(conf_object_t *obj, cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionInterface>(obj)->register_read_before_cb(ci_handle, cb, user_data, free_cb);
        }
        static void register_read_after_cb(conf_object_t *obj, cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionInterface>(obj)->register_read_after_cb(ci_handle, cb, user_data, free_cb);
        }
        static void register_write_before_cb(conf_object_t *obj, cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionInterface>(obj)->register_write_before_cb(ci_handle, cb, user_data, free_cb);
        }
        static void register_write_after_cb(conf_object_t *obj, cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionInterface>(obj)->register_write_after_cb(ci_handle, cb, user_data, free_cb);
        }
        static void add_counter(conf_object_t *obj, cached_instruction_handle_t *ci_handle, uint64 *counter, bool use_atomic_increment) {
            detail::get_interface<CpuCachedInstructionInterface>(obj)->add_counter(ci_handle, counter, use_atomic_increment);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuCachedInstructionInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void register_instruction_before_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_instruction_before_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void register_instruction_after_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_instruction_after_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void register_read_before_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_read_before_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void register_read_after_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_read_after_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void register_write_before_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_write_before_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void register_write_after_cb(cached_instruction_handle_t *ci_handle, cpu_memory_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_write_after_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void add_counter(cached_instruction_handle_t *ci_handle, uint64 *counter, bool use_atomic_increment) const {
            iface_->add_counter(obj_, ci_handle, counter, use_atomic_increment);
        }

        const CpuCachedInstructionInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuCachedInstructionInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_CACHED_INSTRUCTION_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuCachedInstructionInterface::ctype funcs {
                FromC::register_instruction_before_cb,
                FromC::register_instruction_after_cb,
                FromC::register_read_before_cb,
                FromC::register_read_after_cb,
                FromC::register_write_before_cb,
                FromC::register_write_after_cb,
                FromC::add_counter,
            };
            return &funcs;
        }
    };
};

class CpuCachedInstructionOnceInterface {
  public:
    using ctype = cpu_cached_instruction_once_interface_t;

    // Function override and implemented by user
    virtual void register_instruction_before_once_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;
    virtual void register_instruction_after_once_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void register_instruction_before_once_cb(conf_object_t *cpu, cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionOnceInterface>(cpu)->register_instruction_before_once_cb(ci_handle, cb, user_data, free_cb);
        }
        static void register_instruction_after_once_cb(conf_object_t *cpu, cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuCachedInstructionOnceInterface>(cpu)->register_instruction_after_once_cb(ci_handle, cb, user_data, free_cb);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuCachedInstructionOnceInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void register_instruction_before_once_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_instruction_before_once_cb(obj_, ci_handle, cb, user_data, free_cb);
        }
        void register_instruction_after_once_cb(cached_instruction_handle_t *ci_handle, cpu_instruction_cb_t cb, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_instruction_after_once_cb(obj_, ci_handle, cb, user_data, free_cb);
        }

        const CpuCachedInstructionOnceInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuCachedInstructionOnceInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_CACHED_INSTRUCTION_ONCE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuCachedInstructionOnceInterface::ctype funcs {
                FromC::register_instruction_before_once_cb,
                FromC::register_instruction_after_once_cb,
            };
            return &funcs;
        }
    };
};

class CpuInstructionDecoderInterface {
  public:
    using ctype = cpu_instruction_decoder_interface_t;

    // Function override and implemented by user
    virtual void register_emulation_cb(cpu_emulation_cb_t cb, decoder_handle_t *handle, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void register_emulation_cb(conf_object_t *cpu, cpu_emulation_cb_t cb, decoder_handle_t *handle, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) {
            detail::get_interface<CpuInstructionDecoderInterface>(cpu)->register_emulation_cb(cb, handle, user_data, free_cb);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuInstructionDecoderInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void register_emulation_cb(cpu_emulation_cb_t cb, decoder_handle_t *handle, lang_void *user_data, cpu_callback_free_user_data_cb_t free_cb) const {
            iface_->register_emulation_cb(obj_, cb, handle, user_data, free_cb);
        }

        const CpuInstructionDecoderInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuInstructionDecoderInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_INSTRUCTION_DECODER_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuInstructionDecoderInterface::ctype funcs {
                FromC::register_emulation_cb,
            };
            return &funcs;
        }
    };
};

class CpuInstrumentationSubscribeInterface {
  public:
    using ctype = cpu_instrumentation_subscribe_interface_t;

    // Function override and implemented by user
    virtual void remove_callback(cpu_cb_handle_t *handle) = 0;
    virtual void enable_callback(cpu_cb_handle_t *handle) = 0;
    virtual void disable_callback(cpu_cb_handle_t *handle) = 0;
    virtual void remove_connection_callbacks(conf_object_t *connection) = 0;
    virtual void enable_connection_callbacks(conf_object_t *connection) = 0;
    virtual void disable_connection_callbacks(conf_object_t *connection) = 0;
    virtual cpu_cb_handle_t * register_instruction_before_cb(conf_object_t *connection, cpu_instruction_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_instruction_after_cb(conf_object_t *connection, cpu_instruction_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_read_before_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_read_after_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_write_before_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_write_after_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_address_before_cb(conf_object_t *connection, cpu_address_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_cached_instruction_cb(conf_object_t *connection, cpu_cached_instruction_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_instruction_decoder_cb(conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_exception_before_cb(conf_object_t *connection, int exception_number, cpu_exception_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_exception_after_cb(conf_object_t *connection, int exception_number, cpu_exception_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_exception_return_before_cb(conf_object_t *connection, cpu_exception_return_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_exception_return_after_cb(conf_object_t *connection, cpu_exception_return_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_mode_change_cb(conf_object_t *connection, cpu_mode_change_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_control_register_read_before_cb(conf_object_t *connection, int register_number, cpu_control_register_read_cb_t cb, lang_void *data) = 0;
    virtual cpu_cb_handle_t * register_control_register_write_before_cb(conf_object_t *connection, int register_number, cpu_control_register_write_cb_t cb, lang_void *data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void remove_callback(conf_object_t *cpu, cpu_cb_handle_t *handle) {
            detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->remove_callback(handle);
        }
        static void enable_callback(conf_object_t *cpu, cpu_cb_handle_t *handle) {
            detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->enable_callback(handle);
        }
        static void disable_callback(conf_object_t *cpu, cpu_cb_handle_t *handle) {
            detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->disable_callback(handle);
        }
        static void remove_connection_callbacks(conf_object_t *cpu, conf_object_t *connection) {
            detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->remove_connection_callbacks(connection);
        }
        static void enable_connection_callbacks(conf_object_t *cpu, conf_object_t *connection) {
            detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->enable_connection_callbacks(connection);
        }
        static void disable_connection_callbacks(conf_object_t *cpu, conf_object_t *connection) {
            detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->disable_connection_callbacks(connection);
        }
        static cpu_cb_handle_t * register_instruction_before_cb(conf_object_t *cpu, conf_object_t *connection, cpu_instruction_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_instruction_before_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_instruction_after_cb(conf_object_t *cpu, conf_object_t *connection, cpu_instruction_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_instruction_after_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_read_before_cb(conf_object_t *cpu, conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_read_before_cb(connection, scope, cb, data);
        }
        static cpu_cb_handle_t * register_read_after_cb(conf_object_t *cpu, conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_read_after_cb(connection, scope, cb, data);
        }
        static cpu_cb_handle_t * register_write_before_cb(conf_object_t *cpu, conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_write_before_cb(connection, scope, cb, data);
        }
        static cpu_cb_handle_t * register_write_after_cb(conf_object_t *cpu, conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_write_after_cb(connection, scope, cb, data);
        }
        static cpu_cb_handle_t * register_address_before_cb(conf_object_t *cpu, conf_object_t *connection, cpu_address_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_address_before_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_cached_instruction_cb(conf_object_t *cpu, conf_object_t *connection, cpu_cached_instruction_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_cached_instruction_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_instruction_decoder_cb(conf_object_t *cpu, conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_instruction_decoder_cb(connection, cb, disass_cb, data);
        }
        static cpu_cb_handle_t * register_exception_before_cb(conf_object_t *cpu, conf_object_t *connection, int exception_number, cpu_exception_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_exception_before_cb(connection, exception_number, cb, data);
        }
        static cpu_cb_handle_t * register_exception_after_cb(conf_object_t *cpu, conf_object_t *connection, int exception_number, cpu_exception_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_exception_after_cb(connection, exception_number, cb, data);
        }
        static cpu_cb_handle_t * register_exception_return_before_cb(conf_object_t *cpu, conf_object_t *connection, cpu_exception_return_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_exception_return_before_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_exception_return_after_cb(conf_object_t *cpu, conf_object_t *connection, cpu_exception_return_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_exception_return_after_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_mode_change_cb(conf_object_t *cpu, conf_object_t *connection, cpu_mode_change_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_mode_change_cb(connection, cb, data);
        }
        static cpu_cb_handle_t * register_control_register_read_before_cb(conf_object_t *cpu, conf_object_t *connection, int register_number, cpu_control_register_read_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_control_register_read_before_cb(connection, register_number, cb, data);
        }
        static cpu_cb_handle_t * register_control_register_write_before_cb(conf_object_t *cpu, conf_object_t *connection, int register_number, cpu_control_register_write_cb_t cb, lang_void *data) {
            return detail::get_interface<CpuInstrumentationSubscribeInterface>(cpu)->register_control_register_write_before_cb(connection, register_number, cb, data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuInstrumentationSubscribeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void remove_callback(cpu_cb_handle_t *handle) const {
            iface_->remove_callback(obj_, handle);
        }
        void enable_callback(cpu_cb_handle_t *handle) const {
            iface_->enable_callback(obj_, handle);
        }
        void disable_callback(cpu_cb_handle_t *handle) const {
            iface_->disable_callback(obj_, handle);
        }
        void remove_connection_callbacks(conf_object_t *connection) const {
            iface_->remove_connection_callbacks(obj_, connection);
        }
        void enable_connection_callbacks(conf_object_t *connection) const {
            iface_->enable_connection_callbacks(obj_, connection);
        }
        void disable_connection_callbacks(conf_object_t *connection) const {
            iface_->disable_connection_callbacks(obj_, connection);
        }
        cpu_cb_handle_t * register_instruction_before_cb(conf_object_t *connection, cpu_instruction_cb_t cb, lang_void *data) const {
            return iface_->register_instruction_before_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_instruction_after_cb(conf_object_t *connection, cpu_instruction_cb_t cb, lang_void *data) const {
            return iface_->register_instruction_after_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_read_before_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) const {
            return iface_->register_read_before_cb(obj_, connection, scope, cb, data);
        }
        cpu_cb_handle_t * register_read_after_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) const {
            return iface_->register_read_after_cb(obj_, connection, scope, cb, data);
        }
        cpu_cb_handle_t * register_write_before_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) const {
            return iface_->register_write_before_cb(obj_, connection, scope, cb, data);
        }
        cpu_cb_handle_t * register_write_after_cb(conf_object_t *connection, cpu_access_scope_t scope, cpu_memory_cb_t cb, lang_void *data) const {
            return iface_->register_write_after_cb(obj_, connection, scope, cb, data);
        }
        cpu_cb_handle_t * register_address_before_cb(conf_object_t *connection, cpu_address_cb_t cb, lang_void *data) const {
            return iface_->register_address_before_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_cached_instruction_cb(conf_object_t *connection, cpu_cached_instruction_cb_t cb, lang_void *data) const {
            return iface_->register_cached_instruction_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_instruction_decoder_cb(conf_object_t *connection, cpu_instruction_decoder_cb_t cb, cpu_instruction_disassemble_cb_t disass_cb, lang_void *data) const {
            return iface_->register_instruction_decoder_cb(obj_, connection, cb, disass_cb, data);
        }
        cpu_cb_handle_t * register_exception_before_cb(conf_object_t *connection, int exception_number, cpu_exception_cb_t cb, lang_void *data) const {
            return iface_->register_exception_before_cb(obj_, connection, exception_number, cb, data);
        }
        cpu_cb_handle_t * register_exception_after_cb(conf_object_t *connection, int exception_number, cpu_exception_cb_t cb, lang_void *data) const {
            return iface_->register_exception_after_cb(obj_, connection, exception_number, cb, data);
        }
        cpu_cb_handle_t * register_exception_return_before_cb(conf_object_t *connection, cpu_exception_return_cb_t cb, lang_void *data) const {
            return iface_->register_exception_return_before_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_exception_return_after_cb(conf_object_t *connection, cpu_exception_return_cb_t cb, lang_void *data) const {
            return iface_->register_exception_return_after_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_mode_change_cb(conf_object_t *connection, cpu_mode_change_cb_t cb, lang_void *data) const {
            return iface_->register_mode_change_cb(obj_, connection, cb, data);
        }
        cpu_cb_handle_t * register_control_register_read_before_cb(conf_object_t *connection, int register_number, cpu_control_register_read_cb_t cb, lang_void *data) const {
            return iface_->register_control_register_read_before_cb(obj_, connection, register_number, cb, data);
        }
        cpu_cb_handle_t * register_control_register_write_before_cb(conf_object_t *connection, int register_number, cpu_control_register_write_cb_t cb, lang_void *data) const {
            return iface_->register_control_register_write_before_cb(obj_, connection, register_number, cb, data);
        }

        const CpuInstrumentationSubscribeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuInstrumentationSubscribeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_INSTRUMENTATION_SUBSCRIBE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuInstrumentationSubscribeInterface::ctype funcs {
                FromC::remove_callback,
                FromC::enable_callback,
                FromC::disable_callback,
                FromC::remove_connection_callbacks,
                FromC::enable_connection_callbacks,
                FromC::disable_connection_callbacks,
                FromC::register_instruction_before_cb,
                FromC::register_instruction_after_cb,
                FromC::register_read_before_cb,
                FromC::register_read_after_cb,
                FromC::register_write_before_cb,
                FromC::register_write_after_cb,
                FromC::register_address_before_cb,
                FromC::register_cached_instruction_cb,
                FromC::register_instruction_decoder_cb,
                FromC::register_exception_before_cb,
                FromC::register_exception_after_cb,
                FromC::register_exception_return_before_cb,
                FromC::register_exception_return_after_cb,
                FromC::register_mode_change_cb,
                FromC::register_control_register_read_before_cb,
                FromC::register_control_register_write_before_cb,
            };
            return &funcs;
        }
    };
};

class CpuCachedStreamInterface {
  public:
    using ctype = cpu_cached_stream_interface_t;

    // Function override and implemented by user
    virtual void add_stream(cached_instruction_handle_t *ci_handle, cpu_stream_bits_t bits, cpu_stream_data_t **data, uint64 user_data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void add_stream(conf_object_t *obj, cached_instruction_handle_t *ci_handle, cpu_stream_bits_t bits, cpu_stream_data_t **data, uint64 user_data) {
            detail::get_interface<CpuCachedStreamInterface>(obj)->add_stream(ci_handle, bits, data, user_data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuCachedStreamInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void add_stream(cached_instruction_handle_t *ci_handle, cpu_stream_bits_t bits, cpu_stream_data_t **data, uint64 user_data) const {
            iface_->add_stream(obj_, ci_handle, bits, data, user_data);
        }

        const CpuCachedStreamInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuCachedStreamInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_CACHED_STREAM_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuCachedStreamInterface::ctype funcs {
                FromC::add_stream,
            };
            return &funcs;
        }
    };
};

class CpuInstrumentationStreamInterface {
  public:
    using ctype = cpu_instrumentation_stream_interface_t;

    // Function override and implemented by user
    virtual cpu_stream_handle_t * add_stream(conf_object_t *connection, cpu_stream_bits_t bits, cpu_stream_data_t **data, cpu_access_scope_t scope) = 0;
    virtual void remove_stream(cpu_stream_handle_t *handle) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_stream_handle_t * add_stream(conf_object_t *cpu, conf_object_t *connection, cpu_stream_bits_t bits, cpu_stream_data_t **data, cpu_access_scope_t scope) {
            return detail::get_interface<CpuInstrumentationStreamInterface>(cpu)->add_stream(connection, bits, data, scope);
        }
        static void remove_stream(conf_object_t *cpu, cpu_stream_handle_t *handle) {
            detail::get_interface<CpuInstrumentationStreamInterface>(cpu)->remove_stream(handle);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CpuInstrumentationStreamInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_stream_handle_t * add_stream(conf_object_t *connection, cpu_stream_bits_t bits, cpu_stream_data_t **data, cpu_access_scope_t scope) const {
            return iface_->add_stream(obj_, connection, bits, data, scope);
        }
        void remove_stream(cpu_stream_handle_t *handle) const {
            iface_->remove_stream(obj_, handle);
        }

        const CpuInstrumentationStreamInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CpuInstrumentationStreamInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CPU_INSTRUMENTATION_STREAM_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CpuInstrumentationStreamInterface::ctype funcs {
                FromC::add_stream,
                FromC::remove_stream,
            };
            return &funcs;
        }
    };
};

class PreDecoderInterface {
  public:
    using ctype = pre_decoder_interface_t;

    // Function override and implemented by user
    virtual cpu_cb_handle_t * register_pre_decoder_cb(conf_object_t *connection, pre_decoder_cb_t cb, lang_void *data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_cb_handle_t * register_pre_decoder_cb(conf_object_t *cpu, conf_object_t *connection, pre_decoder_cb_t cb, lang_void *data) {
            return detail::get_interface<PreDecoderInterface>(cpu)->register_pre_decoder_cb(connection, cb, data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const PreDecoderInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_cb_handle_t * register_pre_decoder_cb(conf_object_t *connection, pre_decoder_cb_t cb, lang_void *data) const {
            return iface_->register_pre_decoder_cb(obj_, connection, cb, data);
        }

        const PreDecoderInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const PreDecoderInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PRE_DECODER_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr PreDecoderInterface::ctype funcs {
                FromC::register_pre_decoder_cb,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
