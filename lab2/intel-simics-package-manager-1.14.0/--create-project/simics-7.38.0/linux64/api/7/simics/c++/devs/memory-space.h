// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_DEVS_MEMORY_SPACE_H
#define SIMICS_CPP_DEVS_MEMORY_SPACE_H

#include "simics/devs/memory-space.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class MemorySpaceInterface {
  public:
    using ctype = memory_space_interface_t;

    // Function override and implemented by user
    virtual map_list_t * space_lookup(generic_transaction_t *mop, map_info_t mapinfo) = 0;
    virtual exception_type_t access(generic_transaction_t *mop) = 0;
    virtual exception_type_t access_simple(conf_object_t *initiator, physical_address_t addr, uint8 *buf, physical_address_t len, read_or_write_t type, endianness_t endian) = 0;
    virtual exception_type_t access_simple_inq(conf_object_t *initiator, physical_address_t addr, uint8 *buf, physical_address_t len, read_or_write_t type, endianness_t endian) = 0;
    virtual attr_value_t read(conf_object_t *initiator, physical_address_t addr, int length, int inquiry) = 0;
    virtual exception_type_t write(conf_object_t *initiator, physical_address_t addr, attr_value_t data, int inquiry) = 0;
    virtual uint64 fill(physical_address_t start, uint64 size, uint8 value, bool inquiry) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static map_list_t * space_lookup(conf_object_t *obj, generic_transaction_t *mop, map_info_t mapinfo) {
            return detail::get_interface<MemorySpaceInterface>(obj)->space_lookup(mop, mapinfo);
        }
        static exception_type_t access(conf_object_t *obj, generic_transaction_t *mop) {
            return detail::get_interface<MemorySpaceInterface>(obj)->access(mop);
        }
        static exception_type_t access_simple(conf_object_t *obj, conf_object_t *initiator, physical_address_t addr, uint8 *buf, physical_address_t len, read_or_write_t type, endianness_t endian) {
            return detail::get_interface<MemorySpaceInterface>(obj)->access_simple(initiator, addr, buf, len, type, endian);
        }
        static exception_type_t access_simple_inq(conf_object_t *obj, conf_object_t *initiator, physical_address_t addr, uint8 *buf, physical_address_t len, read_or_write_t type, endianness_t endian) {
            return detail::get_interface<MemorySpaceInterface>(obj)->access_simple_inq(initiator, addr, buf, len, type, endian);
        }
        static attr_value_t read(conf_object_t *obj, conf_object_t *initiator, physical_address_t addr, int length, int inquiry) {
            return detail::get_interface<MemorySpaceInterface>(obj)->read(initiator, addr, length, inquiry);
        }
        static exception_type_t write(conf_object_t *obj, conf_object_t *initiator, physical_address_t addr, attr_value_t data, int inquiry) {
            return detail::get_interface<MemorySpaceInterface>(obj)->write(initiator, addr, data, inquiry);
        }
        static uint64 fill(conf_object_t *obj, physical_address_t start, uint64 size, uint8 value, bool inquiry) {
            return detail::get_interface<MemorySpaceInterface>(obj)->fill(start, size, value, inquiry);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const MemorySpaceInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        map_list_t * space_lookup(generic_transaction_t *mop, map_info_t mapinfo) const {
            return iface_->space_lookup(obj_, mop, mapinfo);
        }
        exception_type_t access(generic_transaction_t *mop) const {
            return iface_->access(obj_, mop);
        }
        exception_type_t access_simple(conf_object_t *initiator, physical_address_t addr, uint8 *buf, physical_address_t len, read_or_write_t type, endianness_t endian) const {
            return iface_->access_simple(obj_, initiator, addr, buf, len, type, endian);
        }
        exception_type_t access_simple_inq(conf_object_t *initiator, physical_address_t addr, uint8 *buf, physical_address_t len, read_or_write_t type, endianness_t endian) const {
            return iface_->access_simple_inq(obj_, initiator, addr, buf, len, type, endian);
        }
        attr_value_t read(conf_object_t *initiator, physical_address_t addr, int length, int inquiry) const {
            return iface_->read(obj_, initiator, addr, length, inquiry);
        }
        exception_type_t write(conf_object_t *initiator, physical_address_t addr, attr_value_t data, int inquiry) const {
            return iface_->write(obj_, initiator, addr, data, inquiry);
        }
        uint64 fill(physical_address_t start, uint64 size, uint8 value, bool inquiry) const {
            return iface_->fill(obj_, start, size, value, inquiry);
        }

        const MemorySpaceInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const MemorySpaceInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return MEMORY_SPACE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr MemorySpaceInterface::ctype funcs {
                FromC::space_lookup,
                FromC::access,
                FromC::access_simple,
                FromC::access_simple_inq,
                FromC::read,
                FromC::write,
                nullptr,
                FromC::fill,
            };
            return &funcs;
        }
    };
};

class PortSpaceInterface {
  public:
    using ctype = port_space_interface_t;

    // Function override and implemented by user
    virtual exception_type_t port_operation(generic_transaction_t *mop, map_info_t map_info) = 0;
    virtual attr_value_t read(conf_object_t *initiator, physical_address_t addr, int length, int inquiry) = 0;
    virtual exception_type_t write(conf_object_t *initiator, physical_address_t addr, attr_value_t data, int inquiry) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static exception_type_t port_operation(conf_object_t *pspace_obj, generic_transaction_t *mop, map_info_t map_info) {
            return detail::get_interface<PortSpaceInterface>(pspace_obj)->port_operation(mop, map_info);
        }
        static attr_value_t read(conf_object_t *obj, conf_object_t *initiator, physical_address_t addr, int length, int inquiry) {
            return detail::get_interface<PortSpaceInterface>(obj)->read(initiator, addr, length, inquiry);
        }
        static exception_type_t write(conf_object_t *obj, conf_object_t *initiator, physical_address_t addr, attr_value_t data, int inquiry) {
            return detail::get_interface<PortSpaceInterface>(obj)->write(initiator, addr, data, inquiry);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const PortSpaceInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        exception_type_t port_operation(generic_transaction_t *mop, map_info_t map_info) const {
            return iface_->port_operation(obj_, mop, map_info);
        }
        attr_value_t read(conf_object_t *initiator, physical_address_t addr, int length, int inquiry) const {
            return iface_->read(obj_, initiator, addr, length, inquiry);
        }
        exception_type_t write(conf_object_t *initiator, physical_address_t addr, attr_value_t data, int inquiry) const {
            return iface_->write(obj_, initiator, addr, data, inquiry);
        }

        const PortSpaceInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const PortSpaceInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PORT_SPACE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr PortSpaceInterface::ctype funcs {
                FromC::port_operation,
                FromC::read,
                FromC::write,
            };
            return &funcs;
        }
    };
};

class TranslateInterface {
  public:
    using ctype = translate_interface_t;

    // Function override and implemented by user
    virtual conf_object_t * translate(generic_transaction_t *mem_op, map_info_t mapinfo) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static conf_object_t * translate(conf_object_t *obj, generic_transaction_t *mem_op, map_info_t mapinfo) {
            return detail::get_interface<TranslateInterface>(obj)->translate(mem_op, mapinfo);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const TranslateInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        conf_object_t * translate(generic_transaction_t *mem_op, map_info_t mapinfo) const {
            return iface_->translate(obj_, mem_op, mapinfo);
        }

        const TranslateInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const TranslateInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return TRANSLATE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr TranslateInterface::ctype funcs {
                FromC::translate,
            };
            return &funcs;
        }
    };
};

class BridgeInterface {
  public:
    using ctype = bridge_interface_t;

    // Function override and implemented by user
    virtual exception_type_t not_taken(conf_object_t *src_space, conf_object_t *dst_space, exception_type_t ex, generic_transaction_t *mem_op, map_info_t mapinfo) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static exception_type_t not_taken(conf_object_t *obj, conf_object_t *src_space, conf_object_t *dst_space, exception_type_t ex, generic_transaction_t *mem_op, map_info_t mapinfo) {
            return detail::get_interface<BridgeInterface>(obj)->not_taken(src_space, dst_space, ex, mem_op, mapinfo);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const BridgeInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        exception_type_t not_taken(conf_object_t *src_space, conf_object_t *dst_space, exception_type_t ex, generic_transaction_t *mem_op, map_info_t mapinfo) const {
            return iface_->not_taken(obj_, src_space, dst_space, ex, mem_op, mapinfo);
        }

        const BridgeInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const BridgeInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return BRIDGE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr BridgeInterface::ctype funcs {
                FromC::not_taken,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
