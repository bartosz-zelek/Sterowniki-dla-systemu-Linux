// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_STEP_H
#define SIMICS_CPP_MODEL_IFACE_STEP_H

#include "simics/model-iface/step.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class StepInterface {
  public:
    using ctype = step_interface_t;

    // Function override and implemented by user
    virtual pc_step_t get_step_count() = 0;
    virtual void post_step(event_class_t *evclass, conf_object_t *obj, pc_step_t steps, lang_void *user_data) = 0;
    virtual void cancel_step(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) = 0;
    virtual pc_step_t find_next_step(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) = 0;
    virtual attr_value_t events() = 0;
    virtual pc_step_t advance(pc_step_t steps) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static pc_step_t get_step_count(conf_object_t *queue) {
            return detail::get_interface<StepInterface>(queue)->get_step_count();
        }
        static void post_step(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, pc_step_t steps, lang_void *user_data) {
            detail::get_interface<StepInterface>(queue)->post_step(evclass, obj, steps, user_data);
        }
        static void cancel_step(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) {
            detail::get_interface<StepInterface>(queue)->cancel_step(evclass, obj, pred, match_data);
        }
        static pc_step_t find_next_step(conf_object_t *queue, event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) {
            return detail::get_interface<StepInterface>(queue)->find_next_step(evclass, obj, pred, match_data);
        }
        static attr_value_t events(conf_object_t *obj) {
            return detail::get_interface<StepInterface>(obj)->events();
        }
        static pc_step_t advance(conf_object_t *queue, pc_step_t steps) {
            return detail::get_interface<StepInterface>(queue)->advance(steps);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const StepInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        pc_step_t get_step_count() const {
            return iface_->get_step_count(obj_);
        }
        void post_step(event_class_t *evclass, conf_object_t *obj, pc_step_t steps, lang_void *user_data) const {
            iface_->post_step(obj_, evclass, obj, steps, user_data);
        }
        void cancel_step(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) const {
            iface_->cancel_step(obj_, evclass, obj, pred, match_data);
        }
        pc_step_t find_next_step(event_class_t *evclass, conf_object_t *obj, int (*pred)(lang_void *data, lang_void *match_data), lang_void *match_data) const {
            return iface_->find_next_step(obj_, evclass, obj, pred, match_data);
        }
        attr_value_t events() const {
            return iface_->events(obj_);
        }
        pc_step_t advance(pc_step_t steps) const {
            return iface_->advance(obj_, steps);
        }

        const StepInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const StepInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return STEP_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr StepInterface::ctype funcs {
                FromC::get_step_count,
                FromC::post_step,
                FromC::cancel_step,
                FromC::find_next_step,
                FromC::events,
                FromC::advance,
            };
            return &funcs;
        }
    };
};

class StepCycleRatioInterface {
  public:
    using ctype = step_cycle_ratio_interface_t;

    // Function override and implemented by user
    virtual step_cycle_ratio_t get_ratio() = 0;
    virtual void set_ratio(uint32 steps, uint32 cycles) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static step_cycle_ratio_t get_ratio(conf_object_t *obj) {
            return detail::get_interface<StepCycleRatioInterface>(obj)->get_ratio();
        }
        static void set_ratio(conf_object_t *obj, uint32 steps, uint32 cycles) {
            detail::get_interface<StepCycleRatioInterface>(obj)->set_ratio(steps, cycles);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const StepCycleRatioInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        step_cycle_ratio_t get_ratio() const {
            return iface_->get_ratio(obj_);
        }
        void set_ratio(uint32 steps, uint32 cycles) const {
            iface_->set_ratio(obj_, steps, cycles);
        }

        const StepCycleRatioInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const StepCycleRatioInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return STEP_CYCLE_RATIO_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr StepCycleRatioInterface::ctype funcs {
                FromC::get_ratio,
                FromC::set_ratio,
            };
            return &funcs;
        }
    };
};

class StallInterface {
  public:
    using ctype = stall_interface_t;

    // Function override and implemented by user
    virtual cycles_t get_stall_cycles() = 0;
    virtual void set_stall_cycles(cycles_t cycles) = 0;
    virtual cycles_t get_total_stall_cycles() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cycles_t get_stall_cycles(conf_object_t *obj) {
            return detail::get_interface<StallInterface>(obj)->get_stall_cycles();
        }
        static void set_stall_cycles(conf_object_t *obj, cycles_t cycles) {
            detail::get_interface<StallInterface>(obj)->set_stall_cycles(cycles);
        }
        static cycles_t get_total_stall_cycles(conf_object_t *obj) {
            return detail::get_interface<StallInterface>(obj)->get_total_stall_cycles();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const StallInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cycles_t get_stall_cycles() const {
            return iface_->get_stall_cycles(obj_);
        }
        void set_stall_cycles(cycles_t cycles) const {
            iface_->set_stall_cycles(obj_, cycles);
        }
        cycles_t get_total_stall_cycles() const {
            return iface_->get_total_stall_cycles(obj_);
        }

        const StallInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const StallInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return STALL_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr StallInterface::ctype funcs {
                FromC::get_stall_cycles,
                FromC::set_stall_cycles,
                FromC::get_total_stall_cycles,
            };
            return &funcs;
        }
    };
};

class StepInfoInterface {
  public:
    using ctype = step_info_interface_t;

    // Function override and implemented by user
    virtual pc_step_t get_halt_steps() = 0;
    virtual void set_halt_steps(pc_step_t steps) = 0;
    virtual pc_step_t get_ffwd_steps() = 0;
    virtual void set_ffwd_steps(pc_step_t steps) = 0;
    virtual pc_step_t get_ma_steps() = 0;
    virtual void set_ma_steps(pc_step_t steps) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static pc_step_t get_halt_steps(conf_object_t *obj) {
            return detail::get_interface<StepInfoInterface>(obj)->get_halt_steps();
        }
        static void set_halt_steps(conf_object_t *obj, pc_step_t steps) {
            detail::get_interface<StepInfoInterface>(obj)->set_halt_steps(steps);
        }
        static pc_step_t get_ffwd_steps(conf_object_t *obj) {
            return detail::get_interface<StepInfoInterface>(obj)->get_ffwd_steps();
        }
        static void set_ffwd_steps(conf_object_t *obj, pc_step_t steps) {
            detail::get_interface<StepInfoInterface>(obj)->set_ffwd_steps(steps);
        }
        static pc_step_t get_ma_steps(conf_object_t *obj) {
            return detail::get_interface<StepInfoInterface>(obj)->get_ma_steps();
        }
        static void set_ma_steps(conf_object_t *obj, pc_step_t steps) {
            detail::get_interface<StepInfoInterface>(obj)->set_ma_steps(steps);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const StepInfoInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        pc_step_t get_halt_steps() const {
            return iface_->get_halt_steps(obj_);
        }
        void set_halt_steps(pc_step_t steps) const {
            iface_->set_halt_steps(obj_, steps);
        }
        pc_step_t get_ffwd_steps() const {
            return iface_->get_ffwd_steps(obj_);
        }
        void set_ffwd_steps(pc_step_t steps) const {
            iface_->set_ffwd_steps(obj_, steps);
        }
        pc_step_t get_ma_steps() const {
            return iface_->get_ma_steps(obj_);
        }
        void set_ma_steps(pc_step_t steps) const {
            iface_->set_ma_steps(obj_, steps);
        }

        const StepInfoInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const StepInfoInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return STEP_INFO_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr StepInfoInterface::ctype funcs {
                FromC::get_halt_steps,
                FromC::set_halt_steps,
                FromC::get_ffwd_steps,
                FromC::set_ffwd_steps,
                FromC::get_ma_steps,
                FromC::set_ma_steps,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
