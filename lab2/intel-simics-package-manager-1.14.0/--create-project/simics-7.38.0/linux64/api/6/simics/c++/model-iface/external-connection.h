// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_EXTERNAL_CONNECTION_H
#define SIMICS_CPP_MODEL_IFACE_EXTERNAL_CONNECTION_H

#include "simics/model-iface/external-connection.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class ExternalConnectionCtlInterface {
  public:
    using ctype = external_connection_ctl_interface_t;

    // Function override and implemented by user
    virtual void accept(uint64 id, lang_void *cookie, bool blocking_read) = 0;
    virtual ssize_t read(lang_void *cookie, buffer_t buffer) = 0;
    virtual ssize_t write(lang_void *cookie, bytes_t bytes) = 0;
    virtual void write_async(lang_void *cookie, bytes_t bytes) = 0;
    virtual bool has_error(lang_void *cookie) = 0;
    virtual void notify(lang_void *cookie, notify_mode_t notify_mode, exec_mode_t exec_mode, bool active) = 0;
    virtual void close(lang_void *cookie) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void accept(conf_object_t *obj, uint64 id, lang_void *cookie, bool blocking_read) {
            detail::get_interface<ExternalConnectionCtlInterface>(obj)->accept(id, cookie, blocking_read);
        }
        static ssize_t read(conf_object_t *obj, lang_void *cookie, buffer_t buffer) {
            return detail::get_interface<ExternalConnectionCtlInterface>(obj)->read(cookie, buffer);
        }
        static ssize_t write(conf_object_t *obj, lang_void *cookie, bytes_t bytes) {
            return detail::get_interface<ExternalConnectionCtlInterface>(obj)->write(cookie, bytes);
        }
        static void write_async(conf_object_t *obj, lang_void *cookie, bytes_t bytes) {
            detail::get_interface<ExternalConnectionCtlInterface>(obj)->write_async(cookie, bytes);
        }
        static bool has_error(conf_object_t *obj, lang_void *cookie) {
            return detail::get_interface<ExternalConnectionCtlInterface>(obj)->has_error(cookie);
        }
        static void notify(conf_object_t *obj, lang_void *cookie, notify_mode_t notify_mode, exec_mode_t exec_mode, bool active) {
            detail::get_interface<ExternalConnectionCtlInterface>(obj)->notify(cookie, notify_mode, exec_mode, active);
        }
        static void close(conf_object_t *obj, lang_void *cookie) {
            detail::get_interface<ExternalConnectionCtlInterface>(obj)->close(cookie);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ExternalConnectionCtlInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void accept(uint64 id, lang_void *cookie, bool blocking_read) const {
            iface_->accept(obj_, id, cookie, blocking_read);
        }
        ssize_t read(lang_void *cookie, buffer_t buffer) const {
            return iface_->read(obj_, cookie, buffer);
        }
        ssize_t write(lang_void *cookie, bytes_t bytes) const {
            return iface_->write(obj_, cookie, bytes);
        }
        void write_async(lang_void *cookie, bytes_t bytes) const {
            iface_->write_async(obj_, cookie, bytes);
        }
        bool has_error(lang_void *cookie) const {
            return iface_->has_error(obj_, cookie);
        }
        void notify(lang_void *cookie, notify_mode_t notify_mode, exec_mode_t exec_mode, bool active) const {
            iface_->notify(obj_, cookie, notify_mode, exec_mode, active);
        }
        void close(lang_void *cookie) const {
            iface_->close(obj_, cookie);
        }

        const ExternalConnectionCtlInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ExternalConnectionCtlInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return EXTERNAL_CONNECTION_CTL_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ExternalConnectionCtlInterface::ctype funcs {
                FromC::accept,
                FromC::read,
                FromC::write,
                FromC::write_async,
                FromC::has_error,
                FromC::notify,
                FromC::close,
            };
            return &funcs;
        }
    };
};

class ExternalConnectionEventsInterface {
  public:
    using ctype = external_connection_events_interface_t;

    // Function override and implemented by user
    virtual void on_accept(conf_object_t *server, uint64 id) = 0;
    virtual void on_input(lang_void *cookie) = 0;
    virtual void can_write(lang_void *cookie) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void on_accept(conf_object_t *obj, conf_object_t *server, uint64 id) {
            detail::get_interface<ExternalConnectionEventsInterface>(obj)->on_accept(server, id);
        }
        static void on_input(conf_object_t *obj, lang_void *cookie) {
            detail::get_interface<ExternalConnectionEventsInterface>(obj)->on_input(cookie);
        }
        static void can_write(conf_object_t *obj, lang_void *cookie) {
            detail::get_interface<ExternalConnectionEventsInterface>(obj)->can_write(cookie);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ExternalConnectionEventsInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void on_accept(conf_object_t *server, uint64 id) const {
            iface_->on_accept(obj_, server, id);
        }
        void on_input(lang_void *cookie) const {
            iface_->on_input(obj_, cookie);
        }
        void can_write(lang_void *cookie) const {
            iface_->can_write(obj_, cookie);
        }

        const ExternalConnectionEventsInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ExternalConnectionEventsInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return EXTERNAL_CONNECTION_EVENTS_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ExternalConnectionEventsInterface::ctype funcs {
                FromC::on_accept,
                FromC::on_input,
                FromC::can_write,
            };
            return &funcs;
        }
    };
};

class TcpConnectionInfoInterface {
  public:
    using ctype = tcp_connection_info_interface_t;

    // Function override and implemented by user
    virtual uint16 remote_port(lang_void *cookie) = 0;
    virtual bytes_t remote_ip(lang_void *cookie) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static uint16 remote_port(conf_object_t *obj, lang_void *cookie) {
            return detail::get_interface<TcpConnectionInfoInterface>(obj)->remote_port(cookie);
        }
        static bytes_t remote_ip(conf_object_t *obj, lang_void *cookie) {
            return detail::get_interface<TcpConnectionInfoInterface>(obj)->remote_ip(cookie);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const TcpConnectionInfoInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        uint16 remote_port(lang_void *cookie) const {
            return iface_->remote_port(obj_, cookie);
        }
        bytes_t remote_ip(lang_void *cookie) const {
            return iface_->remote_ip(obj_, cookie);
        }

        const TcpConnectionInfoInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const TcpConnectionInfoInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return TCP_CONNECTION_INFO_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr TcpConnectionInfoInterface::ctype funcs {
                FromC::remote_port,
                FromC::remote_ip,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
