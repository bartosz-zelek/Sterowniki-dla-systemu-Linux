// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_EXECUTE_H
#define SIMICS_CPP_MODEL_IFACE_EXECUTE_H

#include "simics/model-iface/execute.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class ExecuteInterface {
  public:
    using ctype = execute_interface_t;

    // Function override and implemented by user
    virtual void run() = 0;
    virtual void stop() = 0;
    virtual void switch_in() = 0;
    virtual void switch_out() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void run(conf_object_t *obj) {
            detail::get_interface<ExecuteInterface>(obj)->run();
        }
        static void stop(conf_object_t *obj) {
            detail::get_interface<ExecuteInterface>(obj)->stop();
        }
        static void switch_in(conf_object_t *obj) {
            detail::get_interface<ExecuteInterface>(obj)->switch_in();
        }
        static void switch_out(conf_object_t *obj) {
            detail::get_interface<ExecuteInterface>(obj)->switch_out();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ExecuteInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void run() const {
            iface_->run(obj_);
        }
        void stop() const {
            iface_->stop(obj_);
        }
        void switch_in() const {
            iface_->switch_in(obj_);
        }
        void switch_out() const {
            iface_->switch_out(obj_);
        }

        const ExecuteInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ExecuteInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return EXECUTE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ExecuteInterface::ctype funcs {
                FromC::run,
                FromC::stop,
                FromC::switch_in,
                FromC::switch_out,
            };
            return &funcs;
        }
    };
};

class CellInspectionInterface {
  public:
    using ctype = cell_inspection_interface_t;

    // Function override and implemented by user
    virtual void set_current_processor_obj(conf_object_t *cpu_obj) = 0;
    virtual void set_current_step_obj(conf_object_t *step_obj) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void set_current_processor_obj(conf_object_t *obj, conf_object_t *cpu_obj) {
            detail::get_interface<CellInspectionInterface>(obj)->set_current_processor_obj(cpu_obj);
        }
        static void set_current_step_obj(conf_object_t *obj, conf_object_t *step_obj) {
            detail::get_interface<CellInspectionInterface>(obj)->set_current_step_obj(step_obj);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const CellInspectionInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void set_current_processor_obj(conf_object_t *cpu_obj) const {
            iface_->set_current_processor_obj(obj_, cpu_obj);
        }
        void set_current_step_obj(conf_object_t *step_obj) const {
            iface_->set_current_step_obj(obj_, step_obj);
        }

        const CellInspectionInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const CellInspectionInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return CELL_INSPECTION_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr CellInspectionInterface::ctype funcs {
                FromC::set_current_processor_obj,
                FromC::set_current_step_obj,
            };
            return &funcs;
        }
    };
};

class ExecuteControlInterface {
  public:
    using ctype = execute_control_interface_t;

    // Function override and implemented by user
    virtual void message_pending() = 0;
    virtual void yield_request() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void message_pending(conf_object_t *obj) {
            detail::get_interface<ExecuteControlInterface>(obj)->message_pending();
        }
        static void yield_request(conf_object_t *obj) {
            detail::get_interface<ExecuteControlInterface>(obj)->yield_request();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ExecuteControlInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void message_pending() const {
            iface_->message_pending(obj_);
        }
        void yield_request() const {
            iface_->yield_request(obj_);
        }

        const ExecuteControlInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ExecuteControlInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return EXECUTE_CONTROL_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ExecuteControlInterface::ctype funcs {
                FromC::message_pending,
                FromC::yield_request,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
