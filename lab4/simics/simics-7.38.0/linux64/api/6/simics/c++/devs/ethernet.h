// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_DEVS_ETHERNET_H
#define SIMICS_CPP_DEVS_ETHERNET_H

#include "simics/devs/ethernet.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class EthernetCommonInterface {
  public:
    using ctype = ethernet_common_interface_t;

    // Function override and implemented by user
    virtual void frame(const frags_t *frame, eth_frame_crc_status_t crc_status) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void frame(conf_object_t *obj, const frags_t *frame, eth_frame_crc_status_t crc_status) {
            detail::get_interface<EthernetCommonInterface>(obj)->frame(frame, crc_status);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const EthernetCommonInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void frame(const frags_t *frame, eth_frame_crc_status_t crc_status) const {
            iface_->frame(obj_, frame, crc_status);
        }

        const EthernetCommonInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const EthernetCommonInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ETHERNET_COMMON_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr EthernetCommonInterface::ctype funcs {
                FromC::frame,
            };
            return &funcs;
        }
    };
};

class EthernetCableInterface {
  public:
    using ctype = ethernet_cable_interface_t;

    // Function override and implemented by user
    virtual void link_status(bool link_up) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void link_status(conf_object_t *ep, bool link_up) {
            detail::get_interface<EthernetCableInterface>(ep)->link_status(link_up);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const EthernetCableInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void link_status(bool link_up) const {
            iface_->link_status(obj_, link_up);
        }

        const EthernetCableInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const EthernetCableInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ETHERNET_CABLE_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr EthernetCableInterface::ctype funcs {
                FromC::link_status,
            };
            return &funcs;
        }
    };
};

class EthernetSnoopInterface {
  public:
    using ctype = ethernet_snoop_interface_t;

    // Function override and implemented by user
    virtual conf_object_t * attach(conf_object_t *clock, ethernet_link_snoop_t snoop_fun, lang_void *user_data) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static conf_object_t * attach(conf_object_t *link, conf_object_t *clock, ethernet_link_snoop_t snoop_fun, lang_void *user_data) {
            return detail::get_interface<EthernetSnoopInterface>(link)->attach(clock, snoop_fun, user_data);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const EthernetSnoopInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        conf_object_t * attach(conf_object_t *clock, ethernet_link_snoop_t snoop_fun, lang_void *user_data) const {
            return iface_->attach(obj_, clock, snoop_fun, user_data);
        }

        const EthernetSnoopInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const EthernetSnoopInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ETHERNET_SNOOP_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr EthernetSnoopInterface::ctype funcs {
                FromC::attach,
            };
            return &funcs;
        }
    };
};

class EthernetVlanSnoopInterface {
  public:
    using ctype = ethernet_vlan_snoop_interface_t;

    // Function override and implemented by user
    virtual conf_object_t * attach(conf_object_t *clock, ethernet_link_snoop_t snoop_fun, lang_void *user_data, uint16 vlan_id, bool is_vlan_trunk) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static conf_object_t * attach(conf_object_t *link, conf_object_t *clock, ethernet_link_snoop_t snoop_fun, lang_void *user_data, uint16 vlan_id, bool is_vlan_trunk) {
            return detail::get_interface<EthernetVlanSnoopInterface>(link)->attach(clock, snoop_fun, user_data, vlan_id, is_vlan_trunk);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const EthernetVlanSnoopInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        conf_object_t * attach(conf_object_t *clock, ethernet_link_snoop_t snoop_fun, lang_void *user_data, uint16 vlan_id, bool is_vlan_trunk) const {
            return iface_->attach(obj_, clock, snoop_fun, user_data, vlan_id, is_vlan_trunk);
        }

        const EthernetVlanSnoopInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const EthernetVlanSnoopInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return ETHERNET_VLAN_SNOOP_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr EthernetVlanSnoopInterface::ctype funcs {
                FromC::attach,
            };
            return &funcs;
        }
    };
};

class NetworkBreakpointInterface {
  public:
    using ctype = network_breakpoint_interface_t;

    // Function override and implemented by user
    virtual int64 add(bytes_t src_mac_addr, bytes_t dst_mac_addr, int ether_type, break_net_cb_t cb, bool once, int64 bp_id) = 0;
    virtual void remove(int64 bp_id) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static int64 add(conf_object_t *obj, bytes_t src_mac_addr, bytes_t dst_mac_addr, int ether_type, break_net_cb_t cb, bool once, int64 bp_id) {
            return detail::get_interface<NetworkBreakpointInterface>(obj)->add(src_mac_addr, dst_mac_addr, ether_type, cb, once, bp_id);
        }
        static void remove(conf_object_t *obj, int64 bp_id) {
            detail::get_interface<NetworkBreakpointInterface>(obj)->remove(bp_id);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const NetworkBreakpointInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        int64 add(bytes_t src_mac_addr, bytes_t dst_mac_addr, int ether_type, break_net_cb_t cb, bool once, int64 bp_id) const {
            return iface_->add(obj_, src_mac_addr, dst_mac_addr, ether_type, cb, once, bp_id);
        }
        void remove(int64 bp_id) const {
            iface_->remove(obj_, bp_id);
        }

        const NetworkBreakpointInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const NetworkBreakpointInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return NETWORK_BREAKPOINT_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr NetworkBreakpointInterface::ctype funcs {
                FromC::add,
                FromC::remove,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
