// -*- mode: C++; c-file-style: "virtutech-c++" -*-

/*
  Â© 2025 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

// This file is generated by the script bin/gen-cc-interface

#ifndef SIMICS_CPP_MODEL_IFACE_PROCESSOR_INFO_H
#define SIMICS_CPP_MODEL_IFACE_PROCESSOR_INFO_H

#include "simics/model-iface/processor-info.h"

#include <simics/detail/conf-object-util.h>  // get_interface
#include <simics/iface/interface-info.h>

namespace simics {
namespace iface {

class ProcessorInfoInterface {
  public:
    using ctype = processor_info_interface_t;

    // Function override and implemented by user
    virtual tuple_int_string_t disassemble(generic_address_t address, attr_value_t instruction_data, int sub_operation) = 0;
    virtual void set_program_counter(logical_address_t pc) = 0;
    virtual logical_address_t get_program_counter() = 0;
    virtual physical_block_t logical_to_physical(logical_address_t address, access_t access_type) = 0;
    virtual int enable_processor() = 0;
    virtual int disable_processor() = 0;
    virtual int get_enabled() = 0;
    virtual cpu_endian_t get_endian() = 0;
    virtual conf_object_t * get_physical_memory() = 0;
    virtual int get_logical_address_width() = 0;
    virtual int get_physical_address_width() = 0;
    virtual const char * architecture() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static tuple_int_string_t disassemble(conf_object_t *obj, generic_address_t address, attr_value_t instruction_data, int sub_operation) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->disassemble(address, instruction_data, sub_operation);
        }
        static void set_program_counter(conf_object_t *obj, logical_address_t pc) {
            detail::get_interface<ProcessorInfoInterface>(obj)->set_program_counter(pc);
        }
        static logical_address_t get_program_counter(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->get_program_counter();
        }
        static physical_block_t logical_to_physical(conf_object_t *obj, logical_address_t address, access_t access_type) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->logical_to_physical(address, access_type);
        }
        static int enable_processor(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->enable_processor();
        }
        static int disable_processor(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->disable_processor();
        }
        static int get_enabled(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->get_enabled();
        }
        static cpu_endian_t get_endian(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->get_endian();
        }
        static conf_object_t * get_physical_memory(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->get_physical_memory();
        }
        static int get_logical_address_width(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->get_logical_address_width();
        }
        static int get_physical_address_width(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->get_physical_address_width();
        }
        static const char * architecture(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoInterface>(obj)->architecture();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ProcessorInfoInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        tuple_int_string_t disassemble(generic_address_t address, attr_value_t instruction_data, int sub_operation) const {
            return iface_->disassemble(obj_, address, instruction_data, sub_operation);
        }
        void set_program_counter(logical_address_t pc) const {
            iface_->set_program_counter(obj_, pc);
        }
        logical_address_t get_program_counter() const {
            return iface_->get_program_counter(obj_);
        }
        physical_block_t logical_to_physical(logical_address_t address, access_t access_type) const {
            return iface_->logical_to_physical(obj_, address, access_type);
        }
        int enable_processor() const {
            return iface_->enable_processor(obj_);
        }
        int disable_processor() const {
            return iface_->disable_processor(obj_);
        }
        int get_enabled() const {
            return iface_->get_enabled(obj_);
        }
        cpu_endian_t get_endian() const {
            return iface_->get_endian(obj_);
        }
        conf_object_t * get_physical_memory() const {
            return iface_->get_physical_memory(obj_);
        }
        int get_logical_address_width() const {
            return iface_->get_logical_address_width(obj_);
        }
        int get_physical_address_width() const {
            return iface_->get_physical_address_width(obj_);
        }
        const char * architecture() const {
            return iface_->architecture(obj_);
        }

        const ProcessorInfoInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ProcessorInfoInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PROCESSOR_INFO_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ProcessorInfoInterface::ctype funcs {
                FromC::disassemble,
                FromC::set_program_counter,
                FromC::get_program_counter,
                FromC::logical_to_physical,
                FromC::enable_processor,
                FromC::disable_processor,
                FromC::get_enabled,
                FromC::get_endian,
                FromC::get_physical_memory,
                FromC::get_logical_address_width,
                FromC::get_physical_address_width,
                FromC::architecture,
            };
            return &funcs;
        }
    };
};

class ProcessorInfoV2Interface {
  public:
    using ctype = processor_info_v2_interface_t;

    // Function override and implemented by user
    virtual tuple_int_string_t disassemble(generic_address_t address, attr_value_t instruction_data, int sub_operation) = 0;
    virtual void set_program_counter(logical_address_t pc) = 0;
    virtual logical_address_t get_program_counter() = 0;
    virtual physical_block_t logical_to_physical(logical_address_t address, access_t access_type) = 0;
    virtual processor_mode_t get_processor_mode() = 0;
    virtual int enable_processor() = 0;
    virtual int disable_processor() = 0;
    virtual int get_enabled() = 0;
    virtual cpu_endian_t get_endian() = 0;
    virtual conf_object_t * get_physical_memory() = 0;
    virtual int get_logical_address_width() = 0;
    virtual int get_physical_address_width() = 0;
    virtual const char * architecture() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static tuple_int_string_t disassemble(conf_object_t *obj, generic_address_t address, attr_value_t instruction_data, int sub_operation) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->disassemble(address, instruction_data, sub_operation);
        }
        static void set_program_counter(conf_object_t *obj, logical_address_t pc) {
            detail::get_interface<ProcessorInfoV2Interface>(obj)->set_program_counter(pc);
        }
        static logical_address_t get_program_counter(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_program_counter();
        }
        static physical_block_t logical_to_physical(conf_object_t *obj, logical_address_t address, access_t access_type) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->logical_to_physical(address, access_type);
        }
        static processor_mode_t get_processor_mode(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_processor_mode();
        }
        static int enable_processor(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->enable_processor();
        }
        static int disable_processor(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->disable_processor();
        }
        static int get_enabled(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_enabled();
        }
        static cpu_endian_t get_endian(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_endian();
        }
        static conf_object_t * get_physical_memory(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_physical_memory();
        }
        static int get_logical_address_width(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_logical_address_width();
        }
        static int get_physical_address_width(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->get_physical_address_width();
        }
        static const char * architecture(conf_object_t *obj) {
            return detail::get_interface<ProcessorInfoV2Interface>(obj)->architecture();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ProcessorInfoV2Interface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        tuple_int_string_t disassemble(generic_address_t address, attr_value_t instruction_data, int sub_operation) const {
            return iface_->disassemble(obj_, address, instruction_data, sub_operation);
        }
        void set_program_counter(logical_address_t pc) const {
            iface_->set_program_counter(obj_, pc);
        }
        logical_address_t get_program_counter() const {
            return iface_->get_program_counter(obj_);
        }
        physical_block_t logical_to_physical(logical_address_t address, access_t access_type) const {
            return iface_->logical_to_physical(obj_, address, access_type);
        }
        processor_mode_t get_processor_mode() const {
            return iface_->get_processor_mode(obj_);
        }
        int enable_processor() const {
            return iface_->enable_processor(obj_);
        }
        int disable_processor() const {
            return iface_->disable_processor(obj_);
        }
        int get_enabled() const {
            return iface_->get_enabled(obj_);
        }
        cpu_endian_t get_endian() const {
            return iface_->get_endian(obj_);
        }
        conf_object_t * get_physical_memory() const {
            return iface_->get_physical_memory(obj_);
        }
        int get_logical_address_width() const {
            return iface_->get_logical_address_width(obj_);
        }
        int get_physical_address_width() const {
            return iface_->get_physical_address_width(obj_);
        }
        const char * architecture() const {
            return iface_->architecture(obj_);
        }

        const ProcessorInfoV2Interface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ProcessorInfoV2Interface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PROCESSOR_INFO_V2_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ProcessorInfoV2Interface::ctype funcs {
                FromC::disassemble,
                FromC::set_program_counter,
                FromC::get_program_counter,
                FromC::logical_to_physical,
                FromC::get_processor_mode,
                FromC::enable_processor,
                FromC::disable_processor,
                FromC::get_enabled,
                FromC::get_endian,
                FromC::get_physical_memory,
                FromC::get_logical_address_width,
                FromC::get_physical_address_width,
                FromC::architecture,
            };
            return &funcs;
        }
    };
};

class ProcessorEndianInterface {
  public:
    using ctype = processor_endian_interface_t;

    // Function override and implemented by user
    virtual cpu_endian_t get_instruction_endian() = 0;
    virtual cpu_endian_t get_data_endian() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static cpu_endian_t get_instruction_endian(conf_object_t *obj) {
            return detail::get_interface<ProcessorEndianInterface>(obj)->get_instruction_endian();
        }
        static cpu_endian_t get_data_endian(conf_object_t *obj) {
            return detail::get_interface<ProcessorEndianInterface>(obj)->get_data_endian();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ProcessorEndianInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        cpu_endian_t get_instruction_endian() const {
            return iface_->get_instruction_endian(obj_);
        }
        cpu_endian_t get_data_endian() const {
            return iface_->get_data_endian(obj_);
        }

        const ProcessorEndianInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ProcessorEndianInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PROCESSOR_ENDIAN_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ProcessorEndianInterface::ctype funcs {
                FromC::get_instruction_endian,
                FromC::get_data_endian,
            };
            return &funcs;
        }
    };
};

class ProcessorCliInterface {
  public:
    using ctype = processor_cli_interface_t;

    // Function override and implemented by user
    virtual tuple_int_string_t get_disassembly(const char *addr_prefix, generic_address_t address, bool print_cpu, const char *mnemonic) = 0;
    virtual char * get_pregs(bool all) = 0;
    virtual attr_value_t get_diff_regs() = 0;
    virtual char * get_pending_exception_string() = 0;
    virtual char * get_address_prefix() = 0;
    virtual physical_block_t translate_to_physical(const char *prefix, generic_address_t address) = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static tuple_int_string_t get_disassembly(conf_object_t *obj, const char *addr_prefix, generic_address_t address, bool print_cpu, const char *mnemonic) {
            return detail::get_interface<ProcessorCliInterface>(obj)->get_disassembly(addr_prefix, address, print_cpu, mnemonic);
        }
        static char * get_pregs(conf_object_t *cpu, bool all) {
            return detail::get_interface<ProcessorCliInterface>(cpu)->get_pregs(all);
        }
        static attr_value_t get_diff_regs(conf_object_t *obj) {
            return detail::get_interface<ProcessorCliInterface>(obj)->get_diff_regs();
        }
        static char * get_pending_exception_string(conf_object_t *obj) {
            return detail::get_interface<ProcessorCliInterface>(obj)->get_pending_exception_string();
        }
        static char * get_address_prefix(conf_object_t *obj) {
            return detail::get_interface<ProcessorCliInterface>(obj)->get_address_prefix();
        }
        static physical_block_t translate_to_physical(conf_object_t *obj, const char *prefix, generic_address_t address) {
            return detail::get_interface<ProcessorCliInterface>(obj)->translate_to_physical(prefix, address);
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ProcessorCliInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        tuple_int_string_t get_disassembly(const char *addr_prefix, generic_address_t address, bool print_cpu, const char *mnemonic) const {
            return iface_->get_disassembly(obj_, addr_prefix, address, print_cpu, mnemonic);
        }
        char * get_pregs(bool all) const {
            return iface_->get_pregs(obj_, all);
        }
        attr_value_t get_diff_regs() const {
            return iface_->get_diff_regs(obj_);
        }
        char * get_pending_exception_string() const {
            return iface_->get_pending_exception_string(obj_);
        }
        char * get_address_prefix() const {
            return iface_->get_address_prefix(obj_);
        }
        physical_block_t translate_to_physical(const char *prefix, generic_address_t address) const {
            return iface_->translate_to_physical(obj_, prefix, address);
        }

        const ProcessorCliInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ProcessorCliInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PROCESSOR_CLI_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ProcessorCliInterface::ctype funcs {
                FromC::get_disassembly,
                FromC::get_pregs,
                FromC::get_diff_regs,
                FromC::get_pending_exception_string,
                FromC::get_address_prefix,
                FromC::translate_to_physical,
            };
            return &funcs;
        }
    };
};

class OpcodeInfoInterface {
  public:
    using ctype = opcode_info_interface_t;

    // Function override and implemented by user
    virtual opcode_length_info_t get_opcode_length_info() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static opcode_length_info_t get_opcode_length_info(conf_object_t *obj) {
            return detail::get_interface<OpcodeInfoInterface>(obj)->get_opcode_length_info();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const OpcodeInfoInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        opcode_length_info_t get_opcode_length_info() const {
            return iface_->get_opcode_length_info(obj_);
        }

        const OpcodeInfoInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const OpcodeInfoInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return OPCODE_INFO_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr OpcodeInfoInterface::ctype funcs {
                FromC::get_opcode_length_info,
            };
            return &funcs;
        }
    };
};

class ProcessorGuiInterface {
  public:
    using ctype = processor_gui_interface_t;

    // Function override and implemented by user
    virtual void dummy() = 0;

    // Function convert C interface call to C++ interface call
    class FromC {
      public:
        static void dummy(conf_object_t *obj) {
            detail::get_interface<ProcessorGuiInterface>(obj)->dummy();
        }
    };

    // Function convert C++ interface call to C interface call
    class ToC {
      public:
        ToC() : obj_(nullptr), iface_(nullptr) {}
        ToC(conf_object_t *obj, const ProcessorGuiInterface::ctype *iface)
            : obj_(obj), iface_(iface) {}

        void dummy() const {
            iface_->dummy(obj_);
        }

        const ProcessorGuiInterface::ctype *get_iface() const {
            return iface_;
        }

      private:
        conf_object_t *obj_;
        const ProcessorGuiInterface::ctype *iface_;
    };

    class Info : public InterfaceInfo {
      public:
        // InterfaceInfo
        std::string name() const override { return PROCESSOR_GUI_INTERFACE; }
        const interface_t *cstruct() const override {
            static constexpr ProcessorGuiInterface::ctype funcs {
                FromC::dummy,
            };
            return &funcs;
        }
    };
};

}  // namespace iface
}  // namespace simics

#endif
